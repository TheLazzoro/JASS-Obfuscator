globals
//globals from Alloc:
constant boolean LIBRARY_Alloc=true
//endglobals from Alloc
//globals from DamageEngine:
constant boolean LIBRARY_DamageEngine=true
constant boolean DamageEngine__USE_GUI= true
                                                       
constant boolean DamageEngine__USE_SCALING= DamageEngine__USE_GUI
constant boolean DamageEngine__USE_EXTRA= true
constant boolean DamageEngine__USE_ARMOR_MOD= true
constant boolean DamageEngine__USE_MELEE_RANGE= true
constant boolean DamageEngine__USE_LETHAL= true
   
constant integer DamageEngine__LIMBO= 16
   
constant integer DamageEngine_TYPE_CODE= 1
constant integer DamageEngine_TYPE_PURE= 2
constant real DamageEngine__DEATH_VAL= 0.405
timer DamageEngine__alarm= CreateTimer()
boolean DamageEngine__alarmSet= false
    //Values to track the original pre-spirit Link/defensive damage values
integer DamageEngine__lastInstance= 0
boolean DamageEngine__canKick= true
boolean DamageEngine__totem= false
boolean array DamageEngine__attacksImmune
boolean array DamageEngine__damagesImmune
    //Made global in order to use enable/disable behavior.
trigger DamageEngine__t1= CreateTrigger()
trigger DamageEngine__t2= CreateTrigger()
trigger DamageEngine__t3= CreateTrigger()
    //These variables coincide with Blizzard's "limitop" type definitions so as to enable users (GUI in particular) with some nice performance perks.
constant integer DamageEngine_FILTER_ATTACK= 0
constant integer DamageEngine_FILTER_MELEE= 1
constant integer DamageEngine_FILTER_OTHER= 2
constant integer DamageEngine_FILTER_RANGED= 3
constant integer DamageEngine_FILTER_SPELL= 4
constant integer DamageEngine_FILTER_CODE= 5
constant integer DamageEngine_FILTER_MAX= 6
integer DamageEngine__eventFilter= DamageEngine_FILTER_OTHER
boolean DamageEngine_inception= false
boolean DamageEngine__dreaming= false
integer DamageEngine__sleepLevel= 0
group DamageEngine__proclusGlobal= CreateGroup()
group DamageEngine__fischerMorrow= CreateGroup()
boolean DamageEngine__kicking= false
boolean DamageEngine__eventsRun= false
   
boolean DamageEngine__hasLethal= false
//endglobals from DamageEngine
//globals from ExtendableBonusSystem:
constant boolean LIBRARY_ExtendableBonusSystem=true
//endglobals from ExtendableBonusSystem
//globals from LineSegmentEnumeration:
constant boolean LIBRARY_LineSegmentEnumeration=true
//endglobals from LineSegmentEnumeration
//globals from MouseUtils:
constant boolean LIBRARY_MouseUtils=true
constant integer EVENT_MOUSE_UP= 0x400
constant integer EVENT_MOUSE_DOWN= 0x800
constant integer EVENT_MOUSE_MOVE= 0xC00
    //  Introduced in v1.0.2.3
    //  Commented out in v1.0.2.4
    // private constant real STARTUP_DELAY = 0.00
    // private constant boolean NO_DELAY   = false
    //  Introduced in v1.0.2.2
constant boolean MouseUtils__IMPL_LOCK= true
//endglobals from MouseUtils
//globals from RegisterPlayerUnitEvent:
constant boolean LIBRARY_RegisterPlayerUnitEvent=true
trigger array RegisterPlayerUnitEvent__t
//endglobals from RegisterPlayerUnitEvent
//globals from Table:
constant boolean LIBRARY_Table=true
integer Table__less= 0
integer Table__more= 8190
    //Configure it if you use more than 8190 "key" variables in your map (this will never happen though).
    
hashtable Table__ht= InitHashtable()
constant integer Table__sizeK=10
constant integer Table__listK=11
//endglobals from Table
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
        //How to tweak timer utils:
        // USE_HASH_TABLE = true  (new blue)
        //  * SAFEST
        //  * SLOWEST (though hash tables are kind of fast)
        //
        // USE_HASH_TABLE = false, USE_FLEXIBLE_OFFSET = true  (orange)
        //  * kinda safe (except there is a limit in the number of timers)
        //  * ALMOST FAST
        //
        // USE_HASH_TABLE = false, USE_FLEXIBLE_OFFSET = false (red)
        //  * THE FASTEST (though is only  faster than the previous method
        //                  after using the optimizer on the map)
        //  * THE LEAST SAFE ( you may have to tweak OFSSET manually for it to
        //                     work)
        //
constant boolean TimerUtils__USE_HASH_TABLE= true
constant boolean TimerUtils__USE_FLEXIBLE_OFFSET= false

constant integer TimerUtils__OFFSET= 0x100000
integer TimerUtils__VOFFSET= TimerUtils__OFFSET
             
        //Timers to preload at map init:
constant integer TimerUtils__QUANTITY= 256
       
        //Changing this  to something big will allow you to keep recycling
        // timers even when there are already AN INCREDIBLE AMOUNT of timers in
        // the stack. But it will make things far slower so that's probably a bad idea...
constant integer TimerUtils__ARRAY_SIZE= 8190

// processed:         integer array TimerUtils__data[TimerUtils__ARRAY_SIZE]
hashtable TimerUtils__ht
// processed:         timer array TimerUtils__tT[TimerUtils__ARRAY_SIZE]
integer TimerUtils__tN= 0
constant integer TimerUtils__HELD=0x28829022
        //use a totally random number here, the more improbable someone uses it, the better.
       
boolean TimerUtils__didinit= false
//endglobals from TimerUtils
//globals from VersionManager:
constant boolean LIBRARY_VersionManager=true
//endglobals from VersionManager
//globals from WorldBounds:
constant boolean LIBRARY_WorldBounds=true
//endglobals from WorldBounds
//globals from CooldownReduction:
constant boolean LIBRARY_CooldownReduction=true
//endglobals from CooldownReduction
//globals from DummyRecycler:
constant boolean LIBRARY_DummyRecycler=true
        //The rawcode of the Dummy Unit
constant integer DummyRecycler__DUMMY_ID= 'h00P'
      
        //The owner of the Dummy Unit
constant player DummyRecycler__OWNER= Player(14)
      
        //The number of indexed angle. The higher the value the:
        // - Lesser the turning time for the Dummy Units.
        // - Higher the total number of Dummy Units created at Map Initialization.
        //          Recommended Value: 10 (Max difference of 18 degrees)
constant integer DummyRecycler__ANGLES_COUNT= 10
      
        //The number of Dummy units per ANGLES_COUNT. The higher the value the:
        // - Higher the number of units that can be recycled per angle, when
        //   no more units are in queue, the system will resort to use CreateUnit.
        // - Higher the total number of Dummy Units created at Map Initialization.
        //    Recommended Value: 3 to 5 (for less overhead in Map Loading Screen)
constant integer DummyRecycler__STORED_UNIT_COUNT= 3
      
        //The maximum number of Dummy units that can exist. When the system resort
        //to using CreateUnit, the unit will be permanently added to the Dummy
        //List. To avoid spamming Dummy Units and having too much free Dummy
        //Units to allocate, the maximum number of Dummy Units is capped.
        //               Recommended Value: 80 to 120
constant integer DummyRecycler__MAX_DUMMY_COUNT= 100
      
        //When a certain angle have less than BORROW_REQUEST units in its list,
        //it will start to borrow Dummy Units from the list with the highest
        //Dummy Unit count.
        //      Recommended Value: Half of maximum STORED_UNIT_COUNT
constant integer DummyRecycler__BORROW_REQUEST= 5
      
        //It will only return a Dummy if the current dummy is close
        //to it's appropriate facing angle. This is to avoid returning
        //a Dummy which is still turning to face it's list angle.
constant real DummyRecycler__ANGLE_TOLERANCE= 10.0
      
        //An additional option to automatically hide recycled dummy units in the
        //corner of the map camera bounds
constant boolean DummyRecycler__HIDE_ON_MAP_CORNER= true
integer DummyRecycler__dummyCount= DummyRecycler__ANGLES_COUNT * DummyRecycler__STORED_UNIT_COUNT
real array DummyRecycler__angle
integer array DummyRecycler__count
integer array DummyRecycler__countHead
integer array DummyRecycler__countNext
integer array DummyRecycler__countPrev
integer array DummyRecycler__next
integer array DummyRecycler__prev
unit array DummyRecycler__dummy
integer DummyRecycler__upper
integer DummyRecycler__lower
integer DummyRecycler__lastInstance
constant real DummyRecycler__FACING_OFFSET= 180.0 / DummyRecycler__ANGLES_COUNT
//endglobals from DummyRecycler
//globals from ExtendableBonusesBasicBonuses:
constant boolean LIBRARY_ExtendableBonusesBasicBonuses=true
        //The abilities codes for each bonus
        //When pasting the abilities over to your map
        //their raw code should match the bonus here
constant integer ExtendableBonusesBasicBonuses__DAMAGE_ABILITY= 'Z001'
constant integer ExtendableBonusesBasicBonuses__ARMOR_ABILITY= 'Z002'
constant integer ExtendableBonusesBasicBonuses__STATS_ABILITY= 'Z003'
constant integer ExtendableBonusesBasicBonuses__HEALTH_ABILITY= 'Z004'
constant integer ExtendableBonusesBasicBonuses__MANA_ABILITY= 'Z005'
constant integer ExtendableBonusesBasicBonuses__HEALTHREGEN_ABILITY= 'Z006'
constant integer ExtendableBonusesBasicBonuses__MANAREGEN_ABILITY= 'Z007'
constant integer ExtendableBonusesBasicBonuses__ATTACKSPEED_ABILITY= 'Z008'
constant integer ExtendableBonusesBasicBonuses__MOVEMENTSPEED_ABILITY= 'Z009'
constant integer ExtendableBonusesBasicBonuses__SIGHT_RANGE_ABILITY= 'Z00A'
        //The abilities fields that are modified. For the sake of readability
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__DAMAGE_FIELD= ABILITY_ILF_ATTACK_BONUS
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__ARMOR_FIELD= ABILITY_ILF_DEFENSE_BONUS_IDEF
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__AGILITY_FIELD= ABILITY_ILF_AGILITY_BONUS
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__STRENGTH_FIELD= ABILITY_ILF_STRENGTH_BONUS_ISTR
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__INTELLIGENCE_FIELD= ABILITY_ILF_INTELLIGENCE_BONUS
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__HEALTH_FIELD= ABILITY_ILF_MAX_LIFE_GAINED
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__MANA_FIELD= ABILITY_ILF_MAX_MANA_GAINED
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__MOVEMENTSPEED_FIELD= ABILITY_ILF_MOVEMENT_SPEED_BONUS
constant abilityintegerlevelfield ExtendableBonusesBasicBonuses__SIGHT_RANGE_FIELD= ABILITY_ILF_SIGHT_RANGE_BONUS
constant abilityreallevelfield ExtendableBonusesBasicBonuses__HEALTHREGEN_FIELD= ABILITY_RLF_AMOUNT_OF_HIT_POINTS_REGENERATED
constant abilityreallevelfield ExtendableBonusesBasicBonuses__MANAREGEN_FIELD= ABILITY_RLF_AMOUNT_REGENERATED
constant abilityreallevelfield ExtendableBonusesBasicBonuses__ATTACKSPEED_FIELD= ABILITY_RLF_ATTACK_SPEED_INCREASE_ISX1

        //These are not required by the system, but they were the way to interact with NewBonus by chopinski
        //One could use these or use "BonusDamage.typeid"
integer BONUS_DAMAGE
integer BONUS_ARMOR
integer BONUS_AGILITY
integer BONUS_STRENGTH
integer BONUS_INTELLIGENCE
integer BONUS_HEALTH
integer BONUS_MANA
integer BONUS_MOVEMENT_SPEED
integer BONUS_SIGHT_RANGE
integer BONUS_HEALTH_REGEN
integer BONUS_MANA_REGEN
integer BONUS_ATTACK_SPEED
//endglobals from ExtendableBonusesBasicBonuses
//globals from MissileEffect:
constant boolean LIBRARY_MissileEffect=true
//endglobals from MissileEffect
//globals from MouseUtilsLockCamExtension:
constant boolean LIBRARY_MouseUtilsLockCamExtension=true
//endglobals from MouseUtilsLockCamExtension
//globals from NewBonusUtils:
constant boolean LIBRARY_NewBonusUtils=true
//endglobals from NewBonusUtils
//globals from SimpleDelayedDestroyer:
constant boolean LIBRARY_SimpleDelayedDestroyer=true
//endglobals from SimpleDelayedDestroyer
//globals from SpellEffectEvent:
constant boolean LIBRARY_SpellEffectEvent=true
//endglobals from SpellEffectEvent
//globals from CooldownReductionUtils:
constant boolean LIBRARY_CooldownReductionUtils=true
//endglobals from CooldownReductionUtils
//globals from ExtendableBonusesMetroidvania:
constant boolean LIBRARY_ExtendableBonusesMetroidvania=true
        //These are not required by the system, but they were the way to interact with NewBonus by chopinski
        //One could use these or use "BonusDamage.typeid"
integer BONUS_SYSTEM_POWER
integer BONUS_SYSTEM_SPEED

integer array systempower
integer array systemspeed
//endglobals from ExtendableBonusesMetroidvania
//globals from Missiles:
constant boolean LIBRARY_Missiles=true
        // The update period of the system
constant real Missiles_PERIOD= 1. / 40.
        // The max amount of Missiles processed in a PERIOD
        // You can play around with both these values to find
        // your sweet spot. If equal to 0, the system will
        // process all missiles at once every period.
constant real Missiles_SWEET_SPOT= 150
        // the avarage collision size compensation when detecting collisions
constant real Missiles__COLLISION_SIZE= 128.
        // item size used in z collision
constant real Missiles__ITEM_SIZE= 16.
        // Raw code of the dummy unit used for vision
constant integer Missiles__DUMMY= 'dumi'
        // Needed, don't touch.
location Missiles__LOC= Location(0., 0.)
//endglobals from Missiles
//globals from UnitAddAbilityTimed:
constant boolean LIBRARY_UnitAddAbilityTimed=true
//endglobals from UnitAddAbilityTimed
//globals from MetroidvaniaUtils:
constant boolean LIBRARY_MetroidvaniaUtils=true
//endglobals from MetroidvaniaUtils
//globals from MissileUtils:
constant boolean LIBRARY_MissileUtils=true
//endglobals from MissileUtils
//globals from KnockbackTZ:
constant boolean LIBRARY_KnockbackTZ=true
constant real KnockbackTZ__CHECK_RADIUS= 96.
        //Time (in seconds) per update
constant real KnockbackTZ__TICK_RATE= 1. / 50.

        //Speed percent kept per tick
constant real KnockbackTZ__DEFAULT_FRICTION_PERCENT= 0.996
constant real DEFAULT_FRICTION= 0.01

        //Should bounce, using reflection angle from walls, or "continue" "into" the wall 
constant boolean KnockbackTZ__DEFAULT_BOUNCEY= true
constant real KnockbackTZ__BOUNCE_VELOCITY_LOSS= 0.8

constant real KnockbackTZ__DEFAULT_COLLISION= 8.
constant real NO_COLLISION= - 999.
        //Limit of units processed per tick. 
        //Next tick distance is multiplied by skiped ticks, if skiped due to this limit.
constant integer KnockbackTZ__MAX_UPDATES_PER_TICK= 50
        
        //Distance difference allowed to be considered "equal". Real default is too small 
constant real KnockbackTZ__WALKABLE_EPSILON= .1

constant integer KnockbackTZ__EAST= 0
constant integer KnockbackTZ__NORTH= 1
constant integer KnockbackTZ__WEST= 2
constant integer KnockbackTZ__SOUTH= 3

constant group KnockbackTZ__knockbackUnits= CreateGroup()

location walkablePoint= Location(0., 0.)
//endglobals from KnockbackTZ
//globals from MetroidvaniaUi:
constant boolean LIBRARY_MetroidvaniaUi=true
constant real UI_UPDATE_FREQUENCY= 0.05
constant integer UI_TARGET_DEAD_TICKS_DESELECT= R2I(5.0 / UI_UPDATE_FREQUENCY)

trigger ui_show_ui_tooltip_trig= null
trigger ui_hide_tooltip_trig= null
trigger ui_core_bonus_trig= null
framehandle ui_mainBackDrop= null
framehandle ui_portrait= null

framehandle ui_hpBarFull= null
framehandle ui_hpBarEmpty= null
framehandle ui_hpBarText= null

framehandle ui_energyBarFull= null
framehandle ui_energyBarEmpty= null
framehandle ui_energyBarText= null

framehandle ui_statsBackdrop= null
framehandle ui_targetBackdrop= null

framehandle array ui_frame
string array ui_strings

real ui_stat_text_scale= 1.0
    //Even numbers are the icon, odd (+1) is the cooldown indicator
constant integer UI_FRAMES_PER_ABILITY= 3
constant integer UI_ABIL_BTN_OFFSET= 0
constant integer UI_ABIL_ICON_OFFSET= 1
constant integer UI_ABIL_COOLDOWN_OFFSET= 2

constant integer UI_ATTACK= 0
constant integer UI_ATTACK_ALT= UI_ATTACK + UI_FRAMES_PER_ABILITY
constant integer UI_UTIL1= UI_ATTACK_ALT + UI_FRAMES_PER_ABILITY
constant integer UI_UTIL2= UI_UTIL1 + UI_FRAMES_PER_ABILITY
constant integer UI_DASH= UI_UTIL2 + UI_FRAMES_PER_ABILITY
constant integer UI_PASSIVE1= UI_DASH + UI_FRAMES_PER_ABILITY
constant integer UI_PASSIVE2= UI_PASSIVE1 + UI_FRAMES_PER_ABILITY

constant integer UI_INTERACT= UI_PASSIVE2 + UI_FRAMES_PER_ABILITY
constant integer UI_MAP= UI_INTERACT + 3
constant integer UI_STATS= UI_MAP + 3

    //8 stats, 4 frames per stat (Icon, text, icon, button)
constant integer UI_STATS_BASE= 30
constant integer UI_STATS_FRAMES_PER= 4
constant integer UI_STATS_HP= UI_STATS_BASE + 0 * UI_STATS_FRAMES_PER
constant integer UI_STATS_HP_REPAIR= UI_STATS_BASE + 1 * UI_STATS_FRAMES_PER
constant integer UI_STATS_ENERGY= UI_STATS_BASE + 2 * UI_STATS_FRAMES_PER
constant integer UI_STATS_ENERGY_RECHARGE= UI_STATS_BASE + 3 * UI_STATS_FRAMES_PER
constant integer UI_STATS_FIREPOWER= UI_STATS_BASE + 4 * UI_STATS_FRAMES_PER
constant integer UI_STATS_SYSTEM_POWER= UI_STATS_BASE + 5 * UI_STATS_FRAMES_PER
constant integer UI_STATS_SYSTEM_SPEED= UI_STATS_BASE + 6 * UI_STATS_FRAMES_PER
constant integer UI_STATS_MOBILITY= UI_STATS_BASE + 7 * UI_STATS_FRAMES_PER

constant integer UI_STATS_CORES_AVAILABLE= UI_STATS_BASE + 8 * UI_STATS_FRAMES_PER

constant integer UI_TOOLTIP_FRAME= 70
constant integer UI_TOOLTIP_HEADER= UI_TOOLTIP_FRAME + 1
constant integer UI_TOOLTIP_TEXT= UI_TOOLTIP_FRAME + 2
constant integer UI_TOOLTIP_MANA= UI_TOOLTIP_FRAME + 3
constant integer UI_TOOLTIP_COOLDOWN= UI_TOOLTIP_FRAME + 4
constant integer UI_TOOLTIP_MANA_ICON_FRAME= UI_TOOLTIP_FRAME + 5
constant integer UI_TOOLTIP_COOLDOWN_ICON_FRAME= UI_TOOLTIP_FRAME + 6

constant integer UI_TARGET_START= 80
constant integer UI_TARGET_NAME= UI_TARGET_START + 1
constant integer UI_TARGET_HP_ICON= UI_TARGET_START + 2
constant integer UI_TARGET_HP_BAR_EMPTY= UI_TARGET_START + 3
constant integer UI_TARGET_HP_BAR_FULL= UI_TARGET_START + 4
constant integer UI_TARGET_HP_BAR_TEXT= UI_TARGET_START + 5
constant integer UI_TARGET_DAMAGE_ICON= UI_TARGET_START + 6
constant integer UI_TARGET_DAMAGE_TEXT= UI_TARGET_START + 7
constant integer UI_TARGET_MOVEMENT_ICON= UI_TARGET_START + 8
constant integer UI_TARGET_MOVEMENT_TEXT= UI_TARGET_START + 9

constant string ICONS= "Icons\\"
constant string ICON_NONE= "Icons\\v2\\None.blp"
constant string ICON_COOLDOWN= "cooldownBorder.blp"
constant string ICON_INTERACT= "Icons\\Interact.blp"
constant string ICON_MAP= "Icons\\Map.blp"
constant string ICON_STATS_OPEN= "Icons\\StatsOpen.blp"
constant string ICON_STATS_CLOSE= "Icons\\StatsClose.blp"

constant string STATHEX_HP= "UI\\hexv2\\Hp_s.blp"
constant string STATHEX_HP_REPAIR= "UI\\hexv2\\RepairRate.blp"
constant string STATHEX_ENERGY= "UI\\hexv2\\EnergyStorage.blp"
constant string STATHEX_ENERGY_CHARGE= "UI\\hexv2\\EnergyRecharge.blp"
constant string STATHEX_FIREPOWER= "UI\\hexv2\\Firepower.blp"
constant string STATHEX_SYSTEM_POWER= "UI\\hexv2\\SystemEnergy.blp"
constant string STATHEX_SYSTEM_SPEED= "UI\\hexv2\\SystemSpeed.blp"
constant string STATHEX_MOBILITY= "UI\\hexv2\\Mobility.blp"
constant string STAT_BTN_ADD= "Icons\\StatsUpgrade.blp"
constant string STAT_BTN_ADD_DIS= "Icons\\StatsUpgradeDisabled.blp"

constant real UI_STAT_ICON_W= 0.0130
constant real UI_STAT_ICON_H= 0.0150
constant real UI_STAT_ICON_ADD_SIZE= 0.013
constant real UI_STAT_INSET_SIDES= 0.0065
constant real UI_STAT_INSET_TOP= 0.0065

constant integer COOLDOWN_ALPHA= 200

constant real UI_MAIN_LEFT= 0.28
constant real UI_MAIN_RIGHT= 0.52
constant real UI_MAIN_TOP= 0.09
constant real UI_MAIN_BOT= 0.0
constant real UI_MAIN_INSET= 0.009
constant real UI_MAIN_PADDING= 0.002

constant real UI_ICONS_TOP= UI_MAIN_TOP - 0.85 * UI_MAIN_INSET
constant real UI_ICONS_LEFT= UI_MAIN_LEFT + UI_MAIN_INSET
constant real UI_ICONS_SIZE= 0.028

constant real UI_ICONS_EXTRAS_SIZE= 0.0155
constant real UI_ICONS_EXTRAS_RIGHT= UI_MAIN_RIGHT - 0.8 * UI_MAIN_INSET
constant real UI_ICONS_EXTRAS_LEFT= UI_ICONS_EXTRAS_RIGHT - UI_ICONS_EXTRAS_SIZE

constant real UI_STATS_LEFT= UI_MAIN_RIGHT - 0.9 * UI_MAIN_INSET
constant real UI_STATS_RIGHT= UI_MAIN_RIGHT + 0.10
constant real UI_STATS_CENTER= UI_STATS_LEFT + ( UI_STATS_RIGHT - UI_STATS_LEFT ) / 2.

constant real UI_TARGET_LEFT= UI_MAIN_LEFT - 0.11
constant real UI_TARGET_RIGHT= UI_MAIN_LEFT + UI_MAIN_INSET

constant real UI_BAR_ICON_SIZE_W= 0.0182
constant real UI_BAR_ICON_SIZE_H= 0.0208
constant real UI_BAR_ICON_LEFT= UI_MAIN_LEFT + UI_MAIN_INSET
constant real UI_BAR_ICON_RIGHT= UI_BAR_ICON_LEFT + UI_BAR_ICON_SIZE_W
    
constant real UI_BAR_LEFT= UI_BAR_ICON_LEFT + UI_BAR_ICON_SIZE_W
constant real UI_BAR_RIGHT= UI_ICONS_EXTRAS_LEFT - 0.5 * UI_MAIN_PADDING
constant real UI_BAR_ENERGY_BOT= UI_MAIN_PADDING * 1.5
constant real UI_BAR_ENERGY_TOP= UI_BAR_ENERGY_BOT + UI_BAR_ICON_SIZE_H
constant real UI_BAR_HP_BOT= UI_BAR_ENERGY_TOP + 0.5 * UI_MAIN_PADDING
constant real UI_BAR_HP_TOP= UI_BAR_HP_BOT + UI_BAR_ICON_SIZE_H

constant real UI_TOOLTIP_BASE_W= 0.14
constant real UI_TOOLTIP_BASE_H= 0.064
constant real UI_TOOLTIP_INSET_TOP= 0.008
constant real UI_TOOLTIP_INSET_SIDES= 0.0045
constant real UI_TOOLTIP_HEADER_HEIGHT= 0.01

constant real UI_TOOLTIP_ICON_W= 0.009
constant real UI_TOOLTIP_ICON_H= 0.01
constant string UI_TOOLTIP_MANA_ICON_PATH= "UI\\hexv2\\EnergyRecharge.blp"
constant string UI_TOOLTIP_COOLDOWN_ICON_PATH= "UI\\hexv2\\SystemSpeed.blp"

integer targetDeadTicks
timer targetDeadTimer
//endglobals from MetroidvaniaUi
//globals from Respawn:
constant boolean LIBRARY_Respawn=true
texttag array hero_respawn_texttag
integer array hero_respawn_remaining
fogmodifier array hero_respawn_vision

constant real HERO_RESPAWN_DISTANCE_SQR= 150.0 * 150.0
//endglobals from Respawn
//globals from DestructableUpdates:
constant boolean LIBRARY_DestructableUpdates=true
constant integer SPAWN_POINT_DEST= 'B016'
constant real WALL_CHECK_RANGE= 550.
constant real WALL_LOW_RANGE= 350.
constant real WALL_LOW_RANGE_SQR= WALL_LOW_RANGE * WALL_LOW_RANGE

constant integer NO_FLAG= 0
constant integer DEAD_FLAG= 1
constant integer LOW_FLAG= 2
constant integer DEAD_LOW_FLAG= 3
constant integer ANIMATING_FLAG= 4

constant string ANIM_HIGH_ALIVE= "stand"
constant string ANIM_LOW_ALIVE= "stand alternate"
constant string ANIM_HIGH_DEAD= "decay"
constant string ANIM_LOW_DEAD= "decay alternate"
//endglobals from DestructableUpdates
//globals from MetroidvaniaController:
constant boolean LIBRARY_MetroidvaniaController=true
constant oskeytype MC_KEY_ATTACK= OSKEY_Q
constant oskeytype MC_KEY_ATTACK_ALT= OSKEY_W
constant oskeytype MC_KEY_UTIL_1= OSKEY_E
constant oskeytype MC_KEY_UTIL_2= OSKEY_R
constant oskeytype MC_KEY_DASH= OSKEY_D
constant oskeytype MC_KEY_INTERACT= OSKEY_F
constant oskeytype MC_KEY_MAP= OSKEY_M

constant integer NO_ACTION= - 1

constant integer ACITON_STATE_READY= 1
constant integer ACTION_STATE_DOING= 2
constant integer ACTION_STATE_BACKSWING= 3
constant integer ACTION_STATE_COOLDOWN= 4

        //constant integer UI_ATTACK = 0
        //constant integer UI_ATTACK_ALT = 1
        //constant integer UI_UTIL_1 = 2
        //constant integer UI_UTIL_2 = 3
        //constant integer UI_DASH = 4
        //constant integer UI_PASSIVE_1 = 5
        //constant integer UI_PASSIVE_2 = 6
        //constant integer UI_INTERACT = 7
        //constant integer UI_MAP = 8
//endglobals from MetroidvaniaController
    // User-defined
real udg_Radians_QuarterPi= 0
real udg_Radians_QuarterTurn= 0
real udg_Radians_Turn= 0
boolean array udg_K2DPause
real array udg_K2DFXRate
string array udg_K2DFXModel
real array udg_K2DFXTimeLeft
trigger udg_Knockback2DOnImpact= null
boolean array udg_K2DSimple
real udg_Knockback2DCollision= 0
boolean udg_Knockback2DSimple= false
unit udg_Knockback2DSource= null
boolean array udg_K2DUnbiasedCollision
boolean udg_Knockback2DAmphibious= false
boolean array udg_K2DAmphibious
real array udg_K2DCollision
real array udg_K2DDestRadius
boolean array udg_K2DKillTrees
real array udg_K2DVelocity
real array udg_K2DFriction
real array udg_K2DSinD2
real array udg_K2DCosD2
real array udg_K2DSinD1
real array udg_K2DCosD1
real array udg_K2DSinH
real array udg_K2DCosH
integer array udg_K2DRadius
boolean array udg_K2DFlying
real array udg_K2DSin
real array udg_K2DCos
real array udg_K2DLastY
real array udg_K2DLastX
real array udg_K2DHeightThreshold
real udg_Knockback2DHeight= 0
boolean udg_Knockback2DOverride= false
real array udg_K2DTimeLeft
real udg_Knockback2DTime= 0
real array udg_K2DDistanceLeft
real udg_Knockback2DDistance= 0
real udg_Knockback2DAngle= 0
real array udg_K2DAngle
unit array udg_K2DSource
boolean array udg_K2DBounce
boolean array udg_K2DOverride
boolean array udg_K2DFreeze
trigger array udg_K2DImpact
real array udg_K2DHeight
timer udg_K2DTimer= null
integer array udg_K2DNext
integer array udg_K2DPrev
unit udg_Knockback2DUnit= null
boolean udg_K2DItemOffset= false
boolean udg_K2DItemsFound= false
real udg_K2DMaxDestRadius= 0
real udg_K2DMinY= 0
real udg_K2DMinX= 0
real udg_K2DMaxY= 0
real udg_K2DMaxX= 0
rect udg_K2DRegion= null
unit udg_K2DDebrisKiller= null
item udg_K2DItem= null
real udg_K2DY= 0
real udg_K2DX= 0
real udg_Knockback2DFXRate= 0
real udg_Knockback2DDefaultFXRate= 0
string udg_Knockback2DLoopFX
string udg_Knockback2DDefaultFX
real udg_Knockback2DGravity= 0
real udg_Knockback2DDefaultGravity= 0
string udg_Knockback2DTreeOrDebris
real udg_Knockback2DDestRadius= 0
real udg_Knockback2DDefaultDestRadius= 0
boolean udg_Knockback2DKillTrees= false
boolean udg_Knockback2DDefaultKillTrees= false
boolean udg_Knockback2DPause= false
boolean udg_Knockback2DDefaultPause= false
boolean udg_Knockback2DBounces= false
boolean udg_Knockback2DDefaultBounce= false
real udg_Knockback2DFriction= 0
real udg_Knockback2DDefaultFriction= 0
integer udg_Knockback2DRobustPathing= 0
real udg_K2DTimeout= 0
boolean array udg_IsUnitBeingKnockedBack
boolean udg_Knockback2DUnbiasedCollision= false
integer udg_LoopInt= 0
boolean udg_CP_PointIsWalkable= false
integer udg_CP_HiddenItemsIndex= 0
item array udg_CP_HiddenItems
location udg_CP_Point= null
item udg_CP_Item= null
rect udg_CP_Rect= null
boolean udg_NextDamageIsAttack= false
boolean udg_NextDamageIsMelee= false
boolean udg_NextDamageIsRanged= false
integer udg_NextDamageWeaponT= 0
unit udg_DamageFilterSource= null
unit udg_DamageFilterTarget= null
integer udg_DamageFilterAttackT= 0
integer udg_DamageFilterDamageT= 0
integer udg_DamageFilterSourceT= 0
integer udg_DamageFilterTargetT= 0
integer udg_DamageFilterType= 0
integer udg_DamageFilterSourceB= 0
integer udg_DamageFilterTargetB= 0
real udg_DamageFilterMinAmount= 0
integer udg_UDex= 0
unit array udg_UDexUnits
integer array udg_UnitIndexLock
integer array udg_UDexPrev
integer array udg_UDexNext
real udg_UnitIndexEvent= 0
integer udg_UDexRecycle= 0
boolean udg_UnitIndexerEnabled= false
integer udg_UDexWasted= 0
integer udg_UDexGen= 0
real udg_DAMAGE_FACTOR_ELUNES= 0
real udg_DAMAGE_FACTOR_ETHEREAL= 0
real udg_DAMAGE_FACTOR_BRACERS= 0
integer udg_DmgEvBracers= 0
integer udg_NextDamageType= 0
boolean udg_NextDamageOverride= false
integer array udg_LastDmgPrevType
boolean array udg_LastDmgWasSpell
real udg_LastDamageHP= 0
real array udg_LastDmgPrevAmount
real array udg_LastDmgValue
unit array udg_LastDmgSource
unit array udg_LastDmgTarget
integer udg_DamageTypeExplosive= 0
integer udg_DamageTypeCriticalStrike= 0
integer udg_DamageTypeHeal= 0
integer udg_DamageTypeBlocked= 0
integer udg_DamageTypeReduced= 0
integer udg_DmgEvRecursionN= 0
boolean udg_DmgEvRunning= false
boolean udg_DmgEvStarted= false
trigger udg_DmgEvTrig= null
boolean udg_IsDamageSpell= false
integer udg_SpellDamageAbility= 0
integer udg_DamageBlockingAbility= 0
boolean array udg_HideDamageFrom
boolean array udg_UnitDamageRegistered
integer udg_DamageEventsWasted= 0
timer udg_DmgEvTimer= null
trigger udg_ClearDamageEvent= null
real udg_AfterDamageEvent= 0
real udg_DamageEvent= 0
real udg_DamageModifierEvent= 0
integer udg_DamageEventType= 0
real udg_DamageEventPrevAmt= 0
boolean udg_DamageEventOverride= false
unit udg_DamageEventSource= null
unit udg_DamageEventTarget= null
trigger udg_DamageEventTrigger= null
real udg_DamageEventAmount= 0
attacktype array udg_CONVERTED_ATTACK_TYPE
damagetype array udg_CONVERTED_DAMAGE_TYPE
real udg_DamageEventArmorPierced= 0
real udg_LethalDamageEvent= 0
real udg_LethalDamageHP= 0
real udg_AOEDamageEvent= 0
unit udg_AOEDamageSource= null
integer udg_DamageEventAOE= 0
group udg_DamageEventAOEGroup= null
integer udg_DamageEventLevel= 0
unit udg_EnhancedDamageTarget= null
real udg_DamageScalingUser= 0
real udg_DamageScalingWC3= 0
integer udg_DamageTypeCode= 0
integer udg_DamageTypePure= 0
integer udg_DamageTypePureExplosive= 0
boolean udg_IsDamageAttack= false
boolean udg_IsDamageCode= false
boolean udg_IsDamageMelee= false
boolean udg_IsDamageRanged= false
integer udg_DamageEventArmorT= 0
integer udg_ARMOR_TYPE_NONE= 0
integer udg_ARMOR_TYPE_FLESH= 0
integer udg_ARMOR_TYPE_METAL= 0
integer udg_ARMOR_TYPE_WOOD= 0
integer udg_ARMOR_TYPE_ETHEREAL= 0
integer udg_ARMOR_TYPE_STONE= 0
string array udg_ArmorTypeDebugStr
integer udg_DamageEventAttackT= 0
integer udg_ATTACK_TYPE_SPELLS= 0
integer udg_ATTACK_TYPE_NORMAL= 0
integer udg_ATTACK_TYPE_PIERCE= 0
integer udg_ATTACK_TYPE_SIEGE= 0
integer udg_ATTACK_TYPE_MAGIC= 0
integer udg_ATTACK_TYPE_CHAOS= 0
integer udg_ATTACK_TYPE_HERO= 0
string array udg_AttackTypeDebugStr
integer udg_DamageEventDamageT= 0
integer udg_DAMAGE_TYPE_UNKNOWN= 0
integer udg_DAMAGE_TYPE_NORMAL= 0
integer udg_DAMAGE_TYPE_ENHANCED= 0
integer udg_DAMAGE_TYPE_FIRE= 0
integer udg_DAMAGE_TYPE_COLD= 0
integer udg_DAMAGE_TYPE_LIGHTNING= 0
integer udg_DAMAGE_TYPE_POISON= 0
integer udg_DAMAGE_TYPE_DISEASE= 0
integer udg_DAMAGE_TYPE_DIVINE= 0
integer udg_DAMAGE_TYPE_MAGIC= 0
integer udg_DAMAGE_TYPE_SONIC= 0
integer udg_DAMAGE_TYPE_ACID= 0
integer udg_DAMAGE_TYPE_FORCE= 0
integer udg_DAMAGE_TYPE_DEATH= 0
integer udg_DAMAGE_TYPE_MIND= 0
integer udg_DAMAGE_TYPE_PLANT= 0
integer udg_DAMAGE_TYPE_DEFENSIVE= 0
integer udg_DAMAGE_TYPE_DEMOLITION= 0
integer udg_DAMAGE_TYPE_SLOW_POISON= 0
integer udg_DAMAGE_TYPE_SPIRIT_LINK= 0
integer udg_DAMAGE_TYPE_SHADOW_STRIKE= 0
integer udg_DAMAGE_TYPE_UNIVERSAL= 0
string array udg_DamageTypeDebugStr
integer udg_DamageEventDefenseT= 0
integer udg_DEFENSE_TYPE_LIGHT= 0
integer udg_DEFENSE_TYPE_MEDIUM= 0
integer udg_DEFENSE_TYPE_HEAVY= 0
integer udg_DEFENSE_TYPE_FORTIFIED= 0
integer udg_DEFENSE_TYPE_NORMAL= 0
integer udg_DEFENSE_TYPE_HERO= 0
integer udg_DEFENSE_TYPE_DIVINE= 0
integer udg_DEFENSE_TYPE_UNARMORED= 0
string array udg_DefenseTypeDebugStr
string array udg_WeaponTypeDebugStr
integer udg_WEAPON_TYPE_NONE= 0
integer udg_WEAPON_TYPE_ML_CHOP= 0
integer udg_WEAPON_TYPE_MM_CHOP= 0
integer udg_WEAPON_TYPE_MH_CHOP= 0
integer udg_WEAPON_TYPE_ML_SLICE= 0
integer udg_WEAPON_TYPE_MM_SLICE= 0
integer udg_WEAPON_TYPE_MH_SLICE= 0
integer udg_WEAPON_TYPE_MM_BASH= 0
integer udg_WEAPON_TYPE_MH_BASH= 0
integer udg_WEAPON_TYPE_MM_STAB= 0
integer udg_WEAPON_TYPE_MH_STAB= 0
integer udg_WEAPON_TYPE_WL_SLICE= 0
integer udg_WEAPON_TYPE_WM_SLICE= 0
integer udg_WEAPON_TYPE_WH_SLICE= 0
integer udg_WEAPON_TYPE_WL_BASH= 0
integer udg_WEAPON_TYPE_WM_BASH= 0
integer udg_WEAPON_TYPE_WH_BASH= 0
integer udg_WEAPON_TYPE_WL_STAB= 0
integer udg_WEAPON_TYPE_WM_STAB= 0
integer udg_WEAPON_TYPE_CL_SLICE= 0
integer udg_WEAPON_TYPE_CM_SLICE= 0
integer udg_WEAPON_TYPE_CH_SLICE= 0
integer udg_WEAPON_TYPE_AM_CHOP= 0
integer udg_WEAPON_TYPE_RH_BASH= 0
integer udg_DamageEventWeaponT= 0
location udg_CenterPoint= null
destructable array udg_respawnCurrentPoint
group udg_heroes_alive= null
group udg_heroes_dead= null
real udg_CargoEvent= 0
real udg_DeathEvent= 0
real udg_WorldMaxX= 0
real udg_WorldMaxY= 0
group array udg_CargoTransportGroup
boolean array udg_IsUnitNew
boolean array udg_IsUnitTransforming
real udg_UnitTypeEvent= 0
integer array udg_CheckDeathList
boolean array udg_IsUnitReincarnating
boolean array udg_IsUnitBeingUnloaded
unit array udg_KillerOfUnit
integer array udg_UnitTypeOf
boolean array udg_IsUnitAlive
boolean array udg_CheckDeathInList
unit array udg_CargoTransportUnit
boolean array udg_IsUnitRemoved
unit array udg_SummonerOfUnit
boolean array udg_IsUnitPreplaced
timer udg_CheckDeathTimer= null
integer udg_DetectRemoveAbility= 0
integer udg_DetectTransformAbility= 0
integer udg_UDexLastRecycled= 0
integer udg_UDexMax= 0
unit udg_t_unit1= null
location udg_t_loc1= null
boolean udg_t_bool1= false
location udg_t_loc2= null
destructable udg_t_destructible1= null
group udg_heroes_all= null
boolean udg_is_testing= false
group udg_t_group1= null
fogmodifier array udg_respawn_death_visibility
force udg_human_players= null
rect array udg_initial_spawn
boolean udg_dashHasPoint= false
timer udg_dashTimer= null
string udg_t_string1
integer udg_cinematic= 0
real udg_t_real1= 0
integer udg_t_int1= 0
integer udg_t_int2= 0
group udg_spawnedEnemies= null
integer udg_spawnedEnemiesPower= 0
real udg_t_real2= 0
integer array udg_spawnedPowerArr
location array udg_enemyPatrolPoints
hashtable udg_heroes_hash= null
integer udg_t_unittype1= 0
rect array udg_coreSecretPoints
integer udg_boss_BM_status= 0
real udg_onHeroDeathEvent= 0
integer udg_boss_hero_deaths= 0
integer udg_spawnedEnemiesHeat= 0
integer udg_t_int3= 0
rect array udg_doodadRegions
integer udg_g_int1= 0
integer udg_g_int2= 0
rect udg_t_rect1= null
rect udg_t_rect2= null
unit udg_bossUnit= null
rect array udg_bossRegions
integer udg_bossAICounter= 0
boolean udg_bossAIEnabled= false
boolean udg_bossOngoing= false
integer udg_boss_MC_status= 0
group udg_conveyorNorthGroup= null
group udg_conveyorEastGroup= null
group udg_conveyorWestGroup= null
group udg_conveyorSouthGroup= null
lightning array udg_g_lightning
unit udg_boss_MC_crystal_r= null
unit udg_boss_MC_crystal_l= null
timer udg_bossTimer1= null
effect udg_bossVfx1= null
boolean udg_bossBool1= false
integer udg_bossInt1= 0
fogmodifier array udg_g_visModArr
timer udg_bossTimer2= null
unit udg_boss_MC_transmitter_r= null
unit udg_boss_MC_transmitter_l= null

    // Generated
rect gg_rct_InitialSpawn2= null
rect gg_rct_InitialSpawn1= null
rect gg_rct_InitialSpawn3= null
rect gg_rct_InitialSpawn4= null
rect gg_rct_InitialSpawn5= null
rect gg_rct_Intro_Zombie_Pos= null
rect gg_rct_Intro_Zombie_Pos_2= null
rect gg_rct_Intro_Zombie_Pos_Copy= null
rect gg_rct_Intro_Zombie_Pos_Copy_2= null
rect gg_rct_Intro_Zombie_Pos_Copy_3= null
rect gg_rct_Intro_Zombie_Pos_Copy_4= null
rect gg_rct_Intro_ZombiesGroup1= null
rect gg_rct_Intro_Zombie_Pos_Copy_6= null
rect gg_rct_Intro_Zombie_Pos_Copy_7= null
rect gg_rct_Intro_Zombie_Pos_Inside_Doors_1= null
rect gg_rct_Intro_Zombie_Pos_Copy_9= null
rect gg_rct_Intro_Zombie_Pos_Copy_11= null
rect gg_rct_Intro_ZombiesGroup2= null
rect gg_rct_Intro_Area= null
rect gg_rct_Into_Remaining_Zombies= null
rect gg_rct_IceCaveBlock1_1= null
rect gg_rct_IceCaveBlock1_2= null
rect gg_rct_IceCaveBlock2_1= null
rect gg_rct_IceCaveBlock2_12= null
rect gg_rct_IceCaveBlockCave_1= null
rect gg_rct_IceCaveBlockCave_2= null
rect gg_rct_IceCaveBlock3_1= null
rect gg_rct_IceCaveBlock3_2= null
rect gg_rct_IceCaveBlock4= null
rect gg_rct_IceCaveBlock5_1= null
rect gg_rct_IceCaveBlock5_2= null
rect gg_rct_IceCaveBlock6_1= null
rect gg_rct_IceCaveBlock6_2= null
rect gg_rct_IceCaveBlock7_1= null
rect gg_rct_IceCaveBlock7_2= null
rect gg_rct_IceCaveBlock8_1= null
rect gg_rct_IceCaveBlock8_2= null
rect gg_rct_IceCaveBlockSecret_1= null
rect gg_rct_IceCaveBlockSecret_2= null
rect gg_rct_IceCaveBlock9_1= null
rect gg_rct_IceCaveBlock9_2= null
rect gg_rct_IceCaveBlock10= null
rect gg_rct_IceCaveBlock11= null
rect gg_rct_IceCaveBlock12= null
rect gg_rct_IceCaveBlock13= null
rect gg_rct_IceCaveBlock15_1= null
rect gg_rct_IceCaveBlock15_2= null
rect gg_rct_IceCaveBlock4_Alt= null
rect gg_rct_IceCaveBlock14= null
rect gg_rct_IceCaveBlock16_1= null
rect gg_rct_IceCaveBlock16_2= null
rect gg_rct_IceCaveBlock17_1= null
rect gg_rct_IceCaveBlock17_2= null
rect gg_rct_IceCaveBlock17_3= null
rect gg_rct_IceCaveBlockSecret_1_reward= null
rect gg_rct_IceCaveBlockSecret_2_reward= null
rect gg_rct_IceCaveBlockDebris_1= null
rect gg_rct_IceCaveBlockDebris_2= null
rect gg_rct_IceCaveBlockDebris_3= null
rect gg_rct_IceCaveBlockDebris_4= null
rect gg_rct_IceCaveBlockDebris_5= null
rect gg_rct_ExitingSpawnArea= null
rect gg_rct_OpenDoorHint= null
rect gg_rct_IceCaves= null
rect gg_rct_ZombieSpawningArea= null
rect gg_rct_ZombiePatrolP1= null
rect gg_rct_ZombiePatrolP2= null
rect gg_rct_ZombiePatrolP3= null
rect gg_rct_ZombiePatrolP4= null
rect gg_rct_SA_Battery1= null
rect gg_rct_SA_Battery2= null
rect gg_rct_SA_Battery3= null
rect gg_rct_SA_Battery4= null
rect gg_rct_SA_Battery5= null
rect gg_rct_IceCaveBlock14_2= null
rect gg_rct_Brood_Mother_Spawn= null
rect gg_rct_Brood_Mother_Arena= null
rect gg_rct_Brood_Mother_Entrence_Block1= null
rect gg_rct_Brood_Mother_Entrence_Block2= null
rect gg_rct_Brood_Mother_Reward_Block= null
rect gg_rct_Brood_Mother_Reward= null
rect gg_rct_Brood_Mother_North_Doors= null
rect gg_rct_Brood_Mother_StartBattle= null
rect gg_rct_Brood_Mother_TP_Others= null
rect gg_rct_IceCavesPatrol1= null
rect gg_rct_IceCavesPatrol2= null
rect gg_rct_IceCavesPatrol3= null
rect gg_rct_Brood_Mother_Entrence_EggLoc1= null
rect gg_rct_Brood_Mother_Entrence_EggLoc2= null
rect gg_rct_Brood_Mother_Entrence_EggLoc3= null
rect gg_rct_Brood_Mother_Entrence_EggLoc4= null
rect gg_rct_Brood_Mother_Entrence_NorthSpawn= null
rect gg_rct_Brood_Mother_Entrence_EggLoc5= null
rect gg_rct_Brood_Mother_Entrence_EggLoc6= null
rect gg_rct_IceCaveBlockSecret_3_reward= null
rect gg_rct_IceCaveBlockSecret_4_reward= null
rect gg_rct_IceCaveBlockSecret_4= null
rect gg_rct_IceCaveBlockSecret_5_reward= null
rect gg_rct_IceCaveBlockSecret_5= null
rect gg_rct_IceCaveBlockDebris_1_2= null
rect gg_rct_IceCaveBlock18_1= null
rect gg_rct_IceCaveBlock18_2= null
rect gg_rct_IceCaveBlock18_3= null
rect gg_rct_IceCaveBlock4_Alt_2= null
rect gg_rct_IceCaveBlockSecret_6_reward= null
rect gg_rct_IceCaveBlockSecret_7_reward= null
rect gg_rct_IceCaveBlockSecret_8_reward= null
rect gg_rct_IceCaveBlockSecret_9_reward= null
rect gg_rct_IceCaveBlockSecret_11_reward= null
rect gg_rct_IceCaveBlockSecret_12_reward= null
rect gg_rct_IceCaveBlockSecret_13_reward= null
rect gg_rct_IceCaveBlockSecret_14_reward= null
rect gg_rct_IceCaveBlockSecret_15_reward= null
rect gg_rct_IceCaveBlockSecret_16_reward= null
rect gg_rct_IceCaveBlockSecret_17_reward= null
rect gg_rct_IceCaveBlock19_1= null
rect gg_rct_IceCaveBlock19_2= null
rect gg_rct_IceCaveBlockSecret_19_reward= null
rect gg_rct_IceCaveBlockSecret_20_reward= null
rect gg_rct_IceCaveBlockSecret_21_reward= null
rect gg_rct_IceCaveBlockSecret_10_reward= null
rect gg_rct_IceCaveBlockSecret_22_reward= null
rect gg_rct_IceCaveBlock20_1= null
rect gg_rct_IceCaveBlock20_2= null
rect gg_rct_IceCaveBlock21_1= null
rect gg_rct_IceCaveBlock21_2= null
rect gg_rct_IceCaveBlockSecret_23_reward= null
rect gg_rct_ExplodeStuffHint= null
rect gg_rct_Victory_Area= null
rect gg_rct_FinalBoss_TP= null
rect gg_rct_FinalBoss_Spawn= null
rect gg_rct_FinalBoss_ConveyorZap1_1= null
rect gg_rct_FinalBoss_ConveyorZap2_1= null
rect gg_rct_FinalBoss_GeneratorArea= null
rect gg_rct_FinalBoss_Conveyor_Enterence= null
rect gg_rct_FinalBoss_Main_Arena= null
rect gg_rct_FinalBoss_CloseToEnter= null
rect gg_rct_FinalBoss_Enterence= null
rect gg_rct_FinalBoss_WalkStart= null
rect gg_rct_FinalBoss_Full_Arena= null
rect gg_rct_FinalBoss_Conveyor_Lower_Spawn= null
rect gg_rct_FinalBoss_Conveyor_Upper_Spawn= null
rect gg_rct_FinalBoss_Conveyor_Lower_End= null
rect gg_rct_FinalBoss_Conveyor_Upper_End= null
rect gg_rct_FinalBoss_Conveyor_Lower_Downwards_1= null
rect gg_rct_FinalBoss_Conveyor_Lower_Downwards_2= null
rect gg_rct_FinalBoss_Conveyor_Lower_Right_1= null
rect gg_rct_FinalBoss_Conveyor_Lower_Left_1= null
rect gg_rct_FinalBoss_Conveyor_Upper_Left_1= null
rect gg_rct_FinalBoss_Conveyor_Upper_Left_2= null
rect gg_rct_FinalBoss_Conveyor_Upper_Upwards_1= null
rect gg_rct_FinalBoss_Conveyor_Upper_Upwards_2= null
rect gg_rct_FinalBoss_GreenCrystal_L= null
rect gg_rct_FinalBoss_GreenCrystal_R= null
rect gg_rct_FinalBoss_Transmitter_L= null
rect gg_rct_FinalBoss_Transmitter_R= null
rect gg_rct_FinalBoss_SpawnPoint= null
rect gg_rct_FinalBoss_SpawnPoint__Copy= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_2= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_3= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_4= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_5= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_6= null
rect gg_rct_FinalBoss_SpawnPoint__Copy_7= null
rect gg_rct_FinalBoss_Conveyor_Corridor= null
rect gg_rct_Ehhm_TP= null
rect gg_rct_FinalBoss_Vents= null
rect gg_rct_Intro_Zombie_Pos_Inside_Doors_2= null
rect gg_rct_FinalBoss_Door= null
rect gg_rct_StartRoom_UtilityRoom= null
camerasetup gg_cam_IntroCamera1= null
camerasetup gg_cam_IntroCamera2= null
camerasetup gg_cam_IntroCamera3= null
camerasetup gg_cam_IntroCamera4= null
camerasetup gg_cam_IntroCamera5= null
camerasetup gg_cam_IntroCamera6= null
camerasetup gg_cam_Victory1= null
camerasetup gg_cam_Victory2= null
camerasetup gg_cam_FinalBoss_Spawn1= null
sound gg_snd_AbilityBombDetonate= null
sound gg_snd_MCL_Lightning1= null
trigger gg_trg_Table= null
trigger gg_trg_Unit_Indexer= null
trigger gg_trg_SpellEffectEvent= null
trigger gg_trg_RegisterPlayerUnitEvent= null
trigger gg_trg_TimerUtils= null
trigger gg_trg_Dummy_Recycler= null
trigger gg_trg_WorldBounds= null
trigger gg_trg_Alloc= null
trigger gg_trg_LineSegmentEnumeration= null
trigger gg_trg_MouseUtils= null
trigger gg_trg_UnitEvent= null
trigger gg_trg_UnitEventConfig= null
trigger gg_trg_NewBonus= null
trigger gg_trg_NewBonusUtils= null
trigger gg_trg_On_Damage= null
trigger gg_trg_Knockback_2D_Config= null
trigger gg_trg_Knockback_2D_Destroy= null
trigger gg_trg_Knockback_2D= null
trigger gg_trg_Knockback_2D_System= null
trigger gg_trg_CooldownReduction= null
trigger gg_trg_CooldownReductionUtils= null
trigger gg_trg_MissileQ= null
trigger gg_trg_Relativistic_Missiles= null
trigger gg_trg_MissileEffect= null
trigger gg_trg_MissileUtils= null
trigger gg_trg_Check_Walkability_Setup= null
trigger gg_trg_Check_Walkability= null
trigger gg_trg_Damage_Engine_Config= null
trigger gg_trg_Damage_Engine= null
trigger gg_trg_DelayedDestroyer= null
trigger gg_trg_UI= null
trigger gg_trg_MouseUtilsLockCamExtension= null
trigger gg_trg_DestructablesUpdate= null
trigger gg_trg_HeroController= null
trigger gg_trg_KnockbackTZ= null
trigger gg_trg_ExtendableBonusSystem= null
trigger gg_trg_ExtendableBonusesGeneral= null
trigger gg_trg_ExtendableBonusesMetroidvania= null
trigger gg_trg_PickupCore= null
trigger gg_trg_RespawnHelpers= null
trigger gg_trg_ReincarnateStart= null
trigger gg_trg_UpdateNearbyDestructiblesTick= null
trigger gg_trg_BombDetonate= null
trigger gg_trg_BombPickup= null
trigger gg_trg_HeroAbilities= null
trigger gg_trg_Interaction= null
trigger gg_trg_EnemySpawnStartingArea= null
trigger gg_trg_EnemySpawnIceCavesArea= null
trigger gg_trg_EnemySpawningMain= null
trigger gg_trg_EnemyDespawnMain= null
trigger gg_trg_MechaCL_jass= null
trigger gg_trg_MechaCL_StartForceEnter= null
trigger gg_trg_MechaCL_HeroDeath= null
trigger gg_trg_MechaCL_SkipCinematic= null
trigger gg_trg_MechaCL_OnDamageTaken= null
trigger gg_trg_MechaCL_OnDamageTaken_Message_Reset= null
trigger gg_trg_MechaCL_UpdateLightning= null
trigger gg_trg_MechaCL_Death= null
trigger gg_trg_MechaCL_Hero_EnterConveyorArea= null
trigger gg_trg_MechaCL_Hero_LeaveConveyorArea= null
trigger gg_trg_MechaCL_AI_Main= null
trigger gg_trg_MechaCL_Missile_StartAnim= null
trigger gg_trg_MechaCL_Missile_FireFirstRound= null
trigger gg_trg_MechaCL_Missile_FireSecondRound= null
trigger gg_trg_MechaCL_Missile_End= null
trigger gg_trg_MechaCL_AI_Spawn_SawBot_Start= null
trigger gg_trg_MechaCL_AI_Spawn_SawBot_Call= null
trigger gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart= null
trigger gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish= null
trigger gg_trg_MechaCL_OnCrystalDeath= null
trigger gg_trg_MechaCLOnFanDeath= null
trigger gg_trg_BroodMother_Spawn= null
trigger gg_trg_BroodMother_Death= null
trigger gg_trg_BroodMother_RewardEnter= null
trigger gg_trg_BroodMother_HeroDeath= null
trigger gg_trg_BroodMother_AI_LayEgg= null
trigger gg_trg_BroodMother_AI_LayEgg_OnCast= null
trigger gg_trg_BroodMother_AI_LayEgg_OnEggDeath= null
trigger gg_trg_BroodMother_AI= null
trigger gg_trg_EnemyKill= null
trigger gg_trg_ConveyorNorthEnter= null
trigger gg_trg_ConveyorNorthLeave= null
trigger gg_trg_ConveyorEastEnter= null
trigger gg_trg_ConveyorEastLeave= null
trigger gg_trg_ConveyorWestEnter= null
trigger gg_trg_ConveyorWestLeave= null
trigger gg_trg_ConveyorTick= null
trigger gg_trg_FinalBossCrystalsInit= null
trigger gg_trg_TP_To_final_boss= null
trigger gg_trg_OilBarrel= null
trigger gg_trg_InitializeDebug= null
trigger gg_trg_InitializeDebugTriggers= null
trigger gg_trg_RemoveDebugTriggers= null
trigger gg_trg_ChatKill= null
trigger gg_trg_TestFinalBoss= null
trigger gg_trg_HintExitSpawnArea= null
trigger gg_trg_HintOpenDoors= null
trigger gg_trg_HintExplodeStuff= null
trigger gg_trg_HintExplodeVents= null
trigger gg_trg_IceCavesFunctions= null
trigger gg_trg_IceCavesSetupEnd= null
trigger gg_trg_IceCavesSetupMain= null
trigger gg_trg_InitIceCave= null
trigger gg_trg_IntroSkipActions= null
trigger gg_trg_IntroSkip= null
trigger gg_trg_IntroCinematic= null
trigger gg_trg_IntroWalkOrdersMarine11= null
trigger gg_trg_IntroWalkOrdersMarine12= null
trigger gg_trg_IntroOrdersMarineHold1= null
trigger gg_trg_IntroWalkOrdersMarine21= null
trigger gg_trg_IntroOrdersMarineHold2= null
trigger gg_trg_IntroWalkOrdersMarine31= null
trigger gg_trg_IntroOrdersMarineHold3_Hold_Then_Close_Door= null
trigger gg_trg_IntroWalkOrdersMarine41= null
trigger gg_trg_IntroOrdersMarineHold4= null
trigger gg_trg_IntroOrdersZombiesAttackMove1= null
trigger gg_trg_IntroOrdersZombiesAttackMove2= null
trigger gg_trg_IntroCloseDoor= null
trigger gg_trg_IntroWalk_Away_From_Door= null
trigger gg_trg_JassInit= null
trigger gg_trg_MapInit= null
trigger gg_trg_DelayedMapInit= null
trigger gg_trg_GameStart= null
trigger gg_trg_dummy= null
trigger gg_trg_GameVictory= null
trigger gg_trg_OnIndex= null
unit gg_unit_h001_0032= null
unit gg_unit_h001_0031= null
unit gg_unit_h001_0030= null
unit gg_unit_h001_0029= null
destructable gg_dest_B015_0524= null
destructable gg_dest_B015_0523= null
destructable gg_dest_B01B_0355= null
destructable gg_dest_B01B_0357= null
destructable gg_dest_B015_0358= null
destructable gg_dest_B016_0393= null
destructable gg_dest_B00Y_0263= null
destructable gg_dest_B020_3503= null
destructable gg_dest_B01B_3097= null
destructable gg_dest_B01B_3096= null
destructable gg_dest_B01B_2877= null
destructable gg_dest_B025_3152= null
destructable gg_dest_B025_1826= null
destructable gg_dest_B01B_2875= null
destructable gg_dest_B01B_2886= null
destructable gg_dest_B01B_3404= null
constant integer ABIL_ATTACK_BASIC= 'A004'
constant integer ABIL_ATTACK_SLAM= 'A003'
constant integer ABIL_SPELL_SLAM= 'A005'

constant integer STAT_COUNT= 8

constant integer STAT_INDEX_HP= 0
constant integer STAT_INDEX_HP_REPAIR= 1
constant integer STAT_INDEX_ENERGY= 2
constant integer STAT_INDEX_ENERGY_RECHARGE= 3
constant integer STAT_INDEX_FIREPOWER= 4
constant integer STAT_INDEX_SYSTEM_POWER= 5
constant integer STAT_INDEX_SYSTEM_SPEED= 6
constant integer STAT_INDEX_MOBILITY= 7

constant real BONUS_PER_CORE_HP= 10.
constant real BONUS_PER_CORE_HP_REPAIR= 0.15
constant real BONUS_PER_CORE_ENERGY= 12.
constant real BONUS_PER_CORE_ENERGY_RECHARGE= 0.3
constant real BONUS_PER_CORE_FIREPOWER= 2.
constant real BONUS_PER_CORE_SYSTEM_POWER= 5.
constant real BONUS_PER_CORE_SYSTEM_SPEED= 8.
constant real BONUS_PER_CORE_MOBILITY= 12.

constant real CONVEYOR_SPEED= 3.0

constant string CNOTE= "|c00888888"

    //location walkablePoint = Location(0.,0.)
rect enumRect= Rect(0., 0., 0., 0.)

    //player-id-indexed array
location zTester= Location(0., 0.)
integer array coresAvailable
integer totalCoresCollected= 0
constant integer BOMB_UNIT_TYPE= 'h002'
constant integer TIMED_LIFE= 'BTLF'

constant string SOUND_DASH1= "Sounds\\Hero\\SDash1.wav"
constant string SOUND_DASH2= "Sounds\\Hero\\SDash2.wav"
constant real INTERACT_RANGE= 160.
constant string INTERACTION_TOGGLEABLE= "i_tog"
constant string INTERACTION_TERMINAL= "i_term"

constant string INTERACTION_TERMINAL_TOGGLABLE= "term_togglable"

constant real INTERACT_TERMINAL_RANGE= 488
constant real MCL_CONVEYOR_TICK_RATE= 0.04
constant real MCL_CONVEYOR_BEAM_DMG_BASE= 21.

real mcl_crystal_l_x
real mcl_crystal_l_y
real mcl_crystal_r_x
real mcl_crystal_r_y

real mcl_transmitter_l_x
real mcl_transmitter_l_y
real mcl_transmitter_r_x
real mcl_transmitter_r_y

lightning mcl_l_beam_static
lightning mcl_r_beam_static

lightning mcl_l_beam_to_boss
lightning mcl_r_beam_to_boss
    
timer mcl_conveyor_t
integer mcl_conveyor_counter
lightning mcl_conveyor_s
lightning mcl_conveyor_n

integer mcl_missile_counter
constant integer DEST_ICE_WALL= 'B01T'
constant integer MECHA_DH_UID= 'h000'
constant integer ZOMBIE_UID= 'n001'
constant integer ZOMBIE_DOG_UID= 'n003'
constant integer SPIDER_UID= 'n006'
constant integer SPIDERLING_UID= 'n005'
constant integer BROODMOTHER_UID= 'n004'
constant integer MECHA_CL_UID= 'u001'
constant integer SAW_BOT_UID= 'u002'

integer enemyKillsT
integer coreKillsToNextDropT
integer coreDropGrowT
integer coreDropKillsRequiredT

integer unitMovementSpeed
integer destructableEvents

trigger l__library_init

//JASSHelper struct globals:
constant integer si__DamageTrigger=1
integer s__DamageTrigger_MOD= 1
integer s__DamageTrigger_SHIELD= 4
integer s__DamageTrigger_DAMAGE= 5
integer s__DamageTrigger_ZERO= 6
integer s__DamageTrigger_AFTER= 7
integer s__DamageTrigger_LETHAL= 8
integer s__DamageTrigger_AOE= 9
integer s__DamageTrigger_count= 9
integer s__DamageTrigger_lastRegistered= 0
integer array s__DamageTrigger_trigIndexStack
integer s__DamageTrigger_eventIndex= 0
boolean array s__DamageTrigger_filters
string array s__DamageTrigger_eventStr
real array s__DamageTrigger_weight
boolean array s__DamageTrigger_configured
boolean array s__DamageTrigger_usingGUI
integer array s__DamageTrigger_next
trigger array s__DamageTrigger_rootTrig
boolean array s__DamageTrigger_DamageEngine__trigFrozen
integer array s__DamageTrigger_DamageEngine__levelsDeep
boolean array s__DamageTrigger_DamageEngine__inceptionTrig
unit array s__DamageTrigger_source
unit array s__DamageTrigger_target
integer array s__DamageTrigger_sourceType
integer array s__DamageTrigger_targetType
integer array s__DamageTrigger_sourceBuff
integer array s__DamageTrigger_targetBuff
real array s__DamageTrigger_damageMin
integer array s__DamageTrigger_attackType
integer array s__DamageTrigger_damageType
integer array s__DamageTrigger_userType
integer s__DamageTrigger_prev= 0
trigger array s__DamageTrigger_autoTriggers
boolexpr array s__DamageTrigger_autoFuncs
integer s__DamageTrigger_autoN= 0
constant integer si__Damage=2
unit array s__Damage_sourceUnit
unit array s__Damage_targetUnit
real array s__Damage_damage
real array s__Damage_prevAmt
attacktype array s__Damage_attackType
damagetype array s__Damage_damageType
weapontype array s__Damage_weaponType
integer array s__Damage_userType
boolean array s__Damage_isAttack
boolean array s__Damage_isCode
boolean array s__Damage_isSpell
boolean array s__Damage_isMelee
boolean array s__Damage_isRanged
integer array s__Damage_eFilter
real array s__Damage_armorPierced
integer array s__Damage_armorType
integer array s__Damage_defenseType
integer s__Damage_index= 0
integer s__Damage_damageStack= 0
integer s__Damage_prepped= 0
integer s__Damage_count= 0
integer array s__Damage_stackRef
integer array s__Damage_recursiveTrig
integer array s__Damage_prevArmorT
integer array s__Damage_prevDefenseT
boolean s__Damage_arisen= false
constant integer si__ExtendableBonusSystem_ExtendableBonusPlugin=3
integer si__ExtendableBonusSystem_ExtendableBonusPlugin_F=0
integer si__ExtendableBonusSystem_ExtendableBonusPlugin_I=0
integer array si__ExtendableBonusSystem_ExtendableBonusPlugin_V
integer array si__ExtendableBonusSystem_ExtendableBonusPlugin_type
trigger array st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy
trigger array st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus
trigger array st__ExtendableBonusSystem_ExtendableBonusPlugin_Get
trigger array st__ExtendableBonusSystem_ExtendableBonusPlugin_Set
constant integer si__RealAbilityBonus=4
constant integer si__IntegerAbilityBonus=5
constant integer si__ExtendableBonus=6
integer si__ExtendableBonus_F=0
integer si__ExtendableBonus_I=0
integer array si__ExtendableBonus_V
integer array s__ExtendableBonus_registeredBonuses
constant integer si__LineSegment=7
constant real s__LineSegment_MAX_UNIT_COLLISION= 197.00
constant rect s__LineSegment_RECT= Rect(0, 0, 0, 0)
constant group s__LineSegment_GROUP= CreateGroup()
real s__LineSegment_ox
real s__LineSegment_oy
real s__LineSegment_dx
real s__LineSegment_dy
real s__LineSegment_da
real s__LineSegment_db
real s__LineSegment_ui
real s__LineSegment_uj
real s__LineSegment_wdx
real s__LineSegment_wdy
integer s__LineSegment_DestructableCounter= - 1
destructable array s__LineSegment_Destructable
integer s__LineSegment_ItemCounter= - 1
item array s__LineSegment_Item
constant integer si__UserMouse=8
constant real s__UserMouse_INTERVAL= 0.031250000
constant integer s__UserMouse_MOUSE_COUNT_MAX= 16
constant integer s__UserMouse_MOUSE_COUNT_LOSS= 8
constant boolean s__UserMouse_IS_INSTANT= ( s__UserMouse_INTERVAL <= 0. )
integer s__UserMouse_currentEventType= 0
integer s__UserMouse_updateCount= 0
trigger s__UserMouse_stateDetector= null
timer s__UserMouse_resetTimer= null
integer array s__UserMouse_mouseEventCount
timer array s__UserMouse_mouseEventReductor
trigger array s__UserMouse_evTrigger
integer array s__UserMouse_mouseButtonStack
integer array s__UserMouse_next
integer array s__UserMouse_prev
integer array s__UserMouse_resetNext
integer array s__UserMouse_resetPrev
trigger array s__UserMouse_posDetector
integer array s__UserMouse_mouseClickCount
real array s__UserMouse_mouseX
real array s__UserMouse_mouseY
constant integer si__Table__dex=9
constant integer si__Table__handles=10
constant integer si__Table__agents=11
constant integer si__Table__reals=12
constant integer si__Table__booleans=13
constant integer si__Table__strings=14
constant integer si__Table__integers=15
constant integer si__Table__players=16
constant integer si__Table__widgets=17
constant integer si__Table__destructables=18
constant integer si__Table__items=19
constant integer si__Table__units=20
constant integer si__Table__abilitys=21
constant integer si__Table__timers=22
constant integer si__Table__triggers=23
constant integer si__Table__triggerconditions=24
constant integer si__Table__triggeractions=25
constant integer si__Table__events=26
constant integer si__Table__forces=27
constant integer si__Table__groups=28
constant integer si__Table__locations=29
constant integer si__Table__rects=30
constant integer si__Table__boolexprs=31
constant integer si__Table__sounds=32
constant integer si__Table__effects=33
constant integer si__Table__unitpools=34
constant integer si__Table__itempools=35
constant integer si__Table__quests=36
constant integer si__Table__questitems=37
constant integer si__Table__defeatconditions=38
constant integer si__Table__timerdialogs=39
constant integer si__Table__leaderboards=40
constant integer si__Table__multiboards=41
constant integer si__Table__multiboarditems=42
constant integer si__Table__trackables=43
constant integer si__Table__dialogs=44
constant integer si__Table__buttons=45
constant integer si__Table__texttags=46
constant integer si__Table__lightnings=47
constant integer si__Table__images=48
constant integer si__Table__ubersplats=49
constant integer si__Table__regions=50
constant integer si__Table__fogstates=51
constant integer si__Table__fogmodifiers=52
constant integer si__Table__hashtables=53
constant integer si__Table=54
constant integer si__TableArray=55
integer s__TableArray_tempTable
integer s__TableArray_tempEnd
constant integer si__HashTable=56
constant integer si__WorldBounds=57
integer s__WorldBounds_maxX
integer s__WorldBounds_maxY
integer s__WorldBounds_minX
integer s__WorldBounds_minY
integer s__WorldBounds_centerX
integer s__WorldBounds_centerY
rect s__WorldBounds_world
region s__WorldBounds_worldRegion
real s__WorldBounds_playMaxX
real s__WorldBounds_playMaxY
real s__WorldBounds_playMinX
real s__WorldBounds_playMinY
constant integer si__CooldownReduction__AbilityList=58
integer s__CooldownReduction__AbilityList_Alloc___instanceCount= 0
integer array s__CooldownReduction__AbilityList_Alloc___recycle
integer array s__CooldownReduction__AbilityList_next
integer array s__CooldownReduction__AbilityList_prev
unit array s__CooldownReduction__AbilityList_unit
ability array s__CooldownReduction__AbilityList_ability
integer array s__CooldownReduction__AbilityList_defaults
integer array s__CooldownReduction__AbilityList_id
integer array s__CooldownReduction__AbilityList_levels
constant integer si__CDR=59
integer si__CDR_F=0
integer si__CDR_I=0
integer array si__CDR_V
hashtable s__CDR_hashtable= InitHashtable()
integer array s__CDR_n
integer array s__CDR_count
real array s__CDR_normal
real array s__CDR_flat
real array s__CDR_offset
constant integer si__DummyRecycler__S=60
integer s__DummyRecycler__S_tb
constant integer si__BonusDamage=61
constant integer si__BonusArmor=62
constant integer si__BonusMovementSpeed=63
constant integer si__BonusSightRange=64
constant integer si__BonusAgility=65
constant integer si__BonusStrength=66
constant integer si__BonusIntelligence=67
constant integer si__BonusAttackSpeed=68
constant integer si__BonusHealthRegen=69
constant integer si__BonusManaRegen=70
constant integer si__BonusHealth=71
constant integer si__BonusMana=72
constant integer si__MissileEffect__Effect=73
integer array s__MissileEffect__Effect_next
integer array s__MissileEffect__Effect_prev
integer s__MissileEffect__Effect_Alloc___instanceCount= 0
integer array s__MissileEffect__Effect_Alloc___recycle
real array s__MissileEffect__Effect_x
real array s__MissileEffect__Effect_y
real array s__MissileEffect__Effect_z
real array s__MissileEffect__Effect_size
real array s__MissileEffect__Effect_yaw
real array s__MissileEffect__Effect_pitch
real array s__MissileEffect__Effect_roll
string array s__MissileEffect__Effect_path
effect array s__MissileEffect__Effect_effect
constant integer si__MissileEffect=74
integer si__MissileEffect_F=0
integer si__MissileEffect_I=0
integer array si__MissileEffect_V
real array s__MissileEffect_size
real array s__MissileEffect_yaw
real array s__MissileEffect_pitch
real array s__MissileEffect_roll
real array s__MissileEffect_time
integer array s__MissileEffect_transparency
integer array s__MissileEffect_animtype
integer array s__MissileEffect_playercolor
string array s__MissileEffect_path
effect array s__MissileEffect_effect
integer array s__MissileEffect_attachments
constant integer si__LockCamExtension=75
unit array s__LockCamExtension_u
real array s__LockCamExtension_relativeX
real array s__LockCamExtension_relativeY
constant integer si__NewBonusUtils__NewBonusUtils=76
integer si__NewBonusUtils__NewBonusUtils_F=0
integer si__NewBonusUtils__NewBonusUtils_I=0
integer array si__NewBonusUtils__NewBonusUtils_V
timer s__NewBonusUtils__NewBonusUtils_timer= CreateTimer()
integer s__NewBonusUtils__NewBonusUtils_key= - 1
integer array s__NewBonusUtils__NewBonusUtils_array
integer s__NewBonusUtils__NewBonusUtils_k= - 1
integer array s__NewBonusUtils__NewBonusUtils_items
unit array s__NewBonusUtils__NewBonusUtils_unit
item array s__NewBonusUtils__NewBonusUtils_item
real array s__NewBonusUtils__NewBonusUtils_ticks
integer array s__NewBonusUtils__NewBonusUtils_type
integer array s__NewBonusUtils__NewBonusUtils_buff
real array s__NewBonusUtils__NewBonusUtils_amount
boolean array s__NewBonusUtils__NewBonusUtils_link
constant integer si__EffectDestroyer=77
integer si__EffectDestroyer_F=0
integer si__EffectDestroyer_I=0
integer array si__EffectDestroyer_V
effect array s__EffectDestroyer_effect
constant integer si__LightningDestroyer=78
integer si__LightningDestroyer_F=0
integer si__LightningDestroyer_I=0
integer array si__LightningDestroyer_V
lightning array s__LightningDestroyer_effect
constant integer si__ItemDestroyer=79
integer si__ItemDestroyer_F=0
integer si__ItemDestroyer_I=0
integer array si__ItemDestroyer_V
item array s__ItemDestroyer_itemToDestroy
constant integer si__SpellEffectEvent__S=80
integer s__SpellEffectEvent__S_tb
constant integer si__CooldownReductionUtils__CDRUtils=81
timer s__CooldownReductionUtils__CDRUtils_t= CreateTimer()
integer s__CooldownReductionUtils__CDRUtils_didx= - 1
integer array s__CooldownReductionUtils__CDRUtils_data
unit array s__CooldownReductionUtils__CDRUtils_u
real array s__CooldownReductionUtils__CDRUtils_ticks
real array s__CooldownReductionUtils__CDRUtils_amount
integer array s__CooldownReductionUtils__CDRUtils_tipo
constant integer si__BonusSystemPower=82
constant integer si__BonusSystemSpeed=83
constant integer si__Missiles__MissileEvents=84
integer si__Missiles__MissileEvents_F=0
integer si__Missiles__MissileEvents_I=0
integer array si__Missiles__MissileEvents_V
integer array si__Missiles__MissileEvents_type
trigger array st__Missiles__MissileEvents_onDestroy
trigger array st__Missiles__MissileEvents_onHit
trigger array st__Missiles__MissileEvents_onMissile
trigger array st__Missiles__MissileEvents_onDestructable
trigger array st__Missiles__MissileEvents_onItem
trigger array st__Missiles__MissileEvents_onCliff
trigger array st__Missiles__MissileEvents_onTerrain
trigger array st__Missiles__MissileEvents_onTileset
trigger array st__Missiles__MissileEvents_onPeriod
trigger array st__Missiles__MissileEvents_onFinish
trigger array st__Missiles__MissileEvents_onBoundaries
trigger array st__Missiles__MissileEvents_onPause
trigger array st__Missiles__MissileEvents_onResume
trigger array st__Missiles__MissileEvents_onRemove
constant integer si__Missiles__Pool=85
integer si__Missiles__Pool_F=0
integer si__Missiles__Pool_I=0
integer array si__Missiles__Pool_V
player s__Missiles__Pool_player= Player(PLAYER_NEUTRAL_PASSIVE)
group s__Missiles__Pool_group= CreateGroup()
timer array s__Missiles__Pool_timer
unit array s__Missiles__Pool_unit
constant integer si__Missiles__Coordinates=86
integer si__Missiles__Coordinates_F=0
integer si__Missiles__Coordinates_I=0
integer array si__Missiles__Coordinates_V
real array s__Missiles__Coordinates_x
real array s__Missiles__Coordinates_y
real array s__Missiles__Coordinates_z
real array s__Missiles__Coordinates_angle
real array s__Missiles__Coordinates_distance
real array s__Missiles__Coordinates_square
real array s__Missiles__Coordinates_slope
real array s__Missiles__Coordinates_alpha
integer array s__Missiles__Coordinates_ref
constant integer si__Missiles=87
timer s__Missiles_timer= CreateTimer()
group s__Missiles_group= CreateGroup()
rect s__Missiles_rect= Rect(0., 0., 0., 0.)
hashtable s__Missiles_table= InitHashtable()
integer s__Missiles_last= 0
integer s__Missiles_temp= 0
integer s__Missiles_id= - 1
integer s__Missiles_pid= - 1
integer array s__Missiles_missiles
integer array s__Missiles_frozen
real s__Missiles_dilation= 1
integer array s__Missiles_collection
integer s__Missiles_count= - 1
real array s__Missiles_cA
real array s__Missiles_height
real array s__Missiles_open
real array s__Missiles_toZ
real array s__Missiles_time
real array s__Missiles_sight
unit array s__Missiles_dummy
integer array s__Missiles_pkey
integer array s__Missiles_index
integer array s__Missiles_impact
integer array s__Missiles_origin
integer array s__Missiles_effect
real array s__Missiles_x
real array s__Missiles_y
real array s__Missiles_z
real array s__Missiles_prevX
real array s__Missiles_prevY
real array s__Missiles_prevZ
real array s__Missiles_nextX
real array s__Missiles_nextY
real array s__Missiles_nextZ
real array s__Missiles_turn
real array s__Missiles_veloc
real array s__Missiles_travel
boolean array s__Missiles_launched
boolean array s__Missiles_allocated
boolean array s__Missiles_finished
boolean array s__Missiles_paused
integer array s__Missiles_tileset
unit array s__Missiles_source
unit array s__Missiles_target
player array s__Missiles_owner
boolean array s__Missiles_collideZ
real array s__Missiles_collision
real array s__Missiles_damage
real array s__Missiles_acceleration
integer array s__Missiles_data
integer array s__Missiles_type
boolean array s__Missiles_roll
constant integer si__TimedAbility=88
integer si__TimedAbility_F=0
integer si__TimedAbility_I=0
integer array si__TimedAbility_V
unit array s__TimedAbility_u
integer array s__TimedAbility_abil
boolean array s__TimedAbility_recycle
constant integer si__HeroStatsCore=89
integer si__HeroStatsCore_F=0
integer si__HeroStatsCore_I=0
integer array si__HeroStatsCore_V
integer array s__HeroStatsCore_coresApplied
constant integer si__MGroup=90
integer array s__MGroup_next
integer array s__MGroup_prev
integer s__MGroup_Alloc___instanceCount= 0
integer array s__MGroup_Alloc___recycle
integer array s__MGroup_missile
constant integer si__MissileGroup=91
integer si__MissileGroup_F=0
integer si__MissileGroup_I=0
integer array si__MissileGroup_V
integer array s__MissileGroup_group
integer array s__MissileGroup_size
constant integer si__KnockbackTZ=92
integer s__KnockbackTZ_lastProcessed= 0
timer s__KnockbackTZ_updTimer
real array s__KnockbackTZ_vx
real array s__KnockbackTZ_vy
real array s__KnockbackTZ_fx
real array s__KnockbackTZ_fy
real array s__KnockbackTZ_fPercent
real array s__KnockbackTZ_timeLeft
real array s__KnockbackTZ_mass
boolean array s__KnockbackTZ_massOverridden
real array s__KnockbackTZ_collision
boolean array s__KnockbackTZ_bounce
integer array s__KnockbackTZ_ticksSinceLastUpdate
constant integer si__DestructableUpdater=93
integer si__DestructableUpdater_F=0
integer si__DestructableUpdater_I=0
integer array si__DestructableUpdater_V
integer s__DestructableUpdater_table
unit s__DestructableUpdater_u
real s__DestructableUpdater_ux
real s__DestructableUpdater_uy
constant integer si__MetroidvaniaController__ActionInterface=94
integer si__MetroidvaniaController__ActionInterface_F=0
integer si__MetroidvaniaController__ActionInterface_I=0
integer array si__MetroidvaniaController__ActionInterface_V
integer array si__MetroidvaniaController__ActionInterface_type
trigger array st__MetroidvaniaController__ActionInterface_onDestroy
trigger array st__MetroidvaniaController__ActionInterface_onStart
trigger array st__MetroidvaniaController__ActionInterface_onActionPoint
trigger array st__MetroidvaniaController__ActionInterface_onBackswing
trigger array st__MetroidvaniaController__ActionInterface_onRelease
trigger array st__MetroidvaniaController__ActionInterface_onCooldownFinished
trigger array st__MetroidvaniaController__ActionInterface_animationSpeed
trigger array st__MetroidvaniaController__ActionInterface_abilityText
trigger array st__MetroidvaniaController__ActionInterface_abilityName
constant integer si__CooldownDetails=95
integer s__CooldownDetails_Alloc___instanceCount= 0
integer array s__CooldownDetails_Alloc___recycle
real array s__CooldownDetails_actionPoint
real array s__CooldownDetails_actionDuration
real array s__CooldownDetails_actionCooldown
constant integer si__HeroActionBase=96
integer array s__HeroActionBase_actionState
boolean array s__HeroActionBase_isHolding
timer array s__HeroActionBase_cooldownTimer
unit array s__HeroActionBase_u
integer array s__HeroActionBase_cooldownDetails
integer array s__HeroActionBase_uiButtonIndex
real array s__HeroActionBase_energyCost
boolean array s__HeroActionBase_ignoreTarget
constant integer si__MetroidvaniaController=97
trigger s__MetroidvaniaController_mc_main_down
trigger s__MetroidvaniaController_mc_main_up
trigger s__MetroidvaniaController_mc_select
trigger s__MetroidvaniaController_mc_deselect
unit array s__MetroidvaniaController_u
unit array s__MetroidvaniaController_target
boolean array s__MetroidvaniaController_isHolding
timer array s__MetroidvaniaController_t
boolean array s__MetroidvaniaController_isDoingAction
integer array s__MetroidvaniaController_currentAction
integer array s__MetroidvaniaController_queuedAction
real array s__MetroidvaniaController_currentActionTargetX
real array s__MetroidvaniaController_currentActionTargetY
integer array s__MetroidvaniaController_attack
integer array s__MetroidvaniaController_attackAlt
integer array s__MetroidvaniaController_util1
integer array s__MetroidvaniaController_util2
integer array s__MetroidvaniaController_dash
integer array s__MetroidvaniaController_interact
integer array s__MetroidvaniaController_map
constant integer si__HeroAttackBasic=98
constant integer si__HeroAttackBasicAction=99
constant integer si__HeroAttackRapidAction=100
constant integer si__HeroBasicBombAction=101
real s__HeroBasicBombAction_baseDmg= 10.
real s__HeroBasicBombAction_percentDmg= 0.75
real s__HeroBasicBombAction_percentPower= 1.0
constant integer si__HeroBasicDash=102
constant integer si__HeroShockBlast=103
boolean array s__HeroShockBlast_isEmpowered
constant integer si__InteractAction=104
constant integer si__FinalBossHoming=105
integer array s__TimerUtils__data
timer array s__TimerUtils__tT
trigger array st__RealAbilityBonus_AbilityCode
trigger array st__RealAbilityBonus_Field
trigger array st__IntegerAbilityBonus_AbilityCode
trigger array st__IntegerAbilityBonus_Field
trigger array st__HeroActionBase_updateAbilityDetails
integer array si__CDR_type
trigger array st__CDR_onDestroy
trigger st__Missiles_terminate
trigger st__Missiles_reset
trigger st__Missiles_move
trigger st__Missiles_create
trigger st__HeroStatsCore_coresAppliedToStat
trigger st__HeroActionBase_create
trigger st__MetroidvaniaController_tryToExecuteAction
trigger st__MetroidvaniaController_updateAbilityDetails
trigger st__MetroidvaniaController_getAttack
trigger st__MetroidvaniaController_getAttackAlt
trigger st__MetroidvaniaController_getUtil1
trigger st__MetroidvaniaController_getUtil2
trigger st__MetroidvaniaController_getDash
trigger st__MetroidvaniaController_getInteract
trigger st__MetroidvaniaController_getTargetUnit
trigger st__MetroidvaniaController_getHero
trigger st__MetroidvaniaController_setTargetUnit
trigger st__MetroidvaniaController_getMetroidvaniaController
trigger st__HeroBasicBombAction_create
trigger st__HeroBasicBombAction_getDamage
trigger array st___prototype1
trigger array st___prototype2
trigger array st___prototype9
unit f__arg_unit1
real f__arg_real1
real f__arg_real2
real f__arg_real3
real f__arg_real4
real f__arg_real5
real f__arg_real6
integer f__arg_integer1
destructable f__arg_destructable1
item f__arg_item1
player f__arg_player1
string f__arg_string1
trigger f__arg_trigger1
limitop f__arg_limitop1
integer f__arg_this
boolean f__result_boolean
real f__result_real
integer f__result_integer
abilityreallevelfield f__result_abilityreallevelfield
abilityintegerlevelfield f__result_abilityintegerlevelfield
string f__result_string
unit f__result_unit

endglobals
native UnitAlive takes unit u returns boolean


//Generated method caller for ExtendableBonusSystem_ExtendableBonusPlugin.IsIntegerBonus
function sc__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for ExtendableBonusSystem_ExtendableBonusPlugin.IsIntegerBonus had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for ExtendableBonusSystem_ExtendableBonusPlugin.IsIntegerBonus
function sx__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
endfunction

//Generated method caller for ExtendableBonusSystem_ExtendableBonusPlugin.Get
function sc__ExtendableBonusSystem_ExtendableBonusPlugin_Get takes integer this,unit u returns real
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_real
endfunction

//Generated method executor for ExtendableBonusSystem_ExtendableBonusPlugin.Get
function sx__ExtendableBonusSystem_ExtendableBonusPlugin_Get takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerExecute(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
endfunction

//Generated method caller for ExtendableBonusSystem_ExtendableBonusPlugin.Set
function sc__ExtendableBonusSystem_ExtendableBonusPlugin_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_real
endfunction

//Generated method executor for ExtendableBonusSystem_ExtendableBonusPlugin.Set
function sx__ExtendableBonusSystem_ExtendableBonusPlugin_Set takes integer this,unit u,real value returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerExecute(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
endfunction
//Generated destructor of ExtendableBonusSystem_ExtendableBonusPlugin
function sc__ExtendableBonusSystem_ExtendableBonusPlugin_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=this
endfunction

//Generated method caller for RealAbilityBonus.AbilityCode
function sc__RealAbilityBonus_AbilityCode takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__RealAbilityBonus_AbilityCode[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_integer
endfunction

//Generated method caller for RealAbilityBonus.Field
function sc__RealAbilityBonus_Field takes integer this returns abilityreallevelfield
    set f__arg_this=this
    call TriggerEvaluate(st__RealAbilityBonus_Field[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_abilityreallevelfield
endfunction

//Generated method caller for RealAbilityBonus.Set
function sc__RealAbilityBonus_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4])
 return f__result_real
endfunction

//Generated method caller for RealAbilityBonus.Get
function sc__RealAbilityBonus_Get takes integer this,unit u returns real
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4])
 return f__result_real
endfunction

//Generated allocator of RealAbilityBonus
function s__RealAbilityBonus__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=4
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated method caller for IntegerAbilityBonus.AbilityCode
function sc__IntegerAbilityBonus_AbilityCode takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__IntegerAbilityBonus_AbilityCode[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_integer
endfunction

//Generated method caller for IntegerAbilityBonus.Field
function sc__IntegerAbilityBonus_Field takes integer this returns abilityintegerlevelfield
    set f__arg_this=this
    call TriggerEvaluate(st__IntegerAbilityBonus_Field[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]])
 return f__result_abilityintegerlevelfield
endfunction

//Generated method caller for IntegerAbilityBonus.Set
function sc__IntegerAbilityBonus_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5])
 return f__result_real
endfunction

//Generated method caller for IntegerAbilityBonus.Get
function sc__IntegerAbilityBonus_Get takes integer this,unit u returns real
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5])
 return f__result_real
endfunction

//Generated method caller for IntegerAbilityBonus.IsIntegerBonus
function sc__IntegerAbilityBonus_IsIntegerBonus takes integer this returns boolean
            return true
endfunction

//Generated allocator of IntegerAbilityBonus
function s__IntegerAbilityBonus__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=5
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated allocator of ExtendableBonus
function s__ExtendableBonus__allocate takes nothing returns integer
 local integer this=si__ExtendableBonus_F
    if (this!=0) then
        set si__ExtendableBonus_F=si__ExtendableBonus_V[this]
    else
        set si__ExtendableBonus_I=si__ExtendableBonus_I+1
        set this=si__ExtendableBonus_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonus_V[this]=-1
 return this
endfunction

//Generated destructor of ExtendableBonus
function s__ExtendableBonus_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ExtendableBonus_V[this]!=-1) then
        return
    endif
    set si__ExtendableBonus_V[this]=si__ExtendableBonus_F
    set si__ExtendableBonus_F=this
endfunction

//Generated method caller for MetroidvaniaController.tryToExecuteAction
function sc__MetroidvaniaController_tryToExecuteAction takes integer this,integer action returns nothing
    set f__arg_this=this
    set f__arg_integer1=action
    call TriggerEvaluate(st__MetroidvaniaController_tryToExecuteAction)
endfunction

//Generated method caller for MetroidvaniaController.updateAbilityDetails
function sc__MetroidvaniaController_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController_updateAbilityDetails)
endfunction

//Generated method caller for MetroidvaniaController.getAttack
function sc__MetroidvaniaController_getAttack takes integer this returns integer
            return s__MetroidvaniaController_attack[this]
endfunction

//Generated method caller for MetroidvaniaController.getAttackAlt
function sc__MetroidvaniaController_getAttackAlt takes integer this returns integer
            return s__MetroidvaniaController_attackAlt[this]
endfunction

//Generated method caller for MetroidvaniaController.getUtil1
function sc__MetroidvaniaController_getUtil1 takes integer this returns integer
            return s__MetroidvaniaController_util1[this]
endfunction

//Generated method caller for MetroidvaniaController.getUtil2
function sc__MetroidvaniaController_getUtil2 takes integer this returns integer
            return s__MetroidvaniaController_util2[this]
endfunction

//Generated method caller for MetroidvaniaController.getDash
function sc__MetroidvaniaController_getDash takes integer this returns integer
            return s__MetroidvaniaController_dash[this]
endfunction

//Generated method caller for MetroidvaniaController.getInteract
function sc__MetroidvaniaController_getInteract takes integer this returns integer
            return s__MetroidvaniaController_interact[this]
endfunction

//Generated method caller for MetroidvaniaController.getTargetUnit
function sc__MetroidvaniaController_getTargetUnit takes integer this returns unit
            return s__MetroidvaniaController_target[this]
endfunction

//Generated method caller for MetroidvaniaController.getHero
function sc__MetroidvaniaController_getHero takes integer this returns unit
            return s__MetroidvaniaController_u[this]
endfunction

//Generated method caller for MetroidvaniaController.setTargetUnit
function sc__MetroidvaniaController_setTargetUnit takes integer this,unit newTarget returns nothing
            set s__MetroidvaniaController_target[this]=newTarget
endfunction

//Generated method caller for MetroidvaniaController.getMetroidvaniaController
function sc__MetroidvaniaController_getMetroidvaniaController takes player p returns integer
    set f__arg_player1=p
    call TriggerEvaluate(st__MetroidvaniaController_getMetroidvaniaController)
 return f__result_integer
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.onStart
function sc__MetroidvaniaController__ActionInterface_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onStart[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.onStart
function sx__MetroidvaniaController__ActionInterface_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_onStart[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.onActionPoint
function sc__MetroidvaniaController__ActionInterface_onActionPoint takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onActionPoint[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.onActionPoint
function sx__MetroidvaniaController__ActionInterface_onActionPoint takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_onActionPoint[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.onBackswing
function sc__MetroidvaniaController__ActionInterface_onBackswing takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onBackswing[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.onBackswing
function sx__MetroidvaniaController__ActionInterface_onBackswing takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_onBackswing[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.onRelease
function sc__MetroidvaniaController__ActionInterface_onRelease takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onRelease[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.onRelease
function sx__MetroidvaniaController__ActionInterface_onRelease takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_onRelease[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.onCooldownFinished
function sc__MetroidvaniaController__ActionInterface_onCooldownFinished takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onCooldownFinished[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.onCooldownFinished
function sx__MetroidvaniaController__ActionInterface_onCooldownFinished takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_onCooldownFinished[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.animationSpeed
function sc__MetroidvaniaController__ActionInterface_animationSpeed takes integer this returns real
    set f__arg_this=this
    //An error in the next line would mean declaration for MetroidvaniaController__ActionInterface.animationSpeed had a wrong default (1.0)
    set f__result_real=1.0
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_animationSpeed[si__MetroidvaniaController__ActionInterface_type[this]])
 return f__result_real
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.animationSpeed
function sx__MetroidvaniaController__ActionInterface_animationSpeed takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_animationSpeed[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.abilityText
function sc__MetroidvaniaController__ActionInterface_abilityText takes integer this returns string
    set f__arg_this=this
    //An error in the next line would mean declaration for MetroidvaniaController__ActionInterface.abilityText had a wrong default ("TODO")
    set f__result_string="TODO"
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityText[si__MetroidvaniaController__ActionInterface_type[this]])
 return f__result_string
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.abilityText
function sx__MetroidvaniaController__ActionInterface_abilityText takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_abilityText[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for MetroidvaniaController__ActionInterface.abilityName
function sc__MetroidvaniaController__ActionInterface_abilityName takes integer this returns string
    set f__arg_this=this
    //An error in the next line would mean declaration for MetroidvaniaController__ActionInterface.abilityName had a wrong default ("TODO")
    set f__result_string="TODO"
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityName[si__MetroidvaniaController__ActionInterface_type[this]])
 return f__result_string
endfunction

//Generated method executor for MetroidvaniaController__ActionInterface.abilityName
function sx__MetroidvaniaController__ActionInterface_abilityName takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__MetroidvaniaController__ActionInterface_abilityName[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction
//Generated destructor of MetroidvaniaController__ActionInterface
function sc__MetroidvaniaController__ActionInterface_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MetroidvaniaController__ActionInterface_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onDestroy[si__MetroidvaniaController__ActionInterface_type[this]])
    set si__MetroidvaniaController__ActionInterface_V[this]=si__MetroidvaniaController__ActionInterface_F
    set si__MetroidvaniaController__ActionInterface_F=this
endfunction

//Generated allocator of DestructableUpdater
function s__DestructableUpdater__allocate takes nothing returns integer
 local integer this=si__DestructableUpdater_F
    if (this!=0) then
        set si__DestructableUpdater_F=si__DestructableUpdater_V[this]
    else
        set si__DestructableUpdater_I=si__DestructableUpdater_I+1
        set this=si__DestructableUpdater_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__DestructableUpdater_V[this]=-1
 return this
endfunction

//Generated destructor of DestructableUpdater
function s__DestructableUpdater_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__DestructableUpdater_V[this]!=-1) then
        return
    endif
    set si__DestructableUpdater_V[this]=si__DestructableUpdater_F
    set si__DestructableUpdater_F=this
endfunction

//Generated allocator of MissileGroup
function s__MissileGroup__allocate takes nothing returns integer
 local integer this=si__MissileGroup_F
    if (this!=0) then
        set si__MissileGroup_F=si__MissileGroup_V[this]
    else
        set si__MissileGroup_I=si__MissileGroup_I+1
        set this=si__MissileGroup_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__MissileGroup_V[this]=-1
 return this
endfunction

//Generated destructor of MissileGroup
function s__MissileGroup_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MissileGroup_V[this]!=-1) then
        return
    endif
    set si__MissileGroup_V[this]=si__MissileGroup_F
    set si__MissileGroup_F=this
endfunction

//Generated method caller for HeroStatsCore.coresAppliedToStat
function sc__HeroStatsCore_coresAppliedToStat takes player p,integer statIndex returns integer
            return s__HeroStatsCore_coresApplied[GetPlayerId(p) * STAT_COUNT + statIndex]
endfunction

//Generated allocator of HeroStatsCore
function s__HeroStatsCore__allocate takes nothing returns integer
 local integer this=si__HeroStatsCore_F
    if (this!=0) then
        set si__HeroStatsCore_F=si__HeroStatsCore_V[this]
    else
        set si__HeroStatsCore_I=si__HeroStatsCore_I+1
        set this=si__HeroStatsCore_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__HeroStatsCore_V[this]=-1
 return this
endfunction

//Generated destructor of HeroStatsCore
function s__HeroStatsCore_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__HeroStatsCore_V[this]!=-1) then
        return
    endif
    set si__HeroStatsCore_V[this]=si__HeroStatsCore_F
    set si__HeroStatsCore_F=this
endfunction

//Generated allocator of TimedAbility
function s__TimedAbility__allocate takes nothing returns integer
 local integer this=si__TimedAbility_F
    if (this!=0) then
        set si__TimedAbility_F=si__TimedAbility_V[this]
    else
        set si__TimedAbility_I=si__TimedAbility_I+1
        set this=si__TimedAbility_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__TimedAbility_V[this]=-1
 return this
endfunction

//Generated destructor of TimedAbility
function s__TimedAbility_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__TimedAbility_V[this]!=-1) then
        return
    endif
    set si__TimedAbility_V[this]=si__TimedAbility_F
    set si__TimedAbility_F=this
endfunction

//Generated allocator of Missiles__Coordinates
function s__Missiles__Coordinates__allocate takes nothing returns integer
 local integer this=si__Missiles__Coordinates_F
    if (this!=0) then
        set si__Missiles__Coordinates_F=si__Missiles__Coordinates_V[this]
    else
        set si__Missiles__Coordinates_I=si__Missiles__Coordinates_I+1
        set this=si__Missiles__Coordinates_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Missiles__Coordinates_V[this]=-1
 return this
endfunction

//Generated destructor of Missiles__Coordinates
function s__Missiles__Coordinates_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Missiles__Coordinates_V[this]!=-1) then
        return
    endif
    set si__Missiles__Coordinates_V[this]=si__Missiles__Coordinates_F
    set si__Missiles__Coordinates_F=this
endfunction

//Generated allocator of Missiles__Pool
function s__Missiles__Pool__allocate takes nothing returns integer
 local integer this=si__Missiles__Pool_F
    if (this!=0) then
        set si__Missiles__Pool_F=si__Missiles__Pool_V[this]
    else
        set si__Missiles__Pool_I=si__Missiles__Pool_I+1
        set this=si__Missiles__Pool_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Missiles__Pool_V[this]=-1
 return this
endfunction

//Generated destructor of Missiles__Pool
function s__Missiles__Pool_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Missiles__Pool_V[this]!=-1) then
        return
    endif
    set si__Missiles__Pool_V[this]=si__Missiles__Pool_F
    set si__Missiles__Pool_F=this
endfunction

//Generated method caller for Missiles__MissileEvents.onHit
function sc__Missiles__MissileEvents_onHit takes integer this,unit hit returns boolean
    set f__arg_this=this
    set f__arg_unit1=hit
    //An error in the next line would mean declaration for Missiles__MissileEvents.onHit had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onHit[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onHit
function sx__Missiles__MissileEvents_onHit takes integer this,unit hit returns nothing
    set f__arg_this=this
    set f__arg_unit1=hit
    call TriggerExecute(st__Missiles__MissileEvents_onHit[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onMissile
function sc__Missiles__MissileEvents_onMissile takes integer this,integer missile returns boolean
    set f__arg_this=this
    set f__arg_integer1=missile
    //An error in the next line would mean declaration for Missiles__MissileEvents.onMissile had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onMissile[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onMissile
function sx__Missiles__MissileEvents_onMissile takes integer this,integer missile returns nothing
    set f__arg_this=this
    set f__arg_integer1=missile
    call TriggerExecute(st__Missiles__MissileEvents_onMissile[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onDestructable
function sc__Missiles__MissileEvents_onDestructable takes integer this,destructable dest returns boolean
    set f__arg_this=this
    set f__arg_destructable1=dest
    //An error in the next line would mean declaration for Missiles__MissileEvents.onDestructable had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onDestructable[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onDestructable
function sx__Missiles__MissileEvents_onDestructable takes integer this,destructable dest returns nothing
    set f__arg_this=this
    set f__arg_destructable1=dest
    call TriggerExecute(st__Missiles__MissileEvents_onDestructable[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onItem
function sc__Missiles__MissileEvents_onItem takes integer this,item i returns boolean
    set f__arg_this=this
    set f__arg_item1=i
    //An error in the next line would mean declaration for Missiles__MissileEvents.onItem had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onItem[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onItem
function sx__Missiles__MissileEvents_onItem takes integer this,item i returns nothing
    set f__arg_this=this
    set f__arg_item1=i
    call TriggerExecute(st__Missiles__MissileEvents_onItem[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onCliff
function sc__Missiles__MissileEvents_onCliff takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onCliff had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onCliff[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onCliff
function sx__Missiles__MissileEvents_onCliff takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onCliff[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onTerrain
function sc__Missiles__MissileEvents_onTerrain takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onTerrain had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onTerrain[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onTerrain
function sx__Missiles__MissileEvents_onTerrain takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onTerrain[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onTileset
function sc__Missiles__MissileEvents_onTileset takes integer this,integer tileset returns boolean
    set f__arg_this=this
    set f__arg_integer1=tileset
    //An error in the next line would mean declaration for Missiles__MissileEvents.onTileset had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onTileset[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onTileset
function sx__Missiles__MissileEvents_onTileset takes integer this,integer tileset returns nothing
    set f__arg_this=this
    set f__arg_integer1=tileset
    call TriggerExecute(st__Missiles__MissileEvents_onTileset[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onPeriod
function sc__Missiles__MissileEvents_onPeriod takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onPeriod had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onPeriod[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onPeriod
function sx__Missiles__MissileEvents_onPeriod takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onPeriod[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onFinish
function sc__Missiles__MissileEvents_onFinish takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onFinish had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onFinish[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onFinish
function sx__Missiles__MissileEvents_onFinish takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onFinish[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onBoundaries
function sc__Missiles__MissileEvents_onBoundaries takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onBoundaries had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onBoundaries[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onBoundaries
function sx__Missiles__MissileEvents_onBoundaries takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onBoundaries[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onPause
function sc__Missiles__MissileEvents_onPause takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onPause had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onPause[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onPause
function sx__Missiles__MissileEvents_onPause takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onPause[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onResume
function sc__Missiles__MissileEvents_onResume takes integer this returns boolean
    set f__arg_this=this
    //An error in the next line would mean declaration for Missiles__MissileEvents.onResume had a wrong default (false)
    set f__result_boolean=false
    call TriggerEvaluate(st__Missiles__MissileEvents_onResume[si__Missiles__MissileEvents_type[this]])
 return f__result_boolean
endfunction

//Generated method executor for Missiles__MissileEvents.onResume
function sx__Missiles__MissileEvents_onResume takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onResume[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method caller for Missiles__MissileEvents.onRemove
function sc__Missiles__MissileEvents_onRemove takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Missiles__MissileEvents_onRemove[si__Missiles__MissileEvents_type[this]])
endfunction

//Generated method executor for Missiles__MissileEvents.onRemove
function sx__Missiles__MissileEvents_onRemove takes integer this returns nothing
    set f__arg_this=this
    call TriggerExecute(st__Missiles__MissileEvents_onRemove[si__Missiles__MissileEvents_type[this]])
endfunction
//Generated destructor of Missiles__MissileEvents
function sc__Missiles__MissileEvents_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Missiles__MissileEvents_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__Missiles__MissileEvents_onDestroy[si__Missiles__MissileEvents_type[this]])
    set si__Missiles__MissileEvents_V[this]=si__Missiles__MissileEvents_F
    set si__Missiles__MissileEvents_F=this
endfunction

//Generated method caller for BonusSystemSpeed.IsIntegerBonus
function sc__BonusSystemSpeed_IsIntegerBonus takes integer this returns boolean
            return true
endfunction

//Generated method caller for BonusSystemSpeed.Get
function sc__BonusSystemSpeed_Get takes integer this,unit u returns real
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[83])
 return f__result_real
endfunction

//Generated method caller for BonusSystemSpeed.Set
function sc__BonusSystemSpeed_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[83])
 return f__result_real
endfunction

//Generated allocator of BonusSystemSpeed
function s__BonusSystemSpeed__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=83
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated method caller for BonusSystemPower.IsIntegerBonus
function sc__BonusSystemPower_IsIntegerBonus takes integer this returns boolean
            return true
endfunction

//Generated method caller for BonusSystemPower.Get
function sc__BonusSystemPower_Get takes integer this,unit u returns real
            return I2R(systempower[GetUnitUserData(u)])
endfunction

//Generated method caller for BonusSystemPower.Set
function sc__BonusSystemPower_Set takes integer this,unit u,real value returns real
            local integer unitIndex= GetUnitUserData(u)
            set systempower[unitIndex]=R2I(value)
            return I2R(systempower[unitIndex])
endfunction

//Generated allocator of BonusSystemPower
function s__BonusSystemPower__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=82
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated allocator of ItemDestroyer
function s__ItemDestroyer__allocate takes nothing returns integer
 local integer this=si__ItemDestroyer_F
    if (this!=0) then
        set si__ItemDestroyer_F=si__ItemDestroyer_V[this]
    else
        set si__ItemDestroyer_I=si__ItemDestroyer_I+1
        set this=si__ItemDestroyer_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ItemDestroyer_V[this]=-1
 return this
endfunction

//Generated destructor of ItemDestroyer
function s__ItemDestroyer_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ItemDestroyer_V[this]!=-1) then
        return
    endif
    set si__ItemDestroyer_V[this]=si__ItemDestroyer_F
    set si__ItemDestroyer_F=this
endfunction

//Generated allocator of LightningDestroyer
function s__LightningDestroyer__allocate takes nothing returns integer
 local integer this=si__LightningDestroyer_F
    if (this!=0) then
        set si__LightningDestroyer_F=si__LightningDestroyer_V[this]
    else
        set si__LightningDestroyer_I=si__LightningDestroyer_I+1
        set this=si__LightningDestroyer_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__LightningDestroyer_V[this]=-1
 return this
endfunction

//Generated destructor of LightningDestroyer
function s__LightningDestroyer_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__LightningDestroyer_V[this]!=-1) then
        return
    endif
    set si__LightningDestroyer_V[this]=si__LightningDestroyer_F
    set si__LightningDestroyer_F=this
endfunction

//Generated allocator of EffectDestroyer
function s__EffectDestroyer__allocate takes nothing returns integer
 local integer this=si__EffectDestroyer_F
    if (this!=0) then
        set si__EffectDestroyer_F=si__EffectDestroyer_V[this]
    else
        set si__EffectDestroyer_I=si__EffectDestroyer_I+1
        set this=si__EffectDestroyer_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__EffectDestroyer_V[this]=-1
 return this
endfunction

//Generated destructor of EffectDestroyer
function s__EffectDestroyer_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__EffectDestroyer_V[this]!=-1) then
        return
    endif
    set si__EffectDestroyer_V[this]=si__EffectDestroyer_F
    set si__EffectDestroyer_F=this
endfunction

//Generated allocator of NewBonusUtils__NewBonusUtils
function s__NewBonusUtils__NewBonusUtils__allocate takes nothing returns integer
 local integer this=si__NewBonusUtils__NewBonusUtils_F
    if (this!=0) then
        set si__NewBonusUtils__NewBonusUtils_F=si__NewBonusUtils__NewBonusUtils_V[this]
    else
        set si__NewBonusUtils__NewBonusUtils_I=si__NewBonusUtils__NewBonusUtils_I+1
        set this=si__NewBonusUtils__NewBonusUtils_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__NewBonusUtils__NewBonusUtils_V[this]=-1
 return this
endfunction

//Generated destructor of NewBonusUtils__NewBonusUtils
function s__NewBonusUtils__NewBonusUtils_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__NewBonusUtils__NewBonusUtils_V[this]!=-1) then
        return
    endif
    set si__NewBonusUtils__NewBonusUtils_V[this]=si__NewBonusUtils__NewBonusUtils_F
    set si__NewBonusUtils__NewBonusUtils_F=this
endfunction

//Generated allocator of MissileEffect
function s__MissileEffect__allocate takes nothing returns integer
 local integer this=si__MissileEffect_F
    if (this!=0) then
        set si__MissileEffect_F=si__MissileEffect_V[this]
    else
        set si__MissileEffect_I=si__MissileEffect_I+1
        set this=si__MissileEffect_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__MissileEffect_V[this]=-1
 return this
endfunction

//Generated destructor of MissileEffect
function s__MissileEffect_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MissileEffect_V[this]!=-1) then
        return
    endif
    set si__MissileEffect_V[this]=si__MissileEffect_F
    set si__MissileEffect_F=this
endfunction

//Generated method caller for BonusMana.IsIntegerBonus
function sc__BonusMana_IsIntegerBonus takes integer this returns boolean
            return true
endfunction

//Generated method caller for BonusMana.Get
function sc__BonusMana_Get takes integer this,unit u returns real
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY), ExtendableBonusesBasicBonuses__MANA_FIELD, 0))
endfunction

//Generated method caller for BonusMana.Set
function sc__BonusMana_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[72])
 return f__result_real
endfunction

//Generated allocator of BonusMana
function s__BonusMana__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=72
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated method caller for BonusHealth.IsIntegerBonus
function sc__BonusHealth_IsIntegerBonus takes integer this returns boolean
            return true
endfunction

//Generated method caller for BonusHealth.Get
function sc__BonusHealth_Get takes integer this,unit u returns real
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY), ExtendableBonusesBasicBonuses__HEALTH_FIELD, 0))
endfunction

//Generated method caller for BonusHealth.Set
function sc__BonusHealth_Set takes integer this,unit u,real value returns real
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_real1=value
    call TriggerEvaluate(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[71])
 return f__result_real
endfunction

//Generated allocator of BonusHealth
function s__BonusHealth__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__ExtendableBonusSystem_ExtendableBonusPlugin_F
    if (this!=0) then
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_F=si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]
    else
        set si__ExtendableBonusSystem_ExtendableBonusPlugin_I=si__ExtendableBonusSystem_ExtendableBonusPlugin_I+1
        set this=si__ExtendableBonusSystem_ExtendableBonusPlugin_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=71
    set kthis=this

    set si__ExtendableBonusSystem_ExtendableBonusPlugin_V[this]=-1
 return this
endfunction


//Generated method caller for BonusManaRegen.AbilityCode
function sc__BonusManaRegen_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__MANAREGEN_ABILITY
endfunction

//Generated method caller for BonusManaRegen.Field
function sc__BonusManaRegen_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__MANAREGEN_FIELD
endfunction

//Generated allocator of BonusManaRegen
function s__BonusManaRegen__allocate takes nothing returns integer
 local integer this=s__RealAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=70
    set kthis=this

 return this
endfunction


//Generated method caller for BonusHealthRegen.AbilityCode
function sc__BonusHealthRegen_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__HEALTHREGEN_ABILITY
endfunction

//Generated method caller for BonusHealthRegen.Field
function sc__BonusHealthRegen_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__HEALTHREGEN_FIELD
endfunction

//Generated allocator of BonusHealthRegen
function s__BonusHealthRegen__allocate takes nothing returns integer
 local integer this=s__RealAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=69
    set kthis=this

 return this
endfunction


//Generated method caller for BonusAttackSpeed.AbilityCode
function sc__BonusAttackSpeed_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__ATTACKSPEED_ABILITY
endfunction

//Generated method caller for BonusAttackSpeed.Field
function sc__BonusAttackSpeed_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__ATTACKSPEED_FIELD
endfunction

//Generated allocator of BonusAttackSpeed
function s__BonusAttackSpeed__allocate takes nothing returns integer
 local integer this=s__RealAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=68
    set kthis=this

 return this
endfunction


//Generated method caller for BonusIntelligence.AbilityCode
function sc__BonusIntelligence_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
endfunction

//Generated method caller for BonusIntelligence.Field
function sc__BonusIntelligence_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__INTELLIGENCE_FIELD
endfunction

//Generated allocator of BonusIntelligence
function s__BonusIntelligence__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=67
    set kthis=this

 return this
endfunction


//Generated method caller for BonusStrength.AbilityCode
function sc__BonusStrength_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
endfunction

//Generated method caller for BonusStrength.Field
function sc__BonusStrength_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__STRENGTH_FIELD
endfunction

//Generated allocator of BonusStrength
function s__BonusStrength__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=66
    set kthis=this

 return this
endfunction


//Generated method caller for BonusAgility.AbilityCode
function sc__BonusAgility_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
endfunction

//Generated method caller for BonusAgility.Field
function sc__BonusAgility_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__AGILITY_FIELD
endfunction

//Generated allocator of BonusAgility
function s__BonusAgility__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=65
    set kthis=this

 return this
endfunction


//Generated method caller for BonusSightRange.AbilityCode
function sc__BonusSightRange_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__SIGHT_RANGE_ABILITY
endfunction

//Generated method caller for BonusSightRange.Field
function sc__BonusSightRange_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__SIGHT_RANGE_FIELD
endfunction

//Generated allocator of BonusSightRange
function s__BonusSightRange__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=64
    set kthis=this

 return this
endfunction


//Generated method caller for BonusMovementSpeed.AbilityCode
function sc__BonusMovementSpeed_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__MOVEMENTSPEED_ABILITY
endfunction

//Generated method caller for BonusMovementSpeed.Field
function sc__BonusMovementSpeed_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__MOVEMENTSPEED_FIELD
endfunction

//Generated allocator of BonusMovementSpeed
function s__BonusMovementSpeed__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=63
    set kthis=this

 return this
endfunction


//Generated method caller for BonusArmor.AbilityCode
function sc__BonusArmor_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__ARMOR_ABILITY
endfunction

//Generated method caller for BonusArmor.Field
function sc__BonusArmor_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__ARMOR_FIELD
endfunction

//Generated allocator of BonusArmor
function s__BonusArmor__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=62
    set kthis=this

 return this
endfunction


//Generated method caller for BonusDamage.AbilityCode
function sc__BonusDamage_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__DAMAGE_ABILITY
endfunction

//Generated method caller for BonusDamage.Field
function sc__BonusDamage_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__DAMAGE_FIELD
endfunction

//Generated allocator of BonusDamage
function s__BonusDamage__allocate takes nothing returns integer
 local integer this=s__IntegerAbilityBonus__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__ExtendableBonusSystem_ExtendableBonusPlugin_type[this]=61
    set kthis=this

 return this
endfunction


//Generated allocator of CDR
function s__CDR__allocate takes nothing returns integer
 local integer this=si__CDR_F
    if (this!=0) then
        set si__CDR_F=si__CDR_V[this]
    else
        set si__CDR_I=si__CDR_I+1
        set this=si__CDR_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CDR_type[this]=59
    set si__CDR_V[this]=-1
 return this
endfunction

//Generated destructor of CDR
function sc__CDR_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__CDR_V[this]!=-1) then
        return
    endif
    set f__arg_this=this
    call TriggerEvaluate(st__CDR_onDestroy[si__CDR_type[this]])
    set si__CDR_V[this]=si__CDR_F
    set si__CDR_F=this
endfunction

//Generated method caller for HeroActionBase.updateAbilityDetails
function sc__HeroActionBase_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[si__MetroidvaniaController__ActionInterface_type[this]])
endfunction

//Generated method caller for HeroActionBase.create
function sc__HeroActionBase_create takes unit u,integer uiIndex,string iconPath returns integer
    set f__arg_unit1=u
    set f__arg_integer1=uiIndex
    set f__arg_string1=iconPath
    call TriggerEvaluate(st__HeroActionBase_create)
 return f__result_integer
endfunction

//Generated allocator of HeroActionBase
function s__HeroActionBase__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__MetroidvaniaController__ActionInterface_F
    if (this!=0) then
        set si__MetroidvaniaController__ActionInterface_F=si__MetroidvaniaController__ActionInterface_V[this]
    else
        set si__MetroidvaniaController__ActionInterface_I=si__MetroidvaniaController__ActionInterface_I+1
        set this=si__MetroidvaniaController__ActionInterface_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__MetroidvaniaController__ActionInterface_type[this]=96
    set kthis=this

    set si__MetroidvaniaController__ActionInterface_V[this]=-1
 return this
endfunction


//Generated allocator of CooldownReductionUtils__CDRUtils
function s__CooldownReductionUtils__CDRUtils__allocate takes nothing returns integer
 local integer this=s__CDR__allocate()
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__CDR_type[this]=81
    set kthis=this

 return this
endfunction


//Generated method caller for Missiles.terminate
function sc__Missiles_terminate takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Missiles_terminate)
endfunction

//Generated method caller for Missiles.reset
function sc__Missiles_reset takes integer this returns nothing
            set s__Missiles_launched[this]=false
            set s__Missiles_finished[this]=false
            set s__Missiles_collideZ[this]=false
            set s__Missiles_paused[this]=false
            set s__Missiles_roll[this]=false
            set s__Missiles_source[this]=null
            set s__Missiles_target[this]=null
            set s__Missiles_owner[this]=null
            set s__Missiles_dummy[this]=null
            set s__Missiles_open[this]=0.
            set s__Missiles_height[this]=0.
            set s__Missiles_veloc[this]=0.
            set s__Missiles_acceleration[this]=0.
            set s__Missiles_collision[this]=0.
            set s__Missiles_damage[this]=0.
            set s__Missiles_travel[this]=0.
            set s__Missiles_turn[this]=0.
            set s__Missiles_time[this]=0.
            set s__Missiles_sight[this]=0.
            set s__Missiles_data[this]=0
            set s__Missiles_type[this]=0
            set s__Missiles_tileset[this]=0
            set s__Missiles_pkey[this]=- 1
            set s__Missiles_index[this]=- 1
endfunction

//Generated method caller for Missiles.move
function sc__Missiles_move takes nothing returns nothing
    call TriggerEvaluate(st__Missiles_move)
endfunction

//Generated method caller for Missiles.create
function sc__Missiles_create takes real x,real y,real z,real toX,real toY,real toZ returns integer
    set f__arg_real1=x
    set f__arg_real2=y
    set f__arg_real3=z
    set f__arg_real4=toX
    set f__arg_real5=toY
    set f__arg_real6=toZ
    call TriggerEvaluate(st__Missiles_create)
 return f__result_integer
endfunction

//Generated allocator of Missiles
function s__Missiles__allocate takes nothing returns integer
 local integer kthis
 local integer this=si__Missiles__MissileEvents_F
    if (this!=0) then
        set si__Missiles__MissileEvents_F=si__Missiles__MissileEvents_V[this]
    else
        set si__Missiles__MissileEvents_I=si__Missiles__MissileEvents_I+1
        set this=si__Missiles__MissileEvents_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Missiles__MissileEvents_type[this]=87
    set kthis=this

    set si__Missiles__MissileEvents_V[this]=-1
 return this
endfunction


//Generated method caller for FinalBossHoming.onFinish
function sc__FinalBossHoming_onFinish takes integer this returns boolean
        return true
endfunction

//Generated method caller for FinalBossHoming.onHit
function sc__FinalBossHoming_onHit takes integer this,unit hit returns boolean
    set f__arg_this=this
    set f__arg_unit1=hit
    call TriggerEvaluate(st__Missiles__MissileEvents_onHit[105])
 return f__result_boolean
endfunction

//Generated method caller for FinalBossHoming.onDestructable
function sc__FinalBossHoming_onDestructable takes integer this,destructable dest returns boolean
        if GetDestructableOccluderHeight(dest) > 50.0 and GetDestructableLife(dest) > 0. then
            return true
        else
            return false
        endif
endfunction

//Generated method caller for FinalBossHoming.onTerrain
function sc__FinalBossHoming_onTerrain takes integer this returns boolean
        return true
endfunction

//Generated method caller for FinalBossHoming.onTileset
function sc__FinalBossHoming_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
endfunction

//Generated allocator of FinalBossHoming
function s__FinalBossHoming__allocate takes real x ,real y ,real z ,real toX ,real toY ,real toZ returns integer
 local integer this=sc__Missiles_create(x,y,z,toX,toY,toZ)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__Missiles__MissileEvents_type[this]=105
    set kthis=this

 return this
endfunction


//Generated method caller for HeroAttackBasic.onFinish
function sc__HeroAttackBasic_onFinish takes integer this returns boolean
        return true
endfunction

//Generated method caller for HeroAttackBasic.onHit
function sc__HeroAttackBasic_onHit takes integer this,unit hit returns boolean
    set f__arg_this=this
    set f__arg_unit1=hit
    call TriggerEvaluate(st__Missiles__MissileEvents_onHit[98])
 return f__result_boolean
endfunction

//Generated method caller for HeroAttackBasic.onDestructable
function sc__HeroAttackBasic_onDestructable takes integer this,destructable dest returns boolean
    set f__arg_this=this
    set f__arg_destructable1=dest
    call TriggerEvaluate(st__Missiles__MissileEvents_onDestructable[98])
 return f__result_boolean
endfunction

//Generated method caller for HeroAttackBasic.onTerrain
function sc__HeroAttackBasic_onTerrain takes integer this returns boolean
        return true
endfunction

//Generated method caller for HeroAttackBasic.onTileset
function sc__HeroAttackBasic_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
endfunction

//Generated allocator of HeroAttackBasic
function s__HeroAttackBasic__allocate takes real x ,real y ,real z ,real toX ,real toY ,real toZ returns integer
 local integer this=sc__Missiles_create(x,y,z,toX,toY,toZ)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__Missiles__MissileEvents_type[this]=98
    set kthis=this

 return this
endfunction


//Generated method caller for HeroAttackBasicAction.animationSpeed
function sc__HeroAttackBasicAction_animationSpeed takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_animationSpeed[99])
 return f__result_real
endfunction

//Generated method caller for HeroAttackBasicAction.updateAbilityDetails
function sc__HeroAttackBasicAction_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[99])
endfunction

//Generated method caller for HeroAttackBasicAction.onStart
function sc__HeroAttackBasicAction_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onStart[99])
endfunction

//Generated method caller for HeroAttackBasicAction.onActionPoint
function sc__HeroAttackBasicAction_onActionPoint takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onActionPoint[99])
endfunction

//Generated method caller for HeroAttackBasicAction.abilityText
function sc__HeroAttackBasicAction_abilityText takes integer this returns string
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityText[99])
 return f__result_string
endfunction

//Generated method caller for HeroAttackBasicAction.abilityName
function sc__HeroAttackBasicAction_abilityName takes integer this returns string
        return "[Q] Plasma Bolt"
endfunction

//Generated allocator of HeroAttackBasicAction
function s__HeroAttackBasicAction__allocate takes unit u ,integer uiIndex ,string iconPath returns integer
 local integer this=sc__HeroActionBase_create(u,uiIndex,iconPath)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__MetroidvaniaController__ActionInterface_type[this]=99
    set kthis=this

 return this
endfunction


//Generated method caller for HeroAttackRapidAction.animationSpeed
function sc__HeroAttackRapidAction_animationSpeed takes integer this returns real
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_animationSpeed[100])
 return f__result_real
endfunction

//Generated method caller for HeroAttackRapidAction.updateAbilityDetails
function sc__HeroAttackRapidAction_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[100])
endfunction

//Generated method caller for HeroAttackRapidAction.onStart
function sc__HeroAttackRapidAction_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onStart[100])
endfunction

//Generated method caller for HeroAttackRapidAction.onActionPoint
function sc__HeroAttackRapidAction_onActionPoint takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onActionPoint[100])
endfunction

//Generated method caller for HeroAttackRapidAction.abilityText
function sc__HeroAttackRapidAction_abilityText takes integer this returns string
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityText[100])
 return f__result_string
endfunction

//Generated method caller for HeroAttackRapidAction.abilityName
function sc__HeroAttackRapidAction_abilityName takes integer this returns string
        return "[Q] Plasma Bolt"
endfunction

//Generated allocator of HeroAttackRapidAction
function s__HeroAttackRapidAction__allocate takes unit u ,integer uiIndex ,string iconPath returns integer
 local integer this=sc__HeroActionBase_create(u,uiIndex,iconPath)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__MetroidvaniaController__ActionInterface_type[this]=100
    set kthis=this

 return this
endfunction


//Generated method caller for HeroBasicBombAction.updateAbilityDetails
function sc__HeroBasicBombAction_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[101])
endfunction

//Generated method caller for HeroBasicBombAction.onStart
function sc__HeroBasicBombAction_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onStart[101])
endfunction

//Generated method caller for HeroBasicBombAction.create
function sc__HeroBasicBombAction_create takes unit u returns integer
    set f__arg_unit1=u
    call TriggerEvaluate(st__HeroBasicBombAction_create)
 return f__result_integer
endfunction

//Generated method caller for HeroBasicBombAction.getDamage
function sc__HeroBasicBombAction_getDamage takes unit u returns real
    set f__arg_unit1=u
    call TriggerEvaluate(st__HeroBasicBombAction_getDamage)
 return f__result_real
endfunction

//Generated method caller for HeroBasicBombAction.abilityText
function sc__HeroBasicBombAction_abilityText takes integer this returns string
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityText[101])
 return f__result_string
endfunction

//Generated method caller for HeroBasicBombAction.abilityName
function sc__HeroBasicBombAction_abilityName takes integer this returns string
        return "[E] Energy Bomb"
endfunction

//Generated allocator of HeroBasicBombAction
function s__HeroBasicBombAction__allocate takes unit u ,integer uiIndex ,string iconPath returns integer
 local integer this=sc__HeroActionBase_create(u,uiIndex,iconPath)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__MetroidvaniaController__ActionInterface_type[this]=101
    set kthis=this

 return this
endfunction


//Generated method caller for HeroBasicDash.updateAbilityDetails
function sc__HeroBasicDash_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[102])
endfunction

//Generated method caller for HeroBasicDash.onStart
function sc__HeroBasicDash_onStart takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onStart[102])
endfunction

//Generated method caller for HeroBasicDash.abilityText
function sc__HeroBasicDash_abilityText takes integer this returns string
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_abilityText[102])
 return f__result_string
endfunction

//Generated method caller for HeroBasicDash.abilityName
function sc__HeroBasicDash_abilityName takes integer this returns string
        return "[D] Dash"
endfunction

//Generated allocator of HeroBasicDash
function s__HeroBasicDash__allocate takes unit u ,integer uiIndex ,string iconPath returns integer
 local integer this=sc__HeroActionBase_create(u,uiIndex,iconPath)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__MetroidvaniaController__ActionInterface_type[this]=102
    set kthis=this

 return this
endfunction


//Generated method caller for HeroShockBlast.onFinish
function sc__HeroShockBlast_onFinish takes integer this returns boolean
        return true
endfunction

//Generated method caller for HeroShockBlast.onHit
function sc__HeroShockBlast_onHit takes integer this,unit hit returns boolean
    set f__arg_this=this
    set f__arg_unit1=hit
    call TriggerEvaluate(st__Missiles__MissileEvents_onHit[103])
 return f__result_boolean
endfunction

//Generated method caller for HeroShockBlast.onDestructable
function sc__HeroShockBlast_onDestructable takes integer this,destructable dest returns boolean
    set f__arg_this=this
    set f__arg_destructable1=dest
    call TriggerEvaluate(st__Missiles__MissileEvents_onDestructable[103])
 return f__result_boolean
endfunction

//Generated method caller for HeroShockBlast.onTerrain
function sc__HeroShockBlast_onTerrain takes integer this returns boolean
        return true
endfunction

//Generated method caller for HeroShockBlast.onTileset
function sc__HeroShockBlast_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
endfunction

//Generated allocator of HeroShockBlast
function s__HeroShockBlast__allocate takes real x ,real y ,real z ,real toX ,real toY ,real toZ returns integer
 local integer this=sc__Missiles_create(x,y,z,toX,toY,toZ)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__Missiles__MissileEvents_type[this]=103
    set kthis=this

 return this
endfunction


//Generated method caller for InteractAction.updateAbilityDetails
function sc__InteractAction_updateAbilityDetails takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroActionBase_updateAbilityDetails[104])
endfunction

//Generated method caller for InteractAction.onStart
function sc__InteractAction_onStart takes integer this returns nothing
        //TODO: Play a sound
endfunction

//Generated method caller for InteractAction.onActionPoint
function sc__InteractAction_onActionPoint takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__MetroidvaniaController__ActionInterface_onActionPoint[104])
endfunction

//Generated method caller for InteractAction.abilityText
function sc__InteractAction_abilityText takes integer this returns string
        return "Open or closes nearby smaller doors and interact with computers connected with cables."
endfunction

//Generated method caller for InteractAction.abilityName
function sc__InteractAction_abilityName takes integer this returns string
        return "[F] Interact"
endfunction

//Generated allocator of InteractAction
function s__InteractAction__allocate takes unit u ,integer uiIndex ,string iconPath returns integer
 local integer this=sc__HeroActionBase_create(u,uiIndex,iconPath)
 local integer kthis
    if(this==0) then
        return 0
    endif
    set si__MetroidvaniaController__ActionInterface_type[this]=104
    set kthis=this

 return this
endfunction

function sc___prototype1_execute takes integer i returns nothing

    call TriggerExecute(st___prototype1[i])
endfunction
function sc___prototype1_evaluate takes integer i returns nothing

    call TriggerEvaluate(st___prototype1[i])

endfunction
function sc___prototype2_execute takes integer i,trigger a1,string a2,limitop a3,real a4 returns nothing
    set f__arg_trigger1=a1
    set f__arg_string1=a2
    set f__arg_limitop1=a3
    set f__arg_real1=a4

    call TriggerExecute(st___prototype2[i])
endfunction
function sc___prototype2_evaluate takes integer i,trigger a1,string a2,limitop a3,real a4 returns nothing
    set f__arg_trigger1=a1
    set f__arg_string1=a2
    set f__arg_limitop1=a3
    set f__arg_real1=a4

    call TriggerEvaluate(st___prototype2[i])

endfunction
function sc___prototype9_execute takes integer i,unit a1,integer a2 returns nothing
    set f__arg_unit1=a1
    set f__arg_integer1=a2

    call TriggerExecute(st___prototype9[i])
endfunction
function sc___prototype9_evaluate takes integer i,unit a1,integer a2 returns nothing
    set f__arg_unit1=a1
    set f__arg_integer1=a2

    call TriggerEvaluate(st___prototype9[i])

endfunction
function h__TriggerRegisterVariableEvent takes trigger a0, string a1, limitop a2, real a3 returns event
    //hook: DamageEngine_RegisterFromHook
    call sc___prototype2_evaluate(1,a0,a1,a2,a3)
return TriggerRegisterVariableEvent(a0,a1,a2,a3)
endfunction

//library Alloc:

//library Alloc ends
//library DamageEngine:


//GUI Vars:

   
    //Map-makers should comment-out any booleans they will never need to check for.
    function s__DamageTrigger_checkConfiguration takes integer this returns boolean
        if s__DamageTrigger_userType[this] != 0 and udg_DamageEventType != s__DamageTrigger_userType[this] then
        elseif s__DamageTrigger_source[this] != null and s__DamageTrigger_source[this] != udg_DamageEventSource then
        elseif s__DamageTrigger_target[this] != null and s__DamageTrigger_target[this] != udg_DamageEventTarget then
        elseif s__DamageTrigger_attackType[this] >= 0 and s__DamageTrigger_attackType[this] != udg_DamageEventAttackT then
        elseif s__DamageTrigger_damageType[this] >= 0 and s__DamageTrigger_damageType[this] != udg_DamageEventDamageT then
        elseif s__DamageTrigger_sourceType[this] != 0 and GetUnitTypeId(udg_DamageEventSource) != s__DamageTrigger_sourceType[this] then
        elseif s__DamageTrigger_targetType[this] != 0 and GetUnitTypeId(udg_DamageEventTarget) != s__DamageTrigger_targetType[this] then
        elseif s__DamageTrigger_sourceBuff[this] != 0 and GetUnitAbilityLevel(udg_DamageEventSource, s__DamageTrigger_sourceBuff[this]) == 0 then
        elseif s__DamageTrigger_targetBuff[this] != 0 and GetUnitAbilityLevel(udg_DamageEventTarget, s__DamageTrigger_targetBuff[this]) == 0 then
        elseif udg_DamageEventAmount > s__DamageTrigger_damageMin[this] then
            return true
        endif
        return false
    endfunction
   
    //The below variables are constant
    //The below variables are private
    function s__DamageTrigger_configure takes integer this returns nothing
        set s__DamageTrigger_attackType[this]=udg_DamageFilterAttackT
        set s__DamageTrigger_damageType[this]=udg_DamageFilterDamageT
        set s__DamageTrigger_source[this]=udg_DamageFilterSource
        set s__DamageTrigger_target[this]=udg_DamageFilterTarget
        set s__DamageTrigger_sourceType[this]=udg_DamageFilterSourceT
        set s__DamageTrigger_targetType[this]=udg_DamageFilterTargetT
        set s__DamageTrigger_sourceBuff[this]=udg_DamageFilterSourceB
        set s__DamageTrigger_targetBuff[this]=udg_DamageFilterTargetB
        set s__DamageTrigger_userType[this]=udg_DamageFilterType
        set s__DamageTrigger_damageMin[this]=udg_DamageFilterMinAmount
 
        set udg_DamageFilterAttackT=- 1
        set udg_DamageFilterDamageT=- 1
        set udg_DamageFilterSource=null
        set udg_DamageFilterTarget=null
        set udg_DamageFilterSourceT=0
        set udg_DamageFilterTargetT=0
        set udg_DamageFilterType=0
        set udg_DamageFilterSourceB=0
        set udg_DamageFilterTargetB=0
        set udg_DamageFilterMinAmount=0.00
 
        set s__DamageTrigger_configured[this]=true
    endfunction
    function s__DamageTrigger_setGUIFromStruct takes boolean full returns nothing
        set udg_DamageEventAmount=s__Damage_damage[s__Damage_index]
        set udg_DamageEventAttackT=GetHandleId(s__Damage_attackType[s__Damage_index])
        set udg_DamageEventDamageT=GetHandleId(s__Damage_damageType[s__Damage_index])
        set udg_DamageEventWeaponT=GetHandleId(s__Damage_weaponType[s__Damage_index])
        set udg_DamageEventType=s__Damage_userType[s__Damage_index]

        set udg_DamageEventArmorPierced=s__Damage_armorPierced[s__Damage_index]
        set udg_DamageEventArmorT=s__Damage_armorType[s__Damage_index]
        set udg_DamageEventDefenseT=s__Damage_defenseType[s__Damage_index]

        if full then
            set udg_DamageEventSource=s__Damage_sourceUnit[s__Damage_index]
            set udg_DamageEventTarget=s__Damage_targetUnit[s__Damage_index]
            set udg_DamageEventPrevAmt=s__Damage_prevAmt[s__Damage_index]
            set udg_IsDamageAttack=s__Damage_isAttack[s__Damage_index]
            set udg_IsDamageCode=s__Damage_isCode[s__Damage_index]
            set udg_IsDamageSpell=s__Damage_isSpell[s__Damage_index]

            set udg_IsDamageMelee=s__Damage_isMelee[s__Damage_index]
            set udg_IsDamageRanged=s__Damage_isRanged[s__Damage_index]

        endif
    endfunction
    function s__DamageTrigger_setStructFromGUI takes nothing returns nothing
        set s__Damage_damage[s__Damage_index]=udg_DamageEventAmount
        set s__Damage_attackType[s__Damage_index]=ConvertAttackType(udg_DamageEventAttackT)
        set s__Damage_damageType[s__Damage_index]=ConvertDamageType(udg_DamageEventDamageT)
        set s__Damage_weaponType[s__Damage_index]=ConvertWeaponType(udg_DamageEventWeaponT)
        set s__Damage_userType[s__Damage_index]=udg_DamageEventType

        set s__Damage_armorPierced[s__Damage_index]=udg_DamageEventArmorPierced
        set s__Damage_armorType[s__Damage_index]=udg_DamageEventArmorT
        set s__Damage_defenseType[s__Damage_index]=udg_DamageEventDefenseT

    endfunction
    function s__DamageTrigger_getVerboseStr takes string eventName returns string
        if eventName == "Modifier" or eventName == "Mod" then
            return "udg_DamageModifierEvent"
        endif
        return "udg_" + eventName + "DamageEvent"
    endfunction
    function s__DamageTrigger_getStrIndex takes string var,real lbs returns integer
        local integer root= R2I(lbs)
        if var == "udg_DamageModifierEvent" then
            if root >= 4 then
                set root=s__DamageTrigger_SHIELD //4.00 or higher
            else
                set root=s__DamageTrigger_MOD //Less than 4.00
            endif
        elseif var == "udg_DamageEvent" then
            if root == 2 or root == 0 then
                set root=s__DamageTrigger_ZERO
            else
                set root=s__DamageTrigger_DAMAGE //Above 0.00 but less than 2.00, generally would just be 1.00
            endif
        elseif var == "udg_AfterDamageEvent" then
            set root=s__DamageTrigger_AFTER
        elseif var == "udg_LethalDamageEvent" then
            set root=s__DamageTrigger_LETHAL
        elseif var == "udg_AOEDamageEvent" then
            set root=s__DamageTrigger_AOE
        else
            set root=0
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_GDD()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_PDD()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_REG_PLUGIN_05()
        endif
        return root
    endfunction
    function s__DamageTrigger_toggleAllFilters takes integer this,boolean flag returns nothing
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_ATTACK]=flag
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_MELEE]=flag
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_OTHER]=flag
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_RANGED]=flag
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_SPELL]=flag
        set s__DamageTrigger_filters[this + DamageEngine_FILTER_CODE]=flag
    endfunction
    function s__DamageTrigger__set_filter takes integer this,integer f returns nothing
        set this=this * DamageEngine_FILTER_MAX
        if f == DamageEngine_FILTER_OTHER then
            call s__DamageTrigger_toggleAllFilters(this,true)
        else
            if f == DamageEngine_FILTER_ATTACK then
                set s__DamageTrigger_filters[this + DamageEngine_FILTER_ATTACK]=true
                set s__DamageTrigger_filters[this + DamageEngine_FILTER_MELEE]=true
                set s__DamageTrigger_filters[this + DamageEngine_FILTER_RANGED]=true
            else
                set s__DamageTrigger_filters[this + f]=true
            endif
        endif
    endfunction
    function s__DamageTrigger_registerVerbose takes trigger whichTrig,string var,real lbs,boolean GUI,integer filt returns integer
        local integer index= s__DamageTrigger_getStrIndex(var , lbs)
        local integer i= 0
        local integer id= 0
 
        if index == 0 then
            return 0
        elseif s__DamageTrigger_rootTrig[s__DamageTrigger_lastRegistered] == whichTrig and s__DamageTrigger_usingGUI[s__DamageTrigger_lastRegistered] then
            set s__DamageTrigger_filters[s__DamageTrigger_lastRegistered * DamageEngine_FILTER_MAX + filt]=true //allows GUI to register multiple different types of Damage filters to the same trigger
            return 0
        endif
 
        if not DamageEngine__hasLethal and index == s__DamageTrigger_LETHAL then
            set DamageEngine__hasLethal=true
        endif
        if s__DamageTrigger_trigIndexStack[0] == 0 then
            set s__DamageTrigger_count=s__DamageTrigger_count + 1 //List runs from index 10 and up
            set id=s__DamageTrigger_count
        else
            set id=s__DamageTrigger_trigIndexStack[0]
            set s__DamageTrigger_trigIndexStack[0]=s__DamageTrigger_trigIndexStack[id]
        endif
        set s__DamageTrigger_lastRegistered=id
        call s__DamageTrigger__set_filter(id,filt)
        set s__DamageTrigger_rootTrig[id]=whichTrig
        set s__DamageTrigger_usingGUI[id]=GUI
        set s__DamageTrigger_weight[id]=lbs
        set s__DamageTrigger_eventStr[id]=var
       
        //Next 2 lines added to fix a bug when using manual vJass configuration,
        //discovered and solved by lolreported
        set s__DamageTrigger_attackType[id]=- 1
        set s__DamageTrigger_damageType[id]=- 1
 
        loop
            set i=s__DamageTrigger_next[index]
            exitwhen i == 0 or lbs < s__DamageTrigger_weight[i]
            set index=i
        endloop
        set s__DamageTrigger_next[index]=id
        set s__DamageTrigger_next[id]=i
 
        //call BJDebugMsg("Registered " + I2S(id) + " to " + I2S(index) + " and before " + I2S(i))
        return s__DamageTrigger_lastRegistered
    endfunction
    function s__DamageTrigger_registerTrigger takes trigger t,string var,real lbs returns integer
        return s__DamageTrigger_registerVerbose(t , s__DamageTrigger_getVerboseStr(var) , lbs , false , DamageEngine_FILTER_OTHER)
    endfunction
    function s__DamageTrigger_getIndex takes trigger t,string eventName,real lbs returns integer
        local integer index= s__DamageTrigger_getStrIndex(s__DamageTrigger_getVerboseStr(eventName) , lbs)
        loop
            set s__DamageTrigger_prev=index
            set index=s__DamageTrigger_next[index]
            exitwhen index == 0 or s__DamageTrigger_rootTrig[index] == t
        endloop
        return index
    endfunction
    function s__DamageTrigger_unregister takes trigger t,string eventName,real lbs,boolean reset returns boolean
        local integer index= s__DamageTrigger_getIndex(t , eventName , lbs)
        if index == 0 then
            return false
        endif
        set s__DamageTrigger_next[s__DamageTrigger_prev]=s__DamageTrigger_next[index]
     
        set s__DamageTrigger_trigIndexStack[index]=s__DamageTrigger_trigIndexStack[0]
        set s__DamageTrigger_trigIndexStack[0]=index
 
        if reset then
            call s__DamageTrigger_configure(index)
            set s__DamageTrigger_configured[index]=false
            set index=index * DamageEngine_FILTER_MAX
            call s__DamageTrigger_toggleAllFilters(index,false)
        endif
        return true
    endfunction
    function s__DamageTrigger_DamageEngine__run takes integer this returns nothing
        local integer cat= this
        local integer d= s__Damage_index

        local boolean structUnset= false
        local boolean guiUnset= false
        local boolean mod= cat <= s__DamageTrigger_DAMAGE

        if DamageEngine__dreaming then
            return
        endif
        set DamageEngine__dreaming=true
        call DisableTrigger(DamageEngine__t1)
        call DisableTrigger(DamageEngine__t2)
        call EnableTrigger(DamageEngine__t3)
        //call BJDebugMsg("Start of event running")
        loop
            set this=s__DamageTrigger_next[this]
            exitwhen this == 0
            exitwhen cat == s__DamageTrigger_MOD and ( udg_DamageEventOverride or udg_DamageEventType == DamageEngine_TYPE_PURE )
            exitwhen cat == s__DamageTrigger_SHIELD and udg_DamageEventAmount <= 0.00

            exitwhen cat == s__DamageTrigger_LETHAL and udg_LethalDamageHP > DamageEngine__DEATH_VAL

         
            set s__DamageTrigger_eventIndex=this
            if not s__DamageTrigger_DamageEngine__trigFrozen[this] and s__DamageTrigger_filters[this * DamageEngine_FILTER_MAX + s__Damage_eFilter[d]] and IsTriggerEnabled(s__DamageTrigger_rootTrig[this]) and ( not s__DamageTrigger_configured[this] or s__DamageTrigger_checkConfiguration(this) ) then

                if mod then
                    if s__DamageTrigger_usingGUI[this] then
                        if guiUnset then
                            set guiUnset=false
                            call s__DamageTrigger_setGUIFromStruct(false)
                        endif
//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_PDD()
                    elseif structUnset then
                        set structUnset=false
                        call s__DamageTrigger_setStructFromGUI()
                    endif
                endif

//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_FILTER_PLUGIN_05()
               
                //JASS users who do not use actions can modify the below block to just evaluate.
                //It should not make any perceptable difference in terms of performance.
                if TriggerEvaluate(s__DamageTrigger_rootTrig[this]) then
                    call TriggerExecute(s__DamageTrigger_rootTrig[this])
                endif
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_05()

                if mod then
                    if s__DamageTrigger_usingGUI[this] then
//ignored textmacro command: DAMAGE_EVENT_MOD_PLUGIN_PDD()
                        if cat != s__DamageTrigger_MOD then
                            set s__Damage_damage[d]=udg_DamageEventAmount
                        else
                            set structUnset=true
                        endif
                    elseif cat != s__DamageTrigger_MOD then
                        set udg_DamageEventAmount=s__Damage_damage[d]
                    else
                        set guiUnset=true
                    endif
                endif

            endif
        endloop

        if structUnset then
            call s__DamageTrigger_setStructFromGUI()
        endif
        if guiUnset then
            call s__DamageTrigger_setGUIFromStruct(false)
        endif



        //call BJDebugMsg("End of event running")
        call DisableTrigger(DamageEngine__t3)
        call EnableTrigger(DamageEngine__t1)
        call EnableTrigger(DamageEngine__t2)
        set DamageEngine__dreaming=false
    endfunction
    function s__DamageTrigger__staticgetindex takes code c returns trigger
        local integer i= 0
        local boolexpr b= Filter(c)
        loop
            if i == s__DamageTrigger_autoN then
                set s__DamageTrigger_autoTriggers[i]=CreateTrigger()
                set s__DamageTrigger_autoFuncs[i]=b
                call TriggerAddCondition(s__DamageTrigger_autoTriggers[i], b)
                exitwhen true
            endif
            set i=i + 1
            exitwhen b == s__DamageTrigger_autoFuncs[i]
        endloop
        return s__DamageTrigger_autoTriggers[i]
    endfunction
//ignored textmacro command: DAMAGE_EVENT_USER_STRUCT_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_USER_STRUCT_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_USER_STRUCT_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_USER_STRUCT_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_USER_STRUCT_PLUGIN_05()


   


    function s__Damage__get_source takes nothing returns unit
        return udg_DamageEventSource
    endfunction
    function s__Damage__get_target takes nothing returns unit
        return udg_DamageEventTarget
    endfunction
    function s__Damage__get_amount takes nothing returns real
        return s__Damage_damage[s__Damage_index]
    endfunction
    function s__Damage__set_amount takes real r returns nothing
        set s__Damage_damage[s__Damage_index]=r
    endfunction
   

    function s__Damage_setArmor takes integer this,boolean reset returns nothing
        local real pierce
        local integer at
        local integer dt
        if reset then
            set pierce=udg_DamageEventArmorPierced
            set at=s__Damage_prevArmorT[s__Damage_index]
            set dt=s__Damage_prevDefenseT[s__Damage_index]
            set udg_DamageEventArmorPierced=0.00
            set s__Damage_armorPierced[this]=0.00
        else
            set pierce=- udg_DamageEventArmorPierced
            set at=udg_DamageEventArmorT
            set dt=udg_DamageEventDefenseT
        endif
        if pierce != 0.00 then
            call BlzSetUnitArmor(udg_DamageEventTarget, BlzGetUnitArmor(udg_DamageEventTarget) + pierce)
        endif
        if s__Damage_prevArmorT[s__Damage_index] != udg_DamageEventArmorT then
            call BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_ARMOR_TYPE, at)
        endif
        if s__Damage_prevDefenseT[s__Damage_index] != udg_DamageEventDefenseT then
            call BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_DEFENSE_TYPE, dt)
        endif
    endfunction


    function s__Damage_onAOEEnd takes nothing returns nothing
        if udg_DamageEventAOE > 1 then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_AOE)
        endif
        set udg_DamageEventAOE=0
        set udg_DamageEventLevel=0
        set udg_EnhancedDamageTarget=null
        set udg_AOEDamageSource=null
        call GroupClear(udg_DamageEventAOEGroup)
    endfunction

   
    function s__Damage_afterDamage takes nothing returns nothing
        if udg_DamageEventPrevAmt != 0.00 and udg_DamageEventDamageT != 0 then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_AFTER)
            set udg_DamageEventDamageT=0
            set udg_DamageEventPrevAmt=0.00
        endif
    endfunction
    function s__Damage_doPreEvents takes integer this,boolean natural returns boolean

        set s__Damage_armorType[this]=BlzGetUnitIntegerField(s__Damage_targetUnit[this], UNIT_IF_ARMOR_TYPE)
        set s__Damage_defenseType[this]=BlzGetUnitIntegerField(s__Damage_targetUnit[this], UNIT_IF_DEFENSE_TYPE)
        set s__Damage_prevArmorT[this]=s__Damage_armorType[this]
        set s__Damage_prevDefenseT[this]=s__Damage_defenseType[this]
        set s__Damage_armorPierced[this]=0.00

        set s__Damage_index=this
        call s__DamageTrigger_setGUIFromStruct(true)
       
        call GroupAddUnit(DamageEngine__proclusGlobal, udg_DamageEventSource)
        call GroupAddUnit(DamageEngine__fischerMorrow, udg_DamageEventTarget)
//ignored textmacro command: DAMAGE_EVENT_PRE_VARS_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_PRE_VARS_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_PRE_VARS_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_PRE_VARS_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_PRE_VARS_PLUGIN_05()
        if udg_DamageEventAmount != 0.00 then
            set udg_DamageEventOverride=udg_DamageEventDamageT == 0
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_MOD)



            if natural then
                call BlzSetEventAttackType(s__Damage_attackType[this])
                call BlzSetEventDamageType(s__Damage_damageType[this])
                call BlzSetEventWeaponType(s__Damage_weaponType[this])
                call BlzSetEventDamage(udg_DamageEventAmount)
            endif

            call s__Damage_setArmor(this,false)

            return false
        endif
        return true
    endfunction
    function s__Damage_unfreeze takes nothing returns nothing
        local integer i= s__Damage_damageStack
        loop
            exitwhen i == 0
            set i=i - 1
            set s__DamageTrigger_DamageEngine__trigFrozen[s__Damage_recursiveTrig[s__Damage_stackRef[i]]]=false
            set s__DamageTrigger_DamageEngine__levelsDeep[s__Damage_recursiveTrig[s__Damage_stackRef[i]]]=0
        endloop
        call EnableTrigger(DamageEngine__t1)
        call EnableTrigger(DamageEngine__t2)
        set DamageEngine__kicking=false
        set s__Damage_damageStack=0
        set s__Damage_prepped=0
        set DamageEngine__dreaming=false
        set DamageEngine__sleepLevel=0
        call GroupClear(DamageEngine__proclusGlobal)
        call GroupClear(DamageEngine__fischerMorrow)
        //call BJDebugMsg("Cleared up the groups")
    endfunction
    function s__Damage_finish takes nothing returns nothing
        local integer i= 0
        local integer exit
        if DamageEngine__eventsRun then
            set DamageEngine__eventsRun=false
            call s__Damage_afterDamage()
        endif
        if DamageEngine__canKick and not DamageEngine__kicking then
            if s__Damage_damageStack != 0 then
                set DamageEngine__kicking=true
                loop
                    set DamageEngine__sleepLevel=DamageEngine__sleepLevel + 1
                    set exit=s__Damage_damageStack
                    loop
                        set s__Damage_prepped=s__Damage_stackRef[i]
                        if UnitAlive(s__Damage_targetUnit[s__Damage_prepped]) then //Added just in case dead units had issues.
                            call s__Damage_doPreEvents(s__Damage_prepped,false) //don't evaluate the pre-event
                            if s__Damage_damage[s__Damage_prepped] > 0.00 then
                                call DisableTrigger(DamageEngine__t1) //Force only the after armor event to run.
                                call EnableTrigger(DamageEngine__t2) //in case the user forgot to re-enable this
                                set DamageEngine__totem=true
                                call UnitDamageTarget(s__Damage_sourceUnit[s__Damage_prepped], s__Damage_targetUnit[s__Damage_prepped], s__Damage_damage[s__Damage_prepped], s__Damage_isAttack[s__Damage_prepped], s__Damage_isRanged[s__Damage_prepped], s__Damage_attackType[s__Damage_prepped], s__Damage_damageType[s__Damage_prepped], s__Damage_weaponType[s__Damage_prepped])
                            else
                                //No new events run at all in this case
                                if udg_DamageEventDamageT != 0 then
                                    call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_DAMAGE)
                                endif
                                if s__Damage_damage[s__Damage_prepped] < 0.00 then
                                    //No need for BlzSetEventDamage here
                                    call SetWidgetLife(s__Damage_targetUnit[s__Damage_prepped], GetWidgetLife(s__Damage_targetUnit[s__Damage_prepped]) - s__Damage_damage[s__Damage_prepped])
                                endif

                                call s__Damage_setArmor(s__Damage_prepped,true)

                            endif
                            call s__Damage_afterDamage()
                        endif
                        set i=i + 1
                        exitwhen i == exit
                    endloop
                    exitwhen i == s__Damage_damageStack
                endloop
            endif
            call s__Damage_unfreeze()
        endif
    endfunction
    function s__Damage_failsafeClear takes nothing returns nothing

        call s__Damage_setArmor(s__Damage_index,true)

        set DamageEngine__canKick=true
        set DamageEngine__kicking=false
        set DamageEngine__totem=false
        if udg_DamageEventDamageT != 0 then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_DAMAGE)
            set DamageEngine__eventsRun=true
        endif
        call s__Damage_finish()
    endfunction
    function s__Damage__set_enabled takes boolean b returns nothing
        if b then
            if DamageEngine__dreaming then
                call EnableTrigger(DamageEngine__t3)
            else
                call EnableTrigger(DamageEngine__t1)
                call EnableTrigger(DamageEngine__t2)
            endif
        else
            if DamageEngine__dreaming then
                call DisableTrigger(DamageEngine__t3)
            else
                call DisableTrigger(DamageEngine__t1)
                call DisableTrigger(DamageEngine__t2)
            endif
        endif
    endfunction
    function s__Damage__get_enabled takes nothing returns boolean
        return IsTriggerEnabled(DamageEngine__t1)
    endfunction
   
   
    function s__Damage_getOutOfBed takes nothing returns nothing
        if DamageEngine__totem then
            call s__Damage_failsafeClear() //WarCraft 3 didn't run the DAMAGED event despite running the DAMAGING event.
        else
            set DamageEngine__canKick=true
            set DamageEngine__kicking=false
            call s__Damage_finish()
        endif

        call s__Damage_onAOEEnd()

        set s__Damage_arisen=true
    endfunction
   
    function s__Damage_wakeUp takes nothing returns nothing
        set DamageEngine__dreaming=false
        call s__Damage__set_enabled(true)
        call ForForce(bj_FORCE_PLAYER[0], function s__Damage_getOutOfBed) //Moved to a new thread in case of a thread crash
        if not s__Damage_arisen then
            //call BJDebugMsg("DamageEngine issue: thread crashed!")
            call s__Damage_unfreeze()
        else
            set s__Damage_arisen=false
        endif
        set s__Damage_count=0
        set s__Damage_index=0
        set DamageEngine__alarmSet=false
        //call BJDebugMsg("Timer wrapped up")
    endfunction
    function s__Damage_addRecursive takes integer this returns nothing
        if s__Damage_damage[this] != 0.00 then
            set s__Damage_recursiveTrig[this]=s__DamageTrigger_eventIndex
            if not s__Damage_isCode[this] then
                set s__Damage_isCode[this]=true
                set s__Damage_userType[this]=DamageEngine_TYPE_CODE
            endif
            set DamageEngine_inception=DamageEngine_inception or s__DamageTrigger_DamageEngine__inceptionTrig[s__DamageTrigger_eventIndex]
            if DamageEngine__kicking and IsUnitInGroup(s__Damage_sourceUnit[this], DamageEngine__proclusGlobal) and IsUnitInGroup(s__Damage_targetUnit[this], DamageEngine__fischerMorrow) then
                if not DamageEngine_inception then
                    set s__DamageTrigger_DamageEngine__trigFrozen[s__DamageTrigger_eventIndex]=true
                elseif not s__DamageTrigger_DamageEngine__trigFrozen[s__DamageTrigger_eventIndex] then
                    set s__DamageTrigger_DamageEngine__inceptionTrig[s__DamageTrigger_eventIndex]=true
                    if s__DamageTrigger_DamageEngine__levelsDeep[s__DamageTrigger_eventIndex] < DamageEngine__sleepLevel then
                        set s__DamageTrigger_DamageEngine__levelsDeep[s__DamageTrigger_eventIndex]=s__DamageTrigger_DamageEngine__levelsDeep[s__DamageTrigger_eventIndex] + 1
                        if s__DamageTrigger_DamageEngine__levelsDeep[s__DamageTrigger_eventIndex] >= DamageEngine__LIMBO then
                            set s__DamageTrigger_DamageEngine__trigFrozen[s__DamageTrigger_eventIndex]=true
                        endif
                    endif
                endif
            endif
            set s__Damage_stackRef[s__Damage_damageStack]=this
            set s__Damage_damageStack=s__Damage_damageStack + 1
            //call BJDebugMsg("damageStack: " + I2S(damageStack) + " levelsDeep: " + I2S(DamageTrigger.eventIndex.levelsDeep) + " sleepLevel: " + I2S(sleepLevel))
        endif
        set DamageEngine_inception=false
    endfunction
    function s__Damage_clearNexts takes nothing returns nothing
        set udg_NextDamageIsAttack=false
        set udg_NextDamageType=0
        set udg_NextDamageWeaponT=0

        set udg_NextDamageIsMelee=false
        set udg_NextDamageIsRanged=false

    endfunction
    function s__Damage_create takes unit src,unit tgt,real amt,boolean a,attacktype at,damagetype dt,weapontype wt returns integer
        local integer d= s__Damage_count + 1
        set s__Damage_count=d
        set s__Damage_sourceUnit[d]=src
        set s__Damage_targetUnit[d]=tgt
        set s__Damage_damage[d]=amt
        set s__Damage_prevAmt[d]=amt
                     
        set s__Damage_attackType[d]=at
        set s__Damage_damageType[d]=dt
        set s__Damage_weaponType[d]=wt
                     
        set s__Damage_isAttack[d]=udg_NextDamageIsAttack or a
        set s__Damage_isSpell[d]=s__Damage_attackType[d] == null and not s__Damage_isAttack[d]
        return d
    endfunction
    function s__Damage_createFromEvent takes nothing returns integer
        local integer d= s__Damage_create(GetEventDamageSource() , GetTriggerUnit() , GetEventDamage() , BlzGetEventDamageType() == DAMAGE_TYPE_NORMAL , BlzGetEventAttackType() , BlzGetEventDamageType() , BlzGetEventWeaponType())
        set s__Damage_isCode[d]=udg_NextDamageType != 0 or udg_NextDamageIsAttack or udg_NextDamageIsRanged or udg_NextDamageIsMelee or s__Damage_damageType[d] == DAMAGE_TYPE_MIND or udg_NextDamageWeaponT != 0 or ( s__Damage_damage[d] != 0.00 and s__Damage_damageType[d] == DAMAGE_TYPE_UNKNOWN )
 
        if s__Damage_isCode[d] then
            if udg_NextDamageType != 0 then
                set s__Damage_userType[d]=udg_NextDamageType
            else
                set s__Damage_userType[d]=DamageEngine_TYPE_CODE
            endif

            set s__Damage_isMelee[d]=udg_NextDamageIsMelee
            set s__Damage_isRanged[d]=udg_NextDamageIsRanged

            set s__Damage_eFilter[d]=DamageEngine_FILTER_CODE
            if udg_NextDamageWeaponT != 0 then
                set s__Damage_weaponType[d]=ConvertWeaponType(udg_NextDamageWeaponT)
                set udg_NextDamageWeaponT=0
            endif
        else
            set s__Damage_userType[d]=0
            if s__Damage_damageType[d] == DAMAGE_TYPE_NORMAL and s__Damage_isAttack[d] then

                set s__Damage_isMelee[d]=IsUnitType(s__Damage_sourceUnit[d], UNIT_TYPE_MELEE_ATTACKER)
                set s__Damage_isRanged[d]=IsUnitType(s__Damage_sourceUnit[d], UNIT_TYPE_RANGED_ATTACKER)
                if s__Damage_isMelee[d] and s__Damage_isRanged[d] then
                    set s__Damage_isMelee[d]=s__Damage_weaponType[d] != null // Melee units play a sound when damaging
                    set s__Damage_isRanged[d]=not s__Damage_isMelee[d] // In the case where a unit is both ranged and melee, the ranged attack plays no sound.
                endif
                if s__Damage_isMelee[d] then
                    set s__Damage_eFilter[d]=DamageEngine_FILTER_MELEE
                elseif s__Damage_isRanged[d] then
                    set s__Damage_eFilter[d]=DamageEngine_FILTER_RANGED
                else
                    set s__Damage_eFilter[d]=DamageEngine_FILTER_ATTACK
                endif



            else
                if s__Damage_isSpell[d] then
                    set s__Damage_eFilter[d]=DamageEngine_FILTER_SPELL
                else
                    set s__Damage_eFilter[d]=DamageEngine_FILTER_OTHER
                endif

                set s__Damage_isMelee[d]=false
                set s__Damage_isRanged[d]=false

            endif
        endif
        call s__Damage_clearNexts()
        return d
    endfunction
    function s__Damage_onRecursion takes nothing returns boolean
        local integer d= s__Damage_createFromEvent()
        call s__Damage_addRecursive(d)
        call BlzSetEventDamage(0.00)
        return false
    endfunction
    function s__Damage_onDamaging takes nothing returns boolean
        local integer d= s__Damage_createFromEvent()
        //call BJDebugMsg("Pre-damage event running for " + GetUnitName(GetTriggerUnit()))
        if DamageEngine__alarmSet then
            if DamageEngine__totem then //WarCraft 3 didn't run the DAMAGED event despite running the DAMAGING event.
                if s__Damage_damageType[d] == DAMAGE_TYPE_SPIRIT_LINK or s__Damage_damageType[d] == DAMAGE_TYPE_DEFENSIVE or s__Damage_damageType[d] == DAMAGE_TYPE_PLANT then
                    set DamageEngine__totem=false
                    set DamageEngine__lastInstance=s__Damage_index
                    set DamageEngine__canKick=false
                else
                    call s__Damage_failsafeClear() //Not an overlapping event - just wrap it up
                endif
            else
                call s__Damage_finish() //wrap up any previous damage index
            endif
           

            if s__Damage_sourceUnit[d] != udg_AOEDamageSource then
                call s__Damage_onAOEEnd()
                set udg_AOEDamageSource=s__Damage_sourceUnit[d]
            elseif s__Damage_targetUnit[d] == udg_EnhancedDamageTarget then
                set udg_DamageEventLevel=udg_DamageEventLevel + 1
            elseif not IsUnitInGroup(s__Damage_targetUnit[d], udg_DamageEventAOEGroup) then
                set udg_DamageEventAOE=udg_DamageEventAOE + 1
            endif

        else
            call TimerStart(DamageEngine__alarm, 0.00, false, function s__Damage_wakeUp)
            set DamageEngine__alarmSet=true

            set udg_AOEDamageSource=s__Damage_sourceUnit[d]
            set udg_EnhancedDamageTarget=s__Damage_targetUnit[d]

        endif

        call GroupAddUnit(udg_DamageEventAOEGroup, s__Damage_targetUnit[d])

        if s__Damage_doPreEvents(d,true) then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_ZERO)
            set DamageEngine__canKick=true
            call s__Damage_finish()
        endif
        set DamageEngine__totem=DamageEngine__lastInstance == 0 or DamageEngine__attacksImmune[udg_DamageEventAttackT] or DamageEngine__damagesImmune[udg_DamageEventDamageT] or not IsUnitType(udg_DamageEventTarget, UNIT_TYPE_MAGIC_IMMUNE)
        return false
    endfunction
    function s__Damage_onDamaged takes nothing returns boolean
        local real r= GetEventDamage()
        local integer d= s__Damage_index
        //call BJDebugMsg("Second damage event running for " + GetUnitName(GetTriggerUnit()))
        if s__Damage_prepped > 0 then
            set s__Damage_prepped=0
        elseif DamageEngine__dreaming or s__Damage_prevAmt[d] == 0.00 then
            return false
        elseif DamageEngine__totem then
            set DamageEngine__totem=false
        else
            //This should only happen for stuff like Spirit Link or Thorns Aura/Carapace
            call s__Damage_afterDamage()
            set s__Damage_index=DamageEngine__lastInstance
            set DamageEngine__lastInstance=0
            set d=s__Damage_index
            set DamageEngine__canKick=true
            call s__DamageTrigger_setGUIFromStruct(true)
        endif

        call s__Damage_setArmor(d,true)

       

        if udg_DamageEventAmount != 0.00 and r != 0.00 then
            set udg_DamageScalingWC3=r / udg_DamageEventAmount
        elseif udg_DamageEventAmount > 0.00 then
            set udg_DamageScalingWC3=0.00
        else
            set udg_DamageScalingWC3=1.00
            if udg_DamageEventPrevAmt == 0.00 then
                set udg_DamageScalingUser=0.00
            else
                set udg_DamageScalingUser=udg_DamageEventAmount / udg_DamageEventPrevAmt
            endif
        endif

        set udg_DamageEventAmount=r
        set s__Damage_damage[d]=r
 
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_GDD()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_PDD()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_VARS_PLUGIN_05()
 
        if udg_DamageEventAmount > 0.00 then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_SHIELD)




            if DamageEngine__hasLethal or udg_DamageEventType < 0 then
                set udg_LethalDamageHP=GetWidgetLife(udg_DamageEventTarget) - udg_DamageEventAmount
                if udg_LethalDamageHP <= DamageEngine__DEATH_VAL then
                    if DamageEngine__hasLethal then
                        call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_LETHAL)
           
                        set udg_DamageEventAmount=GetWidgetLife(udg_DamageEventTarget) - udg_LethalDamageHP
                        set s__Damage_damage[d]=udg_DamageEventAmount
                    endif
                    if udg_DamageEventType < 0 and udg_LethalDamageHP <= DamageEngine__DEATH_VAL then
                        call SetUnitExploded(udg_DamageEventTarget, true)
                    endif
                endif
            endif


            if udg_DamageEventPrevAmt == 0.00 or udg_DamageScalingWC3 == 0.00 then
                set udg_DamageScalingUser=0.00
            else
                set udg_DamageScalingUser=udg_DamageEventAmount / udg_DamageEventPrevAmt / udg_DamageScalingWC3
            endif

        endif
        if udg_DamageEventDamageT != 0 then
            call s__DamageTrigger_DamageEngine__run(s__DamageTrigger_DAMAGE)
        endif
        call BlzSetEventDamage(udg_DamageEventAmount)
        set DamageEngine__eventsRun=true
        if udg_DamageEventAmount == 0.00 then
            call s__Damage_finish()
        endif
        return false
    endfunction
    function s__Damage_apply takes unit src,unit tgt,real amt,boolean a,boolean r,attacktype at,damagetype dt,weapontype wt returns integer
        local integer d
        if udg_NextDamageType == 0 then
           set udg_NextDamageType=DamageEngine_TYPE_CODE
        endif
        if DamageEngine__dreaming then
            set d=s__Damage_create(src , tgt , amt , a , at , dt , wt)
            set s__Damage_isCode[d]=true
            set s__Damage_eFilter[d]=DamageEngine_FILTER_CODE
                         
            set s__Damage_userType[d]=udg_NextDamageType

            if not s__Damage_isSpell[d] then
                set s__Damage_isRanged[d]=udg_NextDamageIsRanged or r
                set s__Damage_isMelee[d]=not s__Damage_isRanged[d]
            endif

            call s__Damage_addRecursive(d)
        else
            call UnitDamageTarget(src, tgt, amt, a, r, at, dt, wt)
            set d=s__Damage_index
            call s__Damage_finish()
        endif
        call s__Damage_clearNexts()
        return d
    endfunction
    function s__Damage_applySpell takes unit src,unit tgt,real amt,damagetype dt returns integer
        return s__Damage_apply(src , tgt , amt , false , false , null , dt , null)
    endfunction
    function s__Damage_applyAttack takes unit src,unit tgt,real amt,boolean ranged,attacktype at,weapontype wt returns integer
        return s__Damage_apply(src , tgt , amt , true , ranged , at , DAMAGE_TYPE_NORMAL , wt)
    endfunction
    //===========================================================================
    function s__Damage_onInit takes nothing returns nothing
        call TriggerRegisterAnyUnitEventBJ(DamageEngine__t1, EVENT_PLAYER_UNIT_DAMAGING)
        call TriggerAddCondition(DamageEngine__t1, Filter(function s__Damage_onDamaging))
 
        call TriggerRegisterAnyUnitEventBJ(DamageEngine__t2, EVENT_PLAYER_UNIT_DAMAGED)
        call TriggerAddCondition(DamageEngine__t2, Filter(function s__Damage_onDamaged))
 
        //For recursion
        call TriggerRegisterAnyUnitEventBJ(DamageEngine__t3, EVENT_PLAYER_UNIT_DAMAGING)
        call TriggerAddCondition(DamageEngine__t3, Filter(function s__Damage_onRecursion))
        call DisableTrigger(DamageEngine__t3)
 
        //For preventing Thorns/Defensive glitch.
        //Data gathered from https://www.hiveworkshop.com/threads/repo-in-progress-mapping-damage-types-to-their-abilities.316271/
        set DamageEngine__attacksImmune[0]=false //ATTACK_TYPE_NORMAL
        set DamageEngine__attacksImmune[1]=true //ATTACK_TYPE_MELEE  
        set DamageEngine__attacksImmune[2]=true //ATTACK_TYPE_PIERCE  
        set DamageEngine__attacksImmune[3]=true //ATTACK_TYPE_SIEGE  
        set DamageEngine__attacksImmune[4]=false //ATTACK_TYPE_MAGIC  
        set DamageEngine__attacksImmune[5]=true //ATTACK_TYPE_CHAOS  
        set DamageEngine__attacksImmune[6]=true //ATTACK_TYPE_HERO    
 
        set DamageEngine__damagesImmune[0]=true //DAMAGE_TYPE_UNKNOWN      
        set DamageEngine__damagesImmune[4]=true //DAMAGE_TYPE_NORMAL          
        set DamageEngine__damagesImmune[5]=true //DAMAGE_TYPE_ENHANCED        
        set DamageEngine__damagesImmune[8]=false //DAMAGE_TYPE_FIRE            
        set DamageEngine__damagesImmune[9]=false //DAMAGE_TYPE_COLD              
        set DamageEngine__damagesImmune[10]=false //DAMAGE_TYPE_LIGHTNING        
        set DamageEngine__damagesImmune[11]=true //DAMAGE_TYPE_POISON          
        set DamageEngine__damagesImmune[12]=true //DAMAGE_TYPE_DISEASE          
        set DamageEngine__damagesImmune[13]=false //DAMAGE_TYPE_DIVINE            
        set DamageEngine__damagesImmune[14]=false //DAMAGE_TYPE_MAGIC            
        set DamageEngine__damagesImmune[15]=false //DAMAGE_TYPE_SONIC            
        set DamageEngine__damagesImmune[16]=true //DAMAGE_TYPE_ACID            
        set DamageEngine__damagesImmune[17]=false //DAMAGE_TYPE_FORCE            
        set DamageEngine__damagesImmune[18]=false //DAMAGE_TYPE_DEATH            
        set DamageEngine__damagesImmune[19]=false //DAMAGE_TYPE_MIND              
        set DamageEngine__damagesImmune[20]=false //DAMAGE_TYPE_PLANT            
        set DamageEngine__damagesImmune[21]=false //DAMAGE_TYPE_DEFENSIVE        
        set DamageEngine__damagesImmune[22]=true //DAMAGE_TYPE_DEMOLITION      
        set DamageEngine__damagesImmune[23]=true //DAMAGE_TYPE_SLOW_POISON      
        set DamageEngine__damagesImmune[24]=false //DAMAGE_TYPE_SPIRIT_LINK      
        set DamageEngine__damagesImmune[25]=false //DAMAGE_TYPE_SHADOW_STRIKE    
        set DamageEngine__damagesImmune[26]=true //DAMAGE_TYPE_UNIVERSAL
    endfunction
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_DMGPKG()
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_01()
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_02()
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_03()
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_04()
//ignored textmacro command: DAMAGE_EVENT_STRUCT_PLUGIN_05()
    function DamageEngine_DebugStr takes nothing returns nothing
        local integer i= 0
        loop
            set udg_CONVERTED_ATTACK_TYPE[i]=ConvertAttackType(i)
            exitwhen i == 6
            set i=i + 1
        endloop
        set i=0
        loop
            set udg_CONVERTED_DAMAGE_TYPE[i]=ConvertDamageType(i)
            exitwhen i == 26
            set i=i + 1
        endloop
        set udg_AttackTypeDebugStr[0]="SPELLS" //ATTACK_TYPE_NORMAL in JASS
        set udg_AttackTypeDebugStr[1]="NORMAL" //ATTACK_TYPE_MELEE in JASS
        set udg_AttackTypeDebugStr[2]="PIERCE"
        set udg_AttackTypeDebugStr[3]="SIEGE"
        set udg_AttackTypeDebugStr[4]="MAGIC"
        set udg_AttackTypeDebugStr[5]="CHAOS"
        set udg_AttackTypeDebugStr[6]="HERO"
        set udg_DamageTypeDebugStr[0]="UNKNOWN"
        set udg_DamageTypeDebugStr[4]="NORMAL"
        set udg_DamageTypeDebugStr[5]="ENHANCED"
        set udg_DamageTypeDebugStr[8]="FIRE"
        set udg_DamageTypeDebugStr[9]="COLD"
        set udg_DamageTypeDebugStr[10]="LIGHTNING"
        set udg_DamageTypeDebugStr[11]="POISON"
        set udg_DamageTypeDebugStr[12]="DISEASE"
        set udg_DamageTypeDebugStr[13]="DIVINE"
        set udg_DamageTypeDebugStr[14]="MAGIC"
        set udg_DamageTypeDebugStr[15]="SONIC"
        set udg_DamageTypeDebugStr[16]="ACID"
        set udg_DamageTypeDebugStr[17]="FORCE"
        set udg_DamageTypeDebugStr[18]="DEATH"
        set udg_DamageTypeDebugStr[19]="MIND"
        set udg_DamageTypeDebugStr[20]="PLANT"
        set udg_DamageTypeDebugStr[21]="DEFENSIVE"
        set udg_DamageTypeDebugStr[22]="DEMOLITION"
        set udg_DamageTypeDebugStr[23]="SLOW_POISON"
        set udg_DamageTypeDebugStr[24]="SPIRIT_LINK"
        set udg_DamageTypeDebugStr[25]="SHADOW_STRIKE"
        set udg_DamageTypeDebugStr[26]="UNIVERSAL"
        set udg_WeaponTypeDebugStr[0]="NONE" //WEAPON_TYPE_WHOKNOWS in JASS
        set udg_WeaponTypeDebugStr[1]="METAL_LIGHT_CHOP"
        set udg_WeaponTypeDebugStr[2]="METAL_MEDIUM_CHOP"
        set udg_WeaponTypeDebugStr[3]="METAL_HEAVY_CHOP"
        set udg_WeaponTypeDebugStr[4]="METAL_LIGHT_SLICE"
        set udg_WeaponTypeDebugStr[5]="METAL_MEDIUM_SLICE"
        set udg_WeaponTypeDebugStr[6]="METAL_HEAVY_SLICE"
        set udg_WeaponTypeDebugStr[7]="METAL_MEDIUM_BASH"
        set udg_WeaponTypeDebugStr[8]="METAL_HEAVY_BASH"
        set udg_WeaponTypeDebugStr[9]="METAL_MEDIUM_STAB"
        set udg_WeaponTypeDebugStr[10]="METAL_HEAVY_STAB"
        set udg_WeaponTypeDebugStr[11]="WOOD_LIGHT_SLICE"
        set udg_WeaponTypeDebugStr[12]="WOOD_MEDIUM_SLICE"
        set udg_WeaponTypeDebugStr[13]="WOOD_HEAVY_SLICE"
        set udg_WeaponTypeDebugStr[14]="WOOD_LIGHT_BASH"
        set udg_WeaponTypeDebugStr[15]="WOOD_MEDIUM_BASH"
        set udg_WeaponTypeDebugStr[16]="WOOD_HEAVY_BASH"
        set udg_WeaponTypeDebugStr[17]="WOOD_LIGHT_STAB"
        set udg_WeaponTypeDebugStr[18]="WOOD_MEDIUM_STAB"
        set udg_WeaponTypeDebugStr[19]="CLAW_LIGHT_SLICE"
        set udg_WeaponTypeDebugStr[20]="CLAW_MEDIUM_SLICE"
        set udg_WeaponTypeDebugStr[21]="CLAW_HEAVY_SLICE"
        set udg_WeaponTypeDebugStr[22]="AXE_MEDIUM_CHOP"
        set udg_WeaponTypeDebugStr[23]="ROCK_HEAVY_BASH"
        set udg_DefenseTypeDebugStr[0]="LIGHT"
        set udg_DefenseTypeDebugStr[1]="MEDIUM"
        set udg_DefenseTypeDebugStr[2]="HEAVY"
        set udg_DefenseTypeDebugStr[3]="FORTIFIED"
        set udg_DefenseTypeDebugStr[4]="NORMAL" //Typically deals flat damage to all armor types
        set udg_DefenseTypeDebugStr[5]="HERO"
        set udg_DefenseTypeDebugStr[6]="DIVINE"
        set udg_DefenseTypeDebugStr[7]="UNARMORED"
        set udg_ArmorTypeDebugStr[0]="NONE" //ARMOR_TYPE_WHOKNOWS in JASS, added in 1.31
        set udg_ArmorTypeDebugStr[1]="FLESH"
        set udg_ArmorTypeDebugStr[2]="METAL"
        set udg_ArmorTypeDebugStr[3]="WOOD"
        set udg_ArmorTypeDebugStr[4]="ETHEREAL"
        set udg_ArmorTypeDebugStr[5]="STONE"
    endfunction
    //===========================================================================
    //
    // Setup of automatic events from GUI and custom ones from JASS alike
    //
    //===========================================================================
    function DamageEngine_RegisterFromHook takes trigger whichTrig,string var,limitop op,real value returns nothing
        call s__DamageTrigger_registerVerbose(whichTrig , var , value , true , GetHandleId(op))
    endfunction
//processed hook:     hook TriggerRegisterVariableEvent DamageEngine_RegisterFromHook
    function TriggerRegisterDamageEngineEx takes trigger whichTrig,string eventName,real value,integer f returns integer
        return s__DamageTrigger_registerVerbose(whichTrig , s__DamageTrigger_getVerboseStr(eventName) , value , false , f)
    endfunction
    function TriggerRegisterDamageEngine takes trigger whichTrig,string eventName,real value returns integer
        return s__DamageTrigger_registerTrigger(whichTrig , eventName , value)
    endfunction
    function RegisterDamageEngineEx takes code c,string eventName,real value,integer f returns integer
        return TriggerRegisterDamageEngineEx(s__DamageTrigger__staticgetindex(c) , eventName , value , f)
    endfunction
    //Similar to TriggerRegisterDamageEvent, although takes code instead of trigger as the first argument.
    function RegisterDamageEngine takes code c,string eventName,real value returns integer
        return RegisterDamageEngineEx(c , eventName , value , DamageEngine_FILTER_OTHER)
    endfunction
    //For GUI to tap into more powerful vJass event filtering:

//library DamageEngine ends
//library ExtendableBonusSystem:
    

    
    
    

        function s__RealAbilityBonus_AbilityCode takes integer this returns integer
            call BJDebugMsg("RealAbilityBonus missing AbilityCode!")
            return - 1
        endfunction

        function s__RealAbilityBonus_Field takes integer this returns abilityreallevelfield
            call BJDebugMsg("RealAbilityBonus missing Field!")
            return null
        endfunction

        function s__RealAbilityBonus_Set takes integer this,unit u,real value returns real
            local integer abilCode= sc__RealAbilityBonus_AbilityCode(this)
            if GetUnitAbilityLevel(u, abilCode) == 0 then
                call UnitAddAbility(u, abilCode)
                call UnitMakeAbilityPermanent(u, true, abilCode)
            endif
        
            call BlzSetAbilityRealLevelField(BlzGetUnitAbility(u, abilCode), sc__RealAbilityBonus_Field(this), 0, value)
            call IncUnitAbilityLevel(u, abilCode)
            call DecUnitAbilityLevel(u, abilCode)
        
            return BlzGetAbilityRealLevelField(BlzGetUnitAbility(u, abilCode), sc__RealAbilityBonus_Field(this), 0)
        endfunction

        function s__RealAbilityBonus_Get takes integer this,unit u returns real
            return BlzGetAbilityRealLevelField(BlzGetUnitAbility(u, sc__RealAbilityBonus_AbilityCode(this)), sc__RealAbilityBonus_Field(this), 0)
        endfunction

        function s__IntegerAbilityBonus_AbilityCode takes integer this returns integer
            call BJDebugMsg("IntegerAbilityBonus missing AbilityCode!")
            return - 1
        endfunction

        function s__IntegerAbilityBonus_Field takes integer this returns abilityintegerlevelfield
            call BJDebugMsg("IntegerAbilityBonus missing Field!")
            return null
        endfunction

        function s__IntegerAbilityBonus_Set takes integer this,unit u,real value returns real
            local integer abilCode= sc__IntegerAbilityBonus_AbilityCode(this)
            if GetUnitAbilityLevel(u, abilCode) == 0 then
                call UnitAddAbility(u, abilCode)
                call UnitMakeAbilityPermanent(u, true, abilCode)
            endif
            call BlzSetAbilityIntegerLevelField(BlzGetUnitAbility(u, abilCode), sc__IntegerAbilityBonus_Field(this), 0, R2I(value))
            call IncUnitAbilityLevel(u, abilCode)
            call DecUnitAbilityLevel(u, abilCode)
        
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, abilCode), sc__IntegerAbilityBonus_Field(this), 0))
        endfunction

        function s__IntegerAbilityBonus_Get takes integer this,unit u returns real
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, sc__IntegerAbilityBonus_AbilityCode(this)), sc__IntegerAbilityBonus_Field(this), 0))
        endfunction

        function s__IntegerAbilityBonus_IsIntegerBonus takes integer this returns boolean
            return true
        endfunction

        //private static integer maxTypeId = -1

        function s__ExtendableBonus_Register takes integer bonus returns integer
            set s__ExtendableBonus_registeredBonuses[si__ExtendableBonusSystem_ExtendableBonusPlugin_type[bonus]]=bonus
            //set maxTypeId = IMaxBJ(maxTypeId, bonus.getType())
            //call BJDebugMsg("maxTypeId=" + I2S(maxTypeId) + ", registedTypeId=" + I2S(bonus.getType()) + ", bonus=" + I2S(bonus))
            return si__ExtendableBonusSystem_ExtendableBonusPlugin_type[bonus]
        endfunction

        function s__ExtendableBonus_GetBonus takes integer typeId returns integer
            return s__ExtendableBonus_registeredBonuses[typeId]
        endfunction

        function s__ExtendableBonus_Get takes unit u,integer typeId returns real
            if ( s__ExtendableBonus_registeredBonuses[typeId] == 0 ) then
                call BJDebugMsg("type is not registered! id=" + I2S(typeId))
                return - 1.0
            else
                return sc__ExtendableBonusSystem_ExtendableBonusPlugin_Get(s__ExtendableBonus_registeredBonuses[typeId],u)
            endif
        endfunction

        function s__ExtendableBonus_Set takes unit u,integer typeId,real value returns real
            if ( s__ExtendableBonus_registeredBonuses[typeId] == 0 ) then
                call BJDebugMsg("type is not registered! id=" + I2S(typeId))
                return - 1.0
            else
                //call BJDebugMsg("Setting type=" + I2S(typeId) + " to " + R2S(value))
                return sc__ExtendableBonusSystem_ExtendableBonusPlugin_Set(s__ExtendableBonus_registeredBonuses[typeId],u , value)
            endif
        endfunction

        function s__ExtendableBonus_Add takes unit u,integer typeId,real value returns real
            local integer currentBonus= (s__ExtendableBonus_registeredBonuses[(typeId)]) // INLINED!!
            local real addedValue
            if sc__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus(currentBonus) then
                set addedValue=R2I(value)
            else
                set addedValue=value
            endif
            call s__ExtendableBonus_Set(u , typeId , sc__ExtendableBonusSystem_ExtendableBonusPlugin_Get(currentBonus,u) + addedValue)
            return addedValue
        endfunction

    function GetUnitBonus takes unit u,integer typeId returns real
        return s__ExtendableBonus_Get(u , typeId)
    endfunction

    function SetUnitBonus takes unit u,integer typeId,real value returns real
        return s__ExtendableBonus_Set(u , typeId , value)
    endfunction

    function AddUnitBonus takes unit u,integer typeId,real value returns real
        return s__ExtendableBonus_Add(u , typeId , value)
    endfunction

    function RemoveUnitBonus takes unit u,integer typeId returns nothing
        call s__ExtendableBonus_Set(u , typeId , 0)
    endfunction

//library ExtendableBonusSystem ends
//library LineSegmentEnumeration:
//  --- API ---
// ==== End API ====






    function s__LineSegment_PrepareRect takes real ax,real ay,real bx,real by,real offset,real offsetCollision returns nothing
        local real maxX
        local real maxY
        local real minX
        local real minY

        // get center coordinates of rectangle
        set s__LineSegment_ox=0.5 * ( ax + bx )
        set s__LineSegment_oy=0.5 * ( ay + by )

        // get rectangle major axis as vector
        set s__LineSegment_dx=0.5 * ( bx - ax )
        set s__LineSegment_dy=0.5 * ( by - ay )

        // get half of rectangle length (da) and height (db)
        set s__LineSegment_da=SquareRoot(s__LineSegment_dx * s__LineSegment_dx + s__LineSegment_dy * s__LineSegment_dy)
        set s__LineSegment_db=offset

        // get unit vector of the major axis
        set s__LineSegment_ui=s__LineSegment_dx / s__LineSegment_da
        set s__LineSegment_uj=s__LineSegment_dy / s__LineSegment_da

        // Prepare the bounding Jass Rect
        set offset=offset + offsetCollision

        if ax > bx then
            set maxX=ax + offset
            set minX=bx - offset
        else
            set maxX=bx + offset
            set minX=ax - offset
        endif

        if ay > by then
            set maxY=ay + offset
            set minY=by - offset
        else
            set maxY=by + offset
            set minY=ay - offset
        endif

        call SetRect(s__LineSegment_RECT, minX, minY, maxX, maxY)
    endfunction

    function s__LineSegment_RotateWidgetCoordinates takes widget w returns nothing
        // distance of widget from rectangle center in vector form
        set s__LineSegment_wdx=GetWidgetX(w) - s__LineSegment_ox
        set s__LineSegment_wdy=GetWidgetY(w) - s__LineSegment_oy

        set s__LineSegment_dx=s__LineSegment_wdx * s__LineSegment_ui + s__LineSegment_wdy * s__LineSegment_uj // get the component of above vector in the rect's major axis
        set s__LineSegment_dy=s__LineSegment_wdx * ( - s__LineSegment_uj ) + s__LineSegment_wdy * s__LineSegment_ui // get the component of above vector in the rect's transverse axis
    endfunction

    function s__LineSegment_IsWidgetInRect takes widget w returns boolean
        call s__LineSegment_RotateWidgetCoordinates(w)

        // Check if the components above are less than half the length and height of the rectangle
        // (Square them to compare absolute values)
        return s__LineSegment_dx * s__LineSegment_dx <= s__LineSegment_da * s__LineSegment_da and s__LineSegment_dy * s__LineSegment_dy <= s__LineSegment_db * s__LineSegment_db
    endfunction

    function s__LineSegment_IsUnitInRect takes unit u,boolean checkCollision returns boolean
        if checkCollision then
            call s__LineSegment_RotateWidgetCoordinates(u)

            // Check if the perpendicular distances of the unit from both axes of the rect are less than
            // da and db
            return IsUnitInRangeXY(u, s__LineSegment_ox - s__LineSegment_dy * s__LineSegment_uj, s__LineSegment_oy + s__LineSegment_dy * s__LineSegment_ui, RAbsBJ(s__LineSegment_da)) and IsUnitInRangeXY(u, s__LineSegment_ox + s__LineSegment_dx * s__LineSegment_ui, s__LineSegment_oy + s__LineSegment_dx * s__LineSegment_uj, RAbsBJ(s__LineSegment_db))
        endif

        return s__LineSegment_IsWidgetInRect(u)
    endfunction

    function s__LineSegment_EnumUnitsEx takes group whichgroup,real ax,real ay,real bx,real by,real offset,boolean checkCollision returns nothing
        local unit u

        if checkCollision then
            call s__LineSegment_PrepareRect(ax , ay , bx , by , offset , s__LineSegment_MAX_UNIT_COLLISION)
        else
            call s__LineSegment_PrepareRect(ax , ay , bx , by , offset , 0.00)
        endif

        call GroupEnumUnitsInRect(s__LineSegment_GROUP, s__LineSegment_RECT, null)

        // enum through all tracked units, and check if it's inside bounds
        call GroupClear(whichgroup)
        loop
            set u=FirstOfGroup(s__LineSegment_GROUP)
            exitwhen u == null

            if s__LineSegment_IsUnitInRect(u , checkCollision) then
                call GroupAddUnit(whichgroup, u)
            endif

            call GroupRemoveUnit(s__LineSegment_GROUP, u)
        endloop
    endfunction

    function s__LineSegment_EnumUnits takes group whichgroup,real ax,real ay,real bx,real by,real offset returns nothing
        call s__LineSegment_EnumUnitsEx(whichgroup , ax , ay , bx , by , offset , false)
    endfunction


//textmacro instance: LSE_WIDGET("destructable", "Destructable")

    function s__LineSegment_onDestructableFilter takes nothing returns nothing
        local destructable t= GetFilterDestructable()

        if s__LineSegment_IsWidgetInRect(t) then
            set s__LineSegment_DestructableCounter=s__LineSegment_DestructableCounter + 1
            set s__LineSegment_Destructable[s__LineSegment_DestructableCounter]=t
        endif

        set t=null
    endfunction

    function s__LineSegment_EnumDestructables takes real ax,real ay,real bx,real by,real offset returns nothing
        call s__LineSegment_PrepareRect(ax , ay , bx , by , offset , 0.00)

        set s__LineSegment_DestructableCounter=- 1
        call EnumDestructablesInRect(s__LineSegment_RECT, Filter(function s__LineSegment_onDestructableFilter), null)
    endfunction
//end of: LSE_WIDGET("destructable", "Destructable")
//textmacro instance: LSE_WIDGET("item", "Item")

    function s__LineSegment_onItemFilter takes nothing returns nothing
        local item t= GetFilterItem()

        if s__LineSegment_IsWidgetInRect(t) then
            set s__LineSegment_ItemCounter=s__LineSegment_ItemCounter + 1
            set s__LineSegment_Item[s__LineSegment_ItemCounter]=t
        endif

        set t=null
    endfunction

    function s__LineSegment_EnumItems takes real ax,real ay,real bx,real by,real offset returns nothing
        call s__LineSegment_PrepareRect(ax , ay , bx , by , offset , 0.00)

        set s__LineSegment_ItemCounter=- 1
        call EnumItemsInRect(s__LineSegment_RECT, Filter(function s__LineSegment_onItemFilter), null)
    endfunction
//end of: LSE_WIDGET("item", "Item")


//library LineSegmentEnumeration ends
//library MouseUtils:

//  Arbitrary constants

        //  Determines the minimum interval that a mouse move event detector
        //  will be deactivated. (Globally-based)
        //  You can configure it to any amount you like.
        
        //  Determines how many times a mouse move event detector can fire
        //  before being deactivated. (locally-based)
        //  You can configure this to any integer value. (Preferably positive)
        
        // Determines the amount to be deducted from mouseEventCount
        // per INTERVAL. Runs independently of resetTimer



 
    
    
    
    //  Converts the enum type mousebuttontype into an integer
    function s__UserMouse_toIndex takes mousebuttontype mouseButton returns integer
        return GetHandleId(mouseButton)
    endfunction
    
    function s__UserMouse_getCurEventType takes nothing returns integer
        return s__UserMouse_currentEventType
    endfunction
    
    function s__UserMouse__staticgetindex takes player p returns integer
        if s__UserMouse_posDetector[(GetPlayerId(p) + 1)] != null then
            return GetPlayerId(p) + 1
        endif
        return 0
    endfunction
        
    function s__UserMouse__get_player takes integer this returns player
        return Player(this - 1)
    endfunction
    function s__UserMouse__get_isMouseClicked takes integer this returns boolean
        return s__UserMouse_mouseClickCount[this] > 0
    endfunction
    function s__UserMouse_isMouseButtonClicked takes integer this,mousebuttontype mouseButton returns boolean
        return s__UserMouse_mouseButtonStack[( this - 1 ) * 3 + (GetHandleId((mouseButton)))] > 0 // INLINED!!
    endfunction
    function s__UserMouse_setMousePos takes integer this,integer x,integer y returns nothing
        if GetLocalPlayer() == (Player((this) - 1)) then // INLINED!!
            call BlzSetMousePos(x, y)
        endif
    endfunction

    function s__UserMouse_getMouseEventReductor takes timer t returns integer
        local integer this= s__UserMouse_next[(0)]
        loop
        exitwhen s__UserMouse_mouseEventReductor[this] == t or this == 0
            set this=s__UserMouse_next[this]
        endloop
        return this
    endfunction
    function s__UserMouse_onMouseUpdateListener takes nothing returns nothing
        local integer this= s__UserMouse_resetNext[(0)]
        set s__UserMouse_updateCount=0
        
        loop
            exitwhen this == 0
            set s__UserMouse_updateCount=s__UserMouse_updateCount + 1
                        
            set s__UserMouse_mouseEventCount[this]=0
            call EnableTrigger(s__UserMouse_posDetector[this])
            
            set s__UserMouse_resetPrev[s__UserMouse_resetNext[this]]=s__UserMouse_resetPrev[this]
            set s__UserMouse_resetNext[s__UserMouse_resetPrev[this]]=s__UserMouse_resetNext[this]
            
            set this=s__UserMouse_resetNext[this]
        endloop
        if s__UserMouse_updateCount > 0 then

                call TimerStart(s__UserMouse_resetTimer, s__UserMouse_INTERVAL, false, function s__UserMouse_onMouseUpdateListener)



        else

                call TimerStart(s__UserMouse_resetTimer, 0.00, false, null)
                call PauseTimer(s__UserMouse_resetTimer)

        endif
    endfunction
    function s__UserMouse_onMouseReductListener takes nothing returns nothing
        local integer this= s__UserMouse_getMouseEventReductor(GetExpiredTimer())
        if s__UserMouse_mouseEventCount[this] <= 0 then
            call PauseTimer(s__UserMouse_mouseEventReductor[this])
        else
            set s__UserMouse_mouseEventCount[this]=IMaxBJ(s__UserMouse_mouseEventCount[this] - s__UserMouse_MOUSE_COUNT_LOSS, 0)
            call TimerStart(s__UserMouse_mouseEventReductor[this], s__UserMouse_INTERVAL, false, function s__UserMouse_onMouseReductListener)
        endif
    endfunction

    function s__UserMouse_onMouseUpOrDown takes nothing returns nothing
        local integer this= s__UserMouse__staticgetindex(GetTriggerPlayer())
        local integer index= ( this - 1 ) * 3 + (GetHandleId((BlzGetTriggerPlayerMouseButton()))) // INLINED!!
        local boolean releaseFlag= false
        
        if GetTriggerEventId() == EVENT_PLAYER_MOUSE_DOWN then
            set s__UserMouse_mouseClickCount[this]=IMinBJ(s__UserMouse_mouseClickCount[this] + 1, 3)
            set releaseFlag=s__UserMouse_mouseButtonStack[index] <= 0
            set s__UserMouse_mouseButtonStack[index]=IMinBJ(s__UserMouse_mouseButtonStack[index] + 1, 1)
           
            if releaseFlag then
                set s__UserMouse_currentEventType=EVENT_MOUSE_DOWN
                call TriggerEvaluate(s__UserMouse_evTrigger[EVENT_MOUSE_DOWN])
            endif
        else
            set s__UserMouse_mouseClickCount[this]=IMaxBJ(s__UserMouse_mouseClickCount[this] - 1, 0)
            set releaseFlag=s__UserMouse_mouseButtonStack[index] > 0
            set s__UserMouse_mouseButtonStack[index]=IMaxBJ(s__UserMouse_mouseButtonStack[index] - 1, 0)
            
            if releaseFlag then
                set s__UserMouse_currentEventType=EVENT_MOUSE_UP
                call TriggerEvaluate(s__UserMouse_evTrigger[EVENT_MOUSE_UP])
            endif
        endif
    endfunction
    
    function s__UserMouse_onMouseMove takes nothing returns nothing
        local integer this= s__UserMouse__staticgetindex(GetTriggerPlayer())
        local boolean started= false
        set s__UserMouse_mouseX[this]=BlzGetTriggerPlayerMouseX()
        set s__UserMouse_mouseY[this]=BlzGetTriggerPlayerMouseY()

            set s__UserMouse_mouseEventCount[this]=s__UserMouse_mouseEventCount[this] + 1
            if s__UserMouse_mouseEventCount[this] <= 1 then
                call TimerStart(s__UserMouse_mouseEventReductor[this], s__UserMouse_INTERVAL, false, function s__UserMouse_onMouseReductListener)
            endif

        set s__UserMouse_currentEventType=EVENT_MOUSE_MOVE
        call TriggerEvaluate(s__UserMouse_evTrigger[EVENT_MOUSE_MOVE])

            if s__UserMouse_mouseEventCount[this] >= s__UserMouse_MOUSE_COUNT_MAX then
                call DisableTrigger(s__UserMouse_posDetector[this])
                if s__UserMouse_resetNext[(0)] == 0 then

                        call TimerStart(s__UserMouse_resetTimer, s__UserMouse_INTERVAL, false, function s__UserMouse_onMouseUpdateListener)
                    // Mouse event reductor should be paused



                    call PauseTimer(s__UserMouse_mouseEventReductor[this])
                endif
                set s__UserMouse_resetNext[this]=0
                set s__UserMouse_resetPrev[this]=s__UserMouse_resetPrev[s__UserMouse_resetNext[this]]
                set s__UserMouse_resetNext[s__UserMouse_resetPrev[this]]=this
                set s__UserMouse_resetPrev[s__UserMouse_resetNext[this]]=this
                if started then
                    call s__UserMouse_onMouseUpdateListener()
                endif
            endif

    endfunction
        
    function s__UserMouse_initCallback takes nothing returns nothing
        local integer this= 1
        local player p= (Player((this) - 1)) // INLINED!!
  

            set s__UserMouse_resetTimer=CreateTimer()

        set s__UserMouse_stateDetector=CreateTrigger()
        call TriggerAddCondition(s__UserMouse_stateDetector, Condition(function s__UserMouse_onMouseUpOrDown))
        loop
            exitwhen (this) > bj_MAX_PLAYER_SLOTS
            if GetPlayerController(p) == MAP_CONTROL_USER and GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
                set s__UserMouse_next[this]=0
                set s__UserMouse_prev[this]=s__UserMouse_prev[(0)]
                set s__UserMouse_next[s__UserMouse_prev[(0)]]=this
                set s__UserMouse_prev[(0)]=this
                
                set s__UserMouse_posDetector[this]=CreateTrigger()

                    set s__UserMouse_mouseEventReductor[this]=CreateTimer()

                call TriggerRegisterPlayerEvent(s__UserMouse_posDetector[this], p, EVENT_PLAYER_MOUSE_MOVE)
                call TriggerAddCondition(s__UserMouse_posDetector[this], Condition(function s__UserMouse_onMouseMove))
                
                call TriggerRegisterPlayerEvent(s__UserMouse_stateDetector, p, EVENT_PLAYER_MOUSE_UP)
                call TriggerRegisterPlayerEvent(s__UserMouse_stateDetector, p, EVENT_PLAYER_MOUSE_DOWN)
            endif
            set this=this + 1
            set p=(Player((this) - 1)) // INLINED!!
        endloop
    endfunction
    
    function s__UserMouse_timerInit takes nothing returns nothing
        call s__UserMouse_initCallback()
    endfunction
    function s__UserMouse_registerCode takes code handlerFunc,integer eventId returns triggercondition
        return TriggerAddCondition(s__UserMouse_evTrigger[eventId], Condition(handlerFunc))
    endfunction
    
    function s__UserMouse_unregisterCallback takes triggercondition whichHandler,integer eventId returns nothing
        call TriggerRemoveCondition(s__UserMouse_evTrigger[eventId], whichHandler)
    endfunction
    
//Implemented from module MouseUtils__Init:
    function s__UserMouse_MouseUtils__Init___invokeTimerInit takes nothing returns nothing
        call PauseTimer(GetExpiredTimer())
        call DestroyTimer(GetExpiredTimer())
        call s__UserMouse_initCallback() // INLINED!!
    endfunction
    function s__UserMouse_MouseUtils__Init___onInit takes nothing returns nothing
        set s__UserMouse_evTrigger[EVENT_MOUSE_UP]=CreateTrigger()
        set s__UserMouse_evTrigger[EVENT_MOUSE_DOWN]=CreateTrigger()
        set s__UserMouse_evTrigger[EVENT_MOUSE_MOVE]=CreateTrigger()
        call TimerStart(CreateTimer(), 0.00, false, function s__UserMouse_MouseUtils__Init___invokeTimerInit)
    endfunction
function GetPlayerMouseX takes player p returns real
    return s__UserMouse_mouseX[s__UserMouse__staticgetindex(p)]
endfunction
function GetPlayerMouseY takes player p returns real
    return s__UserMouse_mouseY[s__UserMouse__staticgetindex(p)]
endfunction
function OnMouseEvent takes code func,integer eventId returns triggercondition
    return s__UserMouse_registerCode(func , eventId)
endfunction
function GetMouseEventType takes nothing returns integer
    return (s__UserMouse_currentEventType) // INLINED!!
endfunction
function UnregisterMouseCallback takes triggercondition whichHandler,integer eventId returns nothing
    call s__UserMouse_unregisterCallback(whichHandler , eventId)
endfunction
function SetUserMousePos takes player p,integer x,integer y returns nothing
    call s__UserMouse_setMousePos(s__UserMouse__staticgetindex(p),x , y)
endfunction

//library MouseUtils ends
//library RegisterPlayerUnitEvent:
   
    function RegisterPlayerUnitEvent takes playerunitevent p,code c returns nothing
        local integer i= GetHandleId(p)
        local integer k= 15
        if RegisterPlayerUnitEvent__t[i] == null then
            set RegisterPlayerUnitEvent__t[i]=CreateTrigger()
            loop
                call TriggerRegisterPlayerUnitEvent(RegisterPlayerUnitEvent__t[i], Player(k), p, null)
                exitwhen k == 0
                set k=k - 1
            endloop
        endif
        call TriggerAddCondition(RegisterPlayerUnitEvent__t[i], Filter(c))
    endfunction
   
    function RegisterPlayerUnitEventForPlayer takes playerunitevent p,code c,player pl returns nothing
        local integer i= 16 * GetHandleId(p) + GetPlayerId(pl)
        if RegisterPlayerUnitEvent__t[i] == null then
            set RegisterPlayerUnitEvent__t[i]=CreateTrigger()
            call TriggerRegisterPlayerUnitEvent(RegisterPlayerUnitEvent__t[i], pl, p, null)
        endif
        call TriggerAddCondition(RegisterPlayerUnitEvent__t[i], Filter(c))
    endfunction
   
    function GetPlayerUnitEventTrigger takes playerunitevent p returns trigger
        return RegisterPlayerUnitEvent__t[GetHandleId(p)]
    endfunction

//library RegisterPlayerUnitEvent ends
//library Table:
    

    function s__Table__dex__get_size takes nothing returns integer
        return Table__sizeK
    endfunction
    function s__Table__dex__get_list takes nothing returns integer
        return Table__listK
    endfunction

    function s__Table__handles_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__handles_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction

    function s__Table__agents__setindex takes integer this,integer key,agent value returns nothing
        call SaveAgentHandle(Table__ht, this, key, value)
    endfunction

    

//Run these textmacros to include the entire hashtable API as wrappers.
//Don't be intimidated by the number of macros - Vexorian's map optimizer is
//supposed to kill functions which inline (all of these functions inline).
//textmacro instance: NEW_ARRAY_BASIC("Real", "Real", "real")
    function s__Table__reals__getindex takes integer this,integer key returns real
        return LoadReal(Table__ht, this, key)
    endfunction
    function s__Table__reals__setindex takes integer this,integer key,real value returns nothing
        call SaveReal(Table__ht, this, key, value)
    endfunction
    function s__Table__reals_has takes integer this,integer key returns boolean
        return HaveSavedReal(Table__ht, this, key)
    endfunction
    function s__Table__reals_remove takes integer this,integer key returns nothing
        call RemoveSavedReal(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Real", "Real", "real")
//textmacro instance: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
    function s__Table__booleans__getindex takes integer this,integer key returns boolean
        return LoadBoolean(Table__ht, this, key)
    endfunction
    function s__Table__booleans__setindex takes integer this,integer key,boolean value returns nothing
        call SaveBoolean(Table__ht, this, key, value)
    endfunction
    function s__Table__booleans_has takes integer this,integer key returns boolean
        return HaveSavedBoolean(Table__ht, this, key)
    endfunction
    function s__Table__booleans_remove takes integer this,integer key returns nothing
        call RemoveSavedBoolean(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
//textmacro instance: NEW_ARRAY_BASIC("String", "Str", "string")
    function s__Table__strings__getindex takes integer this,integer key returns string
        return LoadStr(Table__ht, this, key)
    endfunction
    function s__Table__strings__setindex takes integer this,integer key,string value returns nothing
        call SaveStr(Table__ht, this, key, value)
    endfunction
    function s__Table__strings_has takes integer this,integer key returns boolean
        return HaveSavedString(Table__ht, this, key)
    endfunction
    function s__Table__strings_remove takes integer this,integer key returns nothing
        call RemoveSavedString(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("String", "Str", "string")
//New textmacro to allow table.integer[] syntax for compatibility with textmacros that might desire it.
//textmacro instance: NEW_ARRAY_BASIC("Integer", "Integer", "integer")
    function s__Table__integers__getindex takes integer this,integer key returns integer
        return LoadInteger(Table__ht, this, key)
    endfunction
    function s__Table__integers__setindex takes integer this,integer key,integer value returns nothing
        call SaveInteger(Table__ht, this, key, value)
    endfunction
    function s__Table__integers_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table__ht, this, key)
    endfunction
    function s__Table__integers_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Integer", "Integer", "integer")

//textmacro instance: NEW_ARRAY("Player", "player")
    function s__Table__players__getindex takes integer this,integer key returns player
        return LoadPlayerHandle(Table__ht, this, key)
    endfunction
    function s__Table__players__setindex takes integer this,integer key,player value returns nothing
        call SavePlayerHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__players_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__players_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Player", "player")
//textmacro instance: NEW_ARRAY("Widget", "widget")
    function s__Table__widgets__getindex takes integer this,integer key returns widget
        return LoadWidgetHandle(Table__ht, this, key)
    endfunction
    function s__Table__widgets__setindex takes integer this,integer key,widget value returns nothing
        call SaveWidgetHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__widgets_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__widgets_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Widget", "widget")
//textmacro instance: NEW_ARRAY("Destructable", "destructable")
    function s__Table__destructables__getindex takes integer this,integer key returns destructable
        return LoadDestructableHandle(Table__ht, this, key)
    endfunction
    function s__Table__destructables__setindex takes integer this,integer key,destructable value returns nothing
        call SaveDestructableHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__destructables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__destructables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Destructable", "destructable")
//textmacro instance: NEW_ARRAY("Item", "item")
    function s__Table__items__getindex takes integer this,integer key returns item
        return LoadItemHandle(Table__ht, this, key)
    endfunction
    function s__Table__items__setindex takes integer this,integer key,item value returns nothing
        call SaveItemHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__items_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__items_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Item", "item")
//textmacro instance: NEW_ARRAY("Unit", "unit")
    function s__Table__units__getindex takes integer this,integer key returns unit
        return LoadUnitHandle(Table__ht, this, key)
    endfunction
    function s__Table__units__setindex takes integer this,integer key,unit value returns nothing
        call SaveUnitHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__units_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__units_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Unit", "unit")
//textmacro instance: NEW_ARRAY("Ability", "ability")
    function s__Table__abilitys__getindex takes integer this,integer key returns ability
        return LoadAbilityHandle(Table__ht, this, key)
    endfunction
    function s__Table__abilitys__setindex takes integer this,integer key,ability value returns nothing
        call SaveAbilityHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__abilitys_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__abilitys_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Ability", "ability")
//textmacro instance: NEW_ARRAY("Timer", "timer")
    function s__Table__timers__getindex takes integer this,integer key returns timer
        return LoadTimerHandle(Table__ht, this, key)
    endfunction
    function s__Table__timers__setindex takes integer this,integer key,timer value returns nothing
        call SaveTimerHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__timers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__timers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Timer", "timer")
//textmacro instance: NEW_ARRAY("Trigger", "trigger")
    function s__Table__triggers__getindex takes integer this,integer key returns trigger
        return LoadTriggerHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggers__setindex takes integer this,integer key,trigger value returns nothing
        call SaveTriggerHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__triggers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Trigger", "trigger")
//textmacro instance: NEW_ARRAY("TriggerCondition", "triggercondition")
    function s__Table__triggerconditions__getindex takes integer this,integer key returns triggercondition
        return LoadTriggerConditionHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggerconditions__setindex takes integer this,integer key,triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__triggerconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggerconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerCondition", "triggercondition")
//textmacro instance: NEW_ARRAY("TriggerAction", "triggeraction")
    function s__Table__triggeractions__getindex takes integer this,integer key returns triggeraction
        return LoadTriggerActionHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggeractions__setindex takes integer this,integer key,triggeraction value returns nothing
        call SaveTriggerActionHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__triggeractions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__triggeractions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerAction", "triggeraction")
//textmacro instance: NEW_ARRAY("TriggerEvent", "event")
    function s__Table__events__getindex takes integer this,integer key returns event
        return LoadTriggerEventHandle(Table__ht, this, key)
    endfunction
    function s__Table__events__setindex takes integer this,integer key,event value returns nothing
        call SaveTriggerEventHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__events_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__events_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("TriggerEvent", "event")
//textmacro instance: NEW_ARRAY("Force", "force")
    function s__Table__forces__getindex takes integer this,integer key returns force
        return LoadForceHandle(Table__ht, this, key)
    endfunction
    function s__Table__forces__setindex takes integer this,integer key,force value returns nothing
        call SaveForceHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__forces_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__forces_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Force", "force")
//textmacro instance: NEW_ARRAY("Group", "group")
    function s__Table__groups__getindex takes integer this,integer key returns group
        return LoadGroupHandle(Table__ht, this, key)
    endfunction
    function s__Table__groups__setindex takes integer this,integer key,group value returns nothing
        call SaveGroupHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__groups_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__groups_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Group", "group")
//textmacro instance: NEW_ARRAY("Location", "location")
    function s__Table__locations__getindex takes integer this,integer key returns location
        return LoadLocationHandle(Table__ht, this, key)
    endfunction
    function s__Table__locations__setindex takes integer this,integer key,location value returns nothing
        call SaveLocationHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__locations_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__locations_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Location", "location")
//textmacro instance: NEW_ARRAY("Rect", "rect")
    function s__Table__rects__getindex takes integer this,integer key returns rect
        return LoadRectHandle(Table__ht, this, key)
    endfunction
    function s__Table__rects__setindex takes integer this,integer key,rect value returns nothing
        call SaveRectHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__rects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__rects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Rect", "rect")
//textmacro instance: NEW_ARRAY("BooleanExpr", "boolexpr")
    function s__Table__boolexprs__getindex takes integer this,integer key returns boolexpr
        return LoadBooleanExprHandle(Table__ht, this, key)
    endfunction
    function s__Table__boolexprs__setindex takes integer this,integer key,boolexpr value returns nothing
        call SaveBooleanExprHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__boolexprs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__boolexprs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("BooleanExpr", "boolexpr")
//textmacro instance: NEW_ARRAY("Sound", "sound")
    function s__Table__sounds__getindex takes integer this,integer key returns sound
        return LoadSoundHandle(Table__ht, this, key)
    endfunction
    function s__Table__sounds__setindex takes integer this,integer key,sound value returns nothing
        call SaveSoundHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__sounds_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__sounds_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Sound", "sound")
//textmacro instance: NEW_ARRAY("Effect", "effect")
    function s__Table__effects__getindex takes integer this,integer key returns effect
        return LoadEffectHandle(Table__ht, this, key)
    endfunction
    function s__Table__effects__setindex takes integer this,integer key,effect value returns nothing
        call SaveEffectHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__effects_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__effects_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Effect", "effect")
//textmacro instance: NEW_ARRAY("UnitPool", "unitpool")
    function s__Table__unitpools__getindex takes integer this,integer key returns unitpool
        return LoadUnitPoolHandle(Table__ht, this, key)
    endfunction
    function s__Table__unitpools__setindex takes integer this,integer key,unitpool value returns nothing
        call SaveUnitPoolHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__unitpools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__unitpools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("UnitPool", "unitpool")
//textmacro instance: NEW_ARRAY("ItemPool", "itempool")
    function s__Table__itempools__getindex takes integer this,integer key returns itempool
        return LoadItemPoolHandle(Table__ht, this, key)
    endfunction
    function s__Table__itempools__setindex takes integer this,integer key,itempool value returns nothing
        call SaveItemPoolHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__itempools_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__itempools_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("ItemPool", "itempool")
//textmacro instance: NEW_ARRAY("Quest", "quest")
    function s__Table__quests__getindex takes integer this,integer key returns quest
        return LoadQuestHandle(Table__ht, this, key)
    endfunction
    function s__Table__quests__setindex takes integer this,integer key,quest value returns nothing
        call SaveQuestHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__quests_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__quests_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Quest", "quest")
//textmacro instance: NEW_ARRAY("QuestItem", "questitem")
    function s__Table__questitems__getindex takes integer this,integer key returns questitem
        return LoadQuestItemHandle(Table__ht, this, key)
    endfunction
    function s__Table__questitems__setindex takes integer this,integer key,questitem value returns nothing
        call SaveQuestItemHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__questitems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__questitems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("QuestItem", "questitem")
//textmacro instance: NEW_ARRAY("DefeatCondition", "defeatcondition")
    function s__Table__defeatconditions__getindex takes integer this,integer key returns defeatcondition
        return LoadDefeatConditionHandle(Table__ht, this, key)
    endfunction
    function s__Table__defeatconditions__setindex takes integer this,integer key,defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__defeatconditions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__defeatconditions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("DefeatCondition", "defeatcondition")
//textmacro instance: NEW_ARRAY("TimerDialog", "timerdialog")
    function s__Table__timerdialogs__getindex takes integer this,integer key returns timerdialog
        return LoadTimerDialogHandle(Table__ht, this, key)
    endfunction
    function s__Table__timerdialogs__setindex takes integer this,integer key,timerdialog value returns nothing
        call SaveTimerDialogHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__timerdialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__timerdialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("TimerDialog", "timerdialog")
//textmacro instance: NEW_ARRAY("Leaderboard", "leaderboard")
    function s__Table__leaderboards__getindex takes integer this,integer key returns leaderboard
        return LoadLeaderboardHandle(Table__ht, this, key)
    endfunction
    function s__Table__leaderboards__setindex takes integer this,integer key,leaderboard value returns nothing
        call SaveLeaderboardHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__leaderboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__leaderboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Leaderboard", "leaderboard")
//textmacro instance: NEW_ARRAY("Multiboard", "multiboard")
    function s__Table__multiboards__getindex takes integer this,integer key returns multiboard
        return LoadMultiboardHandle(Table__ht, this, key)
    endfunction
    function s__Table__multiboards__setindex takes integer this,integer key,multiboard value returns nothing
        call SaveMultiboardHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__multiboards_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__multiboards_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Multiboard", "multiboard")
//textmacro instance: NEW_ARRAY("MultiboardItem", "multiboarditem")
    function s__Table__multiboarditems__getindex takes integer this,integer key returns multiboarditem
        return LoadMultiboardItemHandle(Table__ht, this, key)
    endfunction
    function s__Table__multiboarditems__setindex takes integer this,integer key,multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__multiboarditems_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__multiboarditems_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("MultiboardItem", "multiboarditem")
//textmacro instance: NEW_ARRAY("Trackable", "trackable")
    function s__Table__trackables__getindex takes integer this,integer key returns trackable
        return LoadTrackableHandle(Table__ht, this, key)
    endfunction
    function s__Table__trackables__setindex takes integer this,integer key,trackable value returns nothing
        call SaveTrackableHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__trackables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__trackables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Trackable", "trackable")
//textmacro instance: NEW_ARRAY("Dialog", "dialog")
    function s__Table__dialogs__getindex takes integer this,integer key returns dialog
        return LoadDialogHandle(Table__ht, this, key)
    endfunction
    function s__Table__dialogs__setindex takes integer this,integer key,dialog value returns nothing
        call SaveDialogHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__dialogs_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__dialogs_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Dialog", "dialog")
//textmacro instance: NEW_ARRAY("Button", "button")
    function s__Table__buttons__getindex takes integer this,integer key returns button
        return LoadButtonHandle(Table__ht, this, key)
    endfunction
    function s__Table__buttons__setindex takes integer this,integer key,button value returns nothing
        call SaveButtonHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__buttons_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__buttons_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Button", "button")
//textmacro instance: NEW_ARRAY("TextTag", "texttag")
    function s__Table__texttags__getindex takes integer this,integer key returns texttag
        return LoadTextTagHandle(Table__ht, this, key)
    endfunction
    function s__Table__texttags__setindex takes integer this,integer key,texttag value returns nothing
        call SaveTextTagHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__texttags_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__texttags_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("TextTag", "texttag")
//textmacro instance: NEW_ARRAY("Lightning", "lightning")
    function s__Table__lightnings__getindex takes integer this,integer key returns lightning
        return LoadLightningHandle(Table__ht, this, key)
    endfunction
    function s__Table__lightnings__setindex takes integer this,integer key,lightning value returns nothing
        call SaveLightningHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__lightnings_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__lightnings_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Lightning", "lightning")
//textmacro instance: NEW_ARRAY("Image", "image")
    function s__Table__images__getindex takes integer this,integer key returns image
        return LoadImageHandle(Table__ht, this, key)
    endfunction
    function s__Table__images__setindex takes integer this,integer key,image value returns nothing
        call SaveImageHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__images_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__images_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Image", "image")
//textmacro instance: NEW_ARRAY("Ubersplat", "ubersplat")
    function s__Table__ubersplats__getindex takes integer this,integer key returns ubersplat
        return LoadUbersplatHandle(Table__ht, this, key)
    endfunction
    function s__Table__ubersplats__setindex takes integer this,integer key,ubersplat value returns nothing
        call SaveUbersplatHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__ubersplats_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__ubersplats_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Ubersplat", "ubersplat")
//textmacro instance: NEW_ARRAY("Region", "region")
    function s__Table__regions__getindex takes integer this,integer key returns region
        return LoadRegionHandle(Table__ht, this, key)
    endfunction
    function s__Table__regions__setindex takes integer this,integer key,region value returns nothing
        call SaveRegionHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__regions_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__regions_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Region", "region")
//textmacro instance: NEW_ARRAY("FogState", "fogstate")
    function s__Table__fogstates__getindex takes integer this,integer key returns fogstate
        return LoadFogStateHandle(Table__ht, this, key)
    endfunction
    function s__Table__fogstates__setindex takes integer this,integer key,fogstate value returns nothing
        call SaveFogStateHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__fogstates_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__fogstates_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("FogState", "fogstate")
//textmacro instance: NEW_ARRAY("FogModifier", "fogmodifier")
    function s__Table__fogmodifiers__getindex takes integer this,integer key returns fogmodifier
        return LoadFogModifierHandle(Table__ht, this, key)
    endfunction
    function s__Table__fogmodifiers__setindex takes integer this,integer key,fogmodifier value returns nothing
        call SaveFogModifierHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__fogmodifiers_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__fogmodifiers_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("FogModifier", "fogmodifier")
//textmacro instance: NEW_ARRAY("Hashtable", "hashtable")
    function s__Table__hashtables__getindex takes integer this,integer key returns hashtable
        return LoadHashtableHandle(Table__ht, this, key)
    endfunction
    function s__Table__hashtables__setindex takes integer this,integer key,hashtable value returns nothing
        call SaveHashtableHandle(Table__ht, this, key, value)
    endfunction
    function s__Table__hashtables_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table__ht, this, key)
    endfunction
    function s__Table__hashtables_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table__ht, this, key)
    endfunction
//end of: NEW_ARRAY("Hashtable", "hashtable")


    // Implement modules for intuitive syntax (tb.handle; tb.unit; etc.)
//Implemented from module Table__realm:
    function s__Table__get_real takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__integerm:
    function s__Table__get_integer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__booleanm:
    function s__Table__get_boolean takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__stringm:
    function s__Table__get_string takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__playerm:
    function s__Table__get_player takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__widgetm:
    function s__Table__get_widget takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__destructablem:
    function s__Table__get_destructable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__itemm:
    function s__Table__get_item takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__unitm:
    function s__Table__get_unit takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__abilitym:
    function s__Table__get_ability takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__timerm:
    function s__Table__get_timer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__triggerm:
    function s__Table__get_trigger takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__triggerconditionm:
    function s__Table__get_triggercondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__triggeractionm:
    function s__Table__get_triggeraction takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__eventm:
    function s__Table__get_event takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__forcem:
    function s__Table__get_force takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__groupm:
    function s__Table__get_group takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__locationm:
    function s__Table__get_location takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__rectm:
    function s__Table__get_rect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__boolexprm:
    function s__Table__get_boolexpr takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__soundm:
    function s__Table__get_sound takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__effectm:
    function s__Table__get_effect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__unitpoolm:
    function s__Table__get_unitpool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__itempoolm:
    function s__Table__get_itempool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__questm:
    function s__Table__get_quest takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__questitemm:
    function s__Table__get_questitem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__defeatconditionm:
    function s__Table__get_defeatcondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__timerdialogm:
    function s__Table__get_timerdialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__leaderboardm:
    function s__Table__get_leaderboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__multiboardm:
    function s__Table__get_multiboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__multiboarditemm:
    function s__Table__get_multiboarditem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__trackablem:
    function s__Table__get_trackable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__dialogm:
    function s__Table__get_dialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__buttonm:
    function s__Table__get_button takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__texttagm:
    function s__Table__get_texttag takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__lightningm:
    function s__Table__get_lightning takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__imagem:
    function s__Table__get_image takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__ubersplatm:
    function s__Table__get_ubersplat takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__regionm:
    function s__Table__get_region takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__fogstatem:
    function s__Table__get_fogstate takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__fogmodifierm:
    function s__Table__get_fogmodifier takes integer this returns integer
        return this
    endfunction
//Implemented from module Table__hashtablem:
    function s__Table__get_hashtable takes integer this returns integer
        return this
    endfunction

    function s__Table__get_handle takes integer this returns integer
        return this
    endfunction

    function s__Table__get_agent takes integer this returns integer
        return this
    endfunction

    //set this = tb[GetSpellAbilityId()]
    function s__Table__getindex takes integer this,integer key returns integer
        return LoadInteger(Table__ht, this, key) //return this.integer[key]
    endfunction

    //set tb[389034] = 8192
    function s__Table__setindex takes integer this,integer key,integer tb returns nothing
        call SaveInteger(Table__ht, this, key, tb) //set this.integer[key] = tb
    endfunction

    //set b = tb.has(2493223)
    function s__Table_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table__ht, this, key) //return this.integer.has(key)
    endfunction

    //call tb.remove(294080)
    function s__Table_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table__ht, this, key) //call this.integer.remove(key)
    endfunction

    //Remove all data from a Table instance
    function s__Table_flush takes integer this returns nothing
        call FlushChildHashtable(Table__ht, this)
    endfunction

    //local Table tb = Table.create()
    function s__Table_create takes nothing returns integer
        local integer this= (LoadInteger(Table__ht, ((Table__listK)), (0))) // INLINED!!
        
        if this == 0 then
            set this=Table__more + 1
            set Table__more=this
        else
            call SaveInteger(Table__ht, ((Table__listK)), (0), ( (LoadInteger(Table__ht, ((Table__listK)), (this))))) // INLINED!!
            call RemoveSavedInteger(Table__ht, ((Table__listK)), (this)) //Clear hashed memory // INLINED!!
        endif
        
        return this
    endfunction

    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    function s__Table_destroy takes integer this returns nothing
        call FlushChildHashtable(Table__ht, (this)) // INLINED!!

        call SaveInteger(Table__ht, ((Table__listK)), (this), ( (LoadInteger(Table__ht, ((Table__listK)), (0))))) // INLINED!!
        call SaveInteger(Table__ht, ((Table__listK)), (0), ( this)) // INLINED!!
    endfunction

//ignored textmacro command: TABLE_BC_METHODS()
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
    
    //Returns a new TableArray to do your bidding. Simply use:
    //
    //    local TableArray ta = TableArray[array_size]
    //
    function s__TableArray__staticgetindex takes integer array_size returns integer
        local integer tb= (LoadInteger(Table__ht, ((Table__sizeK)), (array_size))) // INLINED!!
        local integer this= (LoadInteger(Table__ht, (tb), (0))) // INLINED!!
        
        
        if this == 0 then
            set this=Table__less - array_size
            set Table__less=this
        else
            call SaveInteger(Table__ht, (tb), (0), ( (LoadInteger(Table__ht, (tb), (this))))) //Set the last destroyed to the last-last destroyed // INLINED!!
            call RemoveSavedInteger(Table__ht, (tb), (this)) //Clear hashed memory // INLINED!!
        endif
        
        call SaveInteger(Table__ht, ((Table__sizeK)), (this), ( array_size)) //This remembers the array size // INLINED!!
        return this
    endfunction
    
    //Returns the size of the TableArray
    function s__TableArray__get_size takes integer this returns integer
        return (LoadInteger(Table__ht, ((Table__sizeK)), (this))) // INLINED!!
    endfunction
    
    //This magic method enables two-dimensional[array][syntax] for Tables,
    //similar to the two-dimensional utility provided by hashtables them-
    //selves.
    //
    //ta[integer a].unit[integer b] = unit u
    //ta[integer a][integer c] = integer d
    //
    //Inline-friendly when not running in debug mode
    //
    function s__TableArray__getindex takes integer this,integer key returns integer










        return this + key
    endfunction
    
    //Destroys a TableArray without flushing it; I assume you call .flush()
    //if you want it flushed too. This is a public method so that you don't
    //have to loop through all TableArray indices to flush them if you don't
    //need to (ie. if you were flushing all child-keys as you used them).
    //
    function s__TableArray_destroy takes integer this returns nothing
        local integer tb= (LoadInteger(Table__ht, ((Table__sizeK)), ((LoadInteger(Table__ht, ((Table__sizeK)), ((this))))))) // INLINED!!
        
        
        if tb == 0 then
            //Create a Table to index recycled instances with their array size
            set tb=s__Table_create()
            call SaveInteger(Table__ht, ((Table__sizeK)), ((LoadInteger(Table__ht, ((Table__sizeK)), ((this))))), ( tb)) // INLINED!!
        endif
        
        call RemoveSavedInteger(Table__ht, ((Table__sizeK)), (this)) //Clear the array size from hash memory // INLINED!!
        
        call SaveInteger(Table__ht, (tb), (this), ( (LoadInteger(Table__ht, (tb), (0))))) // INLINED!!
        call SaveInteger(Table__ht, (tb), (0), ( this)) // INLINED!!
    endfunction
    
    
    //Avoids hitting the op limit
    function s__TableArray_clean takes nothing returns nothing
        local integer tb= s__TableArray_tempTable
        local integer end= tb + 0x1000
        if end < s__TableArray_tempEnd then
            set s__TableArray_tempTable=end
            call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        else
            set end=s__TableArray_tempEnd
        endif
        loop
            call FlushChildHashtable(Table__ht, (tb)) // INLINED!!
            set tb=tb + 1
            exitwhen tb == end
        endloop
    endfunction
    
    //Flushes the TableArray and also destroys it. Doesn't get any more
    //similar to the FlushParentHashtable native than this.
    //
    function s__TableArray_flush takes integer this returns nothing
        set s__TableArray_tempTable=this
        set s__TableArray_tempEnd=this + (LoadInteger(Table__ht, ((Table__sizeK)), ((this)))) // INLINED!!
        call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        call s__TableArray_destroy(this)
    endfunction
    
    
//NEW: Added in Table 4.0. A fairly simple struct but allows you to do more
//than that which was previously possible.

    //Enables myHash[parentKey][childKey] syntax.
    //Basically, it creates a Table in the place of the parent key if
    //it didn't already get created earlier.
    function s__HashTable__getindex takes integer this,integer index returns integer
        local integer t= (LoadInteger(Table__ht, ((this)), (index))) // INLINED!!
        if t == 0 then
            set t=s__Table_create()
            call SaveInteger(Table__ht, ((this)), (index), ( t)) //whoops! Forgot that line. I'm out of practice! // INLINED!!
        endif
        return t
    endfunction

    //You need to call this on each parent key that you used if you
    //intend to destroy the HashTable or simply no longer need that key.
    function s__HashTable_remove takes integer this,integer index returns nothing
        local integer t= (LoadInteger(Table__ht, ((this)), (index))) // INLINED!!
        if t != 0 then
            call s__Table_destroy(t)
            call RemoveSavedInteger(Table__ht, ((this)), (index)) // INLINED!!
        endif
    endfunction

    //Added in version 4.1
    function s__HashTable_has takes integer this,integer index returns boolean
        return (HaveSavedInteger(Table__ht, ((this)), (index))) // INLINED!!
    endfunction

    //HashTables are just fancy Table indices.
    function s__HashTable_destroy takes integer this returns nothing
        call s__Table_destroy((this))
    endfunction

    //Like I said above...
    function s__HashTable_create takes nothing returns integer
        return s__Table_create()
    endfunction



//library Table ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (red+blue+orange flavors for 1.24b+) 2.0
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: htt://www.wc3c.net
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* set t=NewTimerEx(x)   : Get a timer (alternative to CreateTimer), call
//*                            Initialize timer data as x, instead of 0.
//*
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Multi-flavor:
//*    Set USE_HASH_TABLE to true if you don't want to complicate your life.
//*
//* If you like speed and giberish try learning about the other flavors.
//*
//********************************************************************

//================================================================

    //==================================================================================================
   
   

    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t,integer value returns nothing

            // new blue
            call SaveInteger(TimerUtils__ht, 0, GetHandleId(t), value)
           

















    endfunction

    function GetTimerData takes timer t returns integer

            // new blue
            return LoadInteger(TimerUtils__ht, 0, GetHandleId(t))
           

















    endfunction

    //==========================================================================================

    //==========================================================================================
    // I needed to decide between duplicating code ignoring the "Once and only once" rule
    // and using the ugly textmacros. I guess textmacros won.
    //

    function NewTimerEx takes integer value returns timer
        if ( TimerUtils__tN == 0 ) then
            if ( not TimerUtils__didinit ) then
                //This extra if shouldn't represent a major performance drawback
                //because QUANTITY rule is not supposed to be broken every day.
                call TriggerEvaluate(st___prototype1[(1)]) // INLINED!!
                set TimerUtils__tN=TimerUtils__tN - 1
            else
                //If this happens then the QUANTITY rule has already been broken, try to fix the
                // issue, else fail.
                set s__TimerUtils__tT[0]= CreateTimer()















            endif
        else
            set TimerUtils__tN=TimerUtils__tN - 1
        endif
        call SaveInteger(TimerUtils__ht, 0, GetHandleId((s__TimerUtils__tT[TimerUtils__tN] )), ( value)) // INLINED!!
     return s__TimerUtils__tT[TimerUtils__tN]
    endfunction
   
    function NewTimer takes nothing returns timer
        return NewTimerEx(0)
    endfunction


    //==========================================================================================
    function ReleaseTimer takes timer t returns nothing
        if ( t == null ) then
            return
        endif
        if ( TimerUtils__tN == TimerUtils__ARRAY_SIZE ) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if ( (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) == TimerUtils__HELD ) then // INLINED!!
                return
            endif
            call SaveInteger(TimerUtils__ht, 0, GetHandleId((t )), ( TimerUtils__HELD)) // INLINED!!
            set s__TimerUtils__tT[TimerUtils__tN]= t
            set TimerUtils__tN=TimerUtils__tN + 1
        endif
    endfunction

    function TimerUtils__init takes nothing returns nothing
     local integer i=0
     local integer o=- 1
     local boolean oops= false
        if ( TimerUtils__didinit ) then
            return
        else
            set TimerUtils__didinit=true
        endif
     

            set TimerUtils__ht=InitHashtable()
            loop
                exitwhen ( i == TimerUtils__QUANTITY )
                set s__TimerUtils__tT[i]= CreateTimer()
                call SaveInteger(TimerUtils__ht, 0, GetHandleId((s__TimerUtils__tT[i] )), ( TimerUtils__HELD)) // INLINED!!
                set i=i + 1
            endloop
            set TimerUtils__tN=TimerUtils__QUANTITY










































    endfunction


//library TimerUtils ends
//library VersionManager:
    function IsReforged takes nothing returns boolean
        return GetLocalizedString("REFORGED") != "REFORGED" //Note: Does not work until after initialization
    endfunction
    

//library VersionManager ends
//library WorldBounds:
   
//Implemented from module WorldBounds__WorldBoundInit:

    function s__WorldBounds_WorldBounds__WorldBoundInit___onInit takes nothing returns nothing
        set s__WorldBounds_world=GetWorldBounds()
        set s__WorldBounds_maxX=R2I(GetRectMaxX(s__WorldBounds_world))
        set s__WorldBounds_maxY=R2I(GetRectMaxY(s__WorldBounds_world))
        set s__WorldBounds_minX=R2I(GetRectMinX(s__WorldBounds_world))
        set s__WorldBounds_minY=R2I(GetRectMinY(s__WorldBounds_world))
        set s__WorldBounds_centerX=R2I(( s__WorldBounds_maxX + s__WorldBounds_minX ) / 2)
        set s__WorldBounds_centerY=R2I(( s__WorldBounds_minY + s__WorldBounds_maxY ) / 2)
        set s__WorldBounds_playMaxX=GetRectMaxX(bj_mapInitialPlayableArea)
        set s__WorldBounds_playMaxY=GetRectMaxY(bj_mapInitialPlayableArea)
        set s__WorldBounds_playMinX=GetRectMinX(bj_mapInitialPlayableArea)
        set s__WorldBounds_playMinY=GetRectMinY(bj_mapInitialPlayableArea)
        set s__WorldBounds_worldRegion=CreateRegion()
        call RegionAddRect(s__WorldBounds_worldRegion, s__WorldBounds_world)
        endfunction
   

//library WorldBounds ends
//library CooldownReduction:

    // Intro
    //     This library intension in to introduce to warcraft an easy way to 
    //     manipulate abilities cooldowns based on a cooldown reduction value that
    //     is unique for each unit.

    // How it Works?
    //     When casting an ability, its "new" cooldown is calculated based on the 
    //     amount of cooldown reduction of the casting unit. the formula for 
    //     calculation is:
    //         Cooldown = (Default Cooldown - Cooldown Offset) * [(1 - source1)*(1 - source2)*...] * (1 - Cooldown Reduction Flat)

    //     The system also allow negative values for CDR, resulting in increased
    //     ability cooldown.

    //     It does not acumulate because the abilities are registered automatically
    //     on the first cast, saving its base cooldown (Object Editor values) and 
    //     always using this base value for calculation, so you can still edit 
    //     the ability via the editor and the system takes care of the rest.

    // How to Import
    //     simply copy the CooldownReduction folder over to your map, and start 
    //     use the API functions

    // Requirements
    //     CooldownReduction requires RegisterPlayerUnitEvent, Alloc and a Unit Indexer.
    //     Credits to Magtheridon96 for RegisterPlayerUnitEvent and to Bribe for
    //     the UnitIndexer. It also requires patch 1.31+.

    //     RegisterPlayerUnitEvent: www.hiveworkshop.com/threads/snippet-registerplayerunitevent.203338/
    //     UnitIndexer: www.hiveworkshop.com/threads/gui-unit-indexer-1-4-0-0.197329/#resource-45899
    //     Alloc: www.hiveworkshop.com/threads/snippet-alloc.192348/
    
    
    
    
    
    // Use this function to filter out units you dont want to have abilities registered.
    // By default dummy units do not trigger the system.
    function CooldownReduction__UnitFilter takes unit source returns boolean
        return GetUnitAbilityLevel(source, 'Aloc') == 0
    endfunction

    function CooldownReduction__AbilityFilter takes integer abilityId returns boolean
        return abilityId != 'A04I'
    endfunction
    
    
    
    
    
//Implemented from module Alloc:
    
        function s__CooldownReduction__AbilityList_allocate takes nothing returns integer
            local integer this
    
            if ( s__CooldownReduction__AbilityList_Alloc___recycle[(0)] == 0 ) then
                set s__CooldownReduction__AbilityList_Alloc___instanceCount=s__CooldownReduction__AbilityList_Alloc___instanceCount + 1
                set this=s__CooldownReduction__AbilityList_Alloc___instanceCount
            else
                set this=s__CooldownReduction__AbilityList_Alloc___recycle[(0)]
                set s__CooldownReduction__AbilityList_Alloc___recycle[(0)]=s__CooldownReduction__AbilityList_Alloc___recycle[s__CooldownReduction__AbilityList_Alloc___recycle[(0)]]
            endif

    
            return this
        endfunction
    
        function s__CooldownReduction__AbilityList_deallocate takes integer this returns nothing
            set s__CooldownReduction__AbilityList_Alloc___recycle[this]=s__CooldownReduction__AbilityList_Alloc___recycle[(0)]
            set s__CooldownReduction__AbilityList_Alloc___recycle[(0)]=this
        endfunction
//Implemented from module CooldownReduction__List:

        function s__CooldownReduction__AbilityList_init takes integer this returns integer
            set s__CooldownReduction__AbilityList_next[this]=this
            set s__CooldownReduction__AbilityList_prev[this]=this

            return this
        endfunction

        function s__CooldownReduction__AbilityList_push takes integer this,integer node returns integer
            set s__CooldownReduction__AbilityList_prev[node]=s__CooldownReduction__AbilityList_prev[this]
            set s__CooldownReduction__AbilityList_next[node]=this
            set s__CooldownReduction__AbilityList_next[s__CooldownReduction__AbilityList_prev[this]]=node
            set s__CooldownReduction__AbilityList_prev[this]=node

            return node
        endfunction

        function s__CooldownReduction__AbilityList_pop takes integer this returns nothing
            set s__CooldownReduction__AbilityList_next[s__CooldownReduction__AbilityList_prev[this]]=s__CooldownReduction__AbilityList_next[this]
            set s__CooldownReduction__AbilityList_prev[s__CooldownReduction__AbilityList_next[this]]=s__CooldownReduction__AbilityList_prev[this]
        endfunction
        
        
        function s__CooldownReduction__AbilityList_destroy takes integer this returns nothing
            local integer node= s__CooldownReduction__AbilityList_next[this]
        
            loop
                exitwhen node == this
                    set s__CooldownReduction__AbilityList_ability[node]=null
                    call s__Table_destroy(s__CooldownReduction__AbilityList_defaults[node])
                    call s__CooldownReduction__AbilityList_pop(node)
                    call s__CooldownReduction__AbilityList_deallocate(node)
                set node=s__CooldownReduction__AbilityList_next[node]
            endloop
            call s__CooldownReduction__AbilityList_deallocate(this)

            set s__CooldownReduction__AbilityList_unit[this]=null
        endfunction
        
        function s__CooldownReduction__AbilityList_insert takes integer this,integer id returns integer
            local integer node= s__CooldownReduction__AbilityList_push(this,s__CooldownReduction__AbilityList_allocate())
            local integer i= 0

            set s__CooldownReduction__AbilityList_id[node]=id
            set s__CooldownReduction__AbilityList_ability[node]=BlzGetUnitAbility(s__CooldownReduction__AbilityList_unit[this], id)
            set s__CooldownReduction__AbilityList_levels[node]=BlzGetAbilityIntegerField(s__CooldownReduction__AbilityList_ability[node], ABILITY_IF_LEVELS)
            set s__CooldownReduction__AbilityList_defaults[node]=s__Table_create()
            
            loop
                exitwhen i >= s__CooldownReduction__AbilityList_levels[node]
                    call SaveReal(Table__ht, (((s__CooldownReduction__AbilityList_defaults[node]))), (i), (( BlzGetAbilityRealLevelField(s__CooldownReduction__AbilityList_ability[node], ABILITY_RLF_COOLDOWN, i))*1.0)) // INLINED!!
                set i=i + 1
            endloop

            return node
        endfunction
        
        function s__CooldownReduction__AbilityList_update takes integer this,integer count,real normal,real flat,real offset returns nothing
            local integer node= s__CooldownReduction__AbilityList_next[this]
            local real cooldown
            local integer i
        
            loop
                exitwhen node == this
                    set i=0
                    loop
                        exitwhen i >= s__CooldownReduction__AbilityList_levels[node]
                            if count > 0 then
                                set cooldown=( ( (LoadReal(Table__ht, (((s__CooldownReduction__AbilityList_defaults[node]))), (i))) - offset ) * normal * ( 1 - flat ) ) // INLINED!!
                            else
                                set cooldown=( ( (LoadReal(Table__ht, (((s__CooldownReduction__AbilityList_defaults[node]))), (i))) - offset ) * ( 1 - flat ) ) // INLINED!!
                            endif
                            call BlzSetAbilityRealLevelField(s__CooldownReduction__AbilityList_ability[node], ABILITY_RLF_COOLDOWN, i, cooldown)
                            call IncUnitAbilityLevel(s__CooldownReduction__AbilityList_unit[this], s__CooldownReduction__AbilityList_id[node])
                            call DecUnitAbilityLevel(s__CooldownReduction__AbilityList_unit[this], s__CooldownReduction__AbilityList_id[node])
                        set i=i + 1
                    endloop
                set node=s__CooldownReduction__AbilityList_next[node]
            endloop
        endfunction
        
        function s__CooldownReduction__AbilityList_calculate takes integer this,integer id,integer level,real cooldown,integer count,real normal,real flat,real offset returns nothing
            if count > 0 then
                call BlzSetAbilityRealLevelField(BlzGetUnitAbility(s__CooldownReduction__AbilityList_unit[this], id), ABILITY_RLF_COOLDOWN, level, ( ( cooldown - offset ) * normal * ( 1 - flat ) ))
            else
                call BlzSetAbilityRealLevelField(BlzGetUnitAbility(s__CooldownReduction__AbilityList_unit[this], id), ABILITY_RLF_COOLDOWN, level, ( ( cooldown - offset ) * ( 1 - flat ) ))
            endif
            call IncUnitAbilityLevel(s__CooldownReduction__AbilityList_unit[this], id)
            call DecUnitAbilityLevel(s__CooldownReduction__AbilityList_unit[this], id)
        endfunction
        
        function s__CooldownReduction__AbilityList_simulate takes integer this,real cooldown,integer count,real normal,real flat,real offset returns real
            local real cd
            
            if count > 0 then
                set cd=( ( cooldown - offset ) * normal * ( 1 - flat ) )
            else
                set cd=( ( cooldown - offset ) * ( 1 - flat ) )
            endif
            
            return cd
        endfunction
        
        function s__CooldownReduction__AbilityList_create takes unit source returns integer
            local integer this= s__CooldownReduction__AbilityList_init((s__CooldownReduction__AbilityList_allocate()))
            
            set s__CooldownReduction__AbilityList_unit[this]=source
            
            return this
        endfunction
    
    
        function s__CDR_getInstance takes unit source returns integer
            local integer i= GetUnitUserData(source)
            
            if s__CDR_n[i] == 0 then
                set s__CDR_n[i]=s__CooldownReduction__AbilityList_create(source)
            endif

            return s__CDR_n[i]
        endfunction
    
        function s__CDR_update takes unit u returns nothing
            local integer id= GetUnitUserData(u)
            local integer list= s__CDR_getInstance(u)

            call s__CooldownReduction__AbilityList_update(list,s__CDR_count[id] , s__CDR_normal[id] , s__CDR_flat[id] , s__CDR_offset[id])
        endfunction
        
        function s__CDR_calculate takes unit u returns real
            local integer idx= GetUnitUserData(u)
            local integer id= GetHandleId(u)
            local integer i= 0
            local real cdr= 0
            local real aux

            loop
                exitwhen i > s__CDR_count[idx]
                    set aux=LoadReal(s__CDR_hashtable, id, i)
                    
                    if i > 0 then
                        set cdr=cdr * ( 1 - aux )
                    else
                        set cdr=1 - aux
                    endif
                set i=i + 1
            endloop

            return cdr
        endfunction
    
        function s__CDR_get takes unit u,integer types returns real
            if types == 0 then
                return s__CDR_normal[GetUnitUserData(u)]
            elseif types == 1 then
                return s__CDR_flat[GetUnitUserData(u)]
            else
                return s__CDR_offset[GetUnitUserData(u)]
            endif
        endfunction

        function s__CDR_Set takes unit u,real value,integer types returns nothing
            if types == 0 then
                set s__CDR_normal[GetUnitUserData(u)]=value
            elseif types == 1 then
                set s__CDR_flat[GetUnitUserData(u)]=value
            else
                set s__CDR_offset[GetUnitUserData(u)]=value
            endif

            call s__CDR_update(u)
        endfunction

        function s__CDR_add takes unit u,real amount returns nothing
            local integer i= GetUnitUserData(u)

            if amount != 0 then
                call SaveReal(s__CDR_hashtable, GetHandleId(u), s__CDR_count[i], amount)
                set s__CDR_normal[i]=s__CDR_calculate(u)
                set s__CDR_count[i]=s__CDR_count[i] + 1
                call s__CDR_update(u)
            endif
        endfunction
        
        function s__CDR_remove takes unit u,real amount returns nothing
            local integer idx= GetUnitUserData(u)
            local integer id= GetHandleId(u)
            local integer i= 0
            local real aux

            if amount == 0 then
                return
            endif

            loop
                exitwhen i > s__CDR_count[idx] - 1
                    set aux=LoadReal(s__CDR_hashtable, id, i)
                    
                    if aux == amount then
                        call RemoveSavedReal(s__CDR_hashtable, id, i)
                        if i != s__CDR_count[idx] - 1 then
                            set aux=LoadReal(s__CDR_hashtable, id, s__CDR_count[idx] - 1)
                            call SaveReal(s__CDR_hashtable, id, i, aux)
                            call RemoveSavedReal(s__CDR_hashtable, id, s__CDR_count[idx] - 1)
                        endif
                        set s__CDR_count[idx]=s__CDR_count[idx] - 1
                        set s__CDR_normal[idx]=s__CDR_calculate(u)
                        set i=s__CDR_count[idx] + 1
                        call s__CDR_update(u)
                    else
                        set i=i + 1
                    endif
            endloop
        endfunction
    
        function s__CDR_calculateCooldown takes unit u,integer id,integer level,real cooldown returns nothing
            local integer i= GetUnitUserData(u)
            local integer list= s__CDR_getInstance(u)

            call s__CooldownReduction__AbilityList_calculate(list,id , level - 1 , cooldown , s__CDR_count[i] , s__CDR_normal[i] , s__CDR_flat[i] , s__CDR_offset[i])
        endfunction
        
        function s__CDR_simulateCooldown takes unit u,real cooldown returns real
            local integer i= GetUnitUserData(u)
            local integer list= s__CDR_getInstance(u)

            return s__CooldownReduction__AbilityList_simulate(list,cooldown , s__CDR_count[i] , s__CDR_normal[i] , s__CDR_flat[i] , s__CDR_offset[i])
        endfunction
    
        function s__CDR_register takes unit u,integer id returns nothing
            local integer list
            local integer i
            
            if (GetUnitAbilityLevel((u), 'Aloc') == 0) and ((id) != 'A04I') then // INLINED!!
                set list=s__CDR_getInstance(u)
                set i=GetUnitUserData(u)
                
                if not LoadBoolean(s__CDR_hashtable, list, id) then
                    call s__CooldownReduction__AbilityList_insert(list,id)
                    call SaveBoolean(s__CDR_hashtable, list, id, true)
                    
                    if s__CDR_count[i] > 0 or s__CDR_normal[i] != 0 or s__CDR_flat[i] != 0 or s__CDR_offset[i] != 0 then
                        call s__CDR_update(u)
                    endif
                endif
            endif
        endfunction
    
        function s__CDR_onCast takes nothing returns nothing
            call s__CDR_register(GetTriggerUnit() , GetSpellAbilityId())
        endfunction
        
        function s__CDR_onLevel takes nothing returns nothing
            call s__CDR_register(GetTriggerUnit() , GetLearnedSkill())
        endfunction
        
        function s__CDR_onDeindex takes nothing returns nothing
            local unit source= udg_UDexUnits[udg_UDex]
            local integer i= GetUnitUserData(source)
            local integer list= s__CDR_getInstance(source)
            
            set s__CDR_n[i]=0
            set s__CDR_normal[i]=0
            set s__CDR_flat[i]=0
            set s__CDR_offset[i]=0
            set s__CDR_count[i]=0

            if list != 0 then
                call s__CooldownReduction__AbilityList_destroy(list)
                call FlushChildHashtable(s__CDR_hashtable, list)
            endif
            call FlushChildHashtable(s__CDR_hashtable, GetHandleId(source))
        endfunction
    
        function s__CDR_onInit takes nothing returns nothing
            local trigger t= CreateTrigger()
            call h__TriggerRegisterVariableEvent(t, "udg_UnitIndexEvent", EQUAL, 2.00)
            call TriggerAddCondition(t, Condition(function s__CDR_onDeindex))
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT , function s__CDR_onCast)
            call RegisterPlayerUnitEvent(EVENT_PLAYER_HERO_SKILL , function s__CDR_onLevel)
        endfunction
    
    
    
    
    function GetUnitCooldownReduction takes unit u returns real
        return 1 - s__CDR_get(u , 0)
    endfunction

    function GetUnitCooldownReductionFlat takes unit u returns real
        return s__CDR_get(u , 1)
    endfunction

    function GetUnitCooldownOffset takes unit u returns real
        return s__CDR_get(u , 2)
    endfunction

    function SetUnitCooldownReduction takes unit u,real value returns nothing
        call s__CDR_Set(u , value , 0)
    endfunction

    function SetUnitCooldownReductionFlat takes unit u,real value returns nothing
        call s__CDR_Set(u , value , 1)
    endfunction

    function SetUnitCooldownOffset takes unit u,real value returns nothing
        call s__CDR_Set(u , value , 2)
    endfunction

    function UnitAddCooldownReduction takes unit u,real value returns nothing
        call s__CDR_add(u , value)
    endfunction

    function UnitAddCooldownReductionFlat takes unit u,real value returns nothing
        call s__CDR_Set(u , s__CDR_get(u , 1) + value , 1)
    endfunction

    function UnitAddCooldownOffset takes unit u,real value returns nothing
        call s__CDR_Set(u , s__CDR_get(u , 2) + value , 2)
    endfunction

    function UnitRemoveCooldownReduction takes unit u,real value returns nothing
        call s__CDR_remove(u , value)
    endfunction

    function CalculateAbilityCooldown takes unit u,integer id,integer level,real cooldown returns nothing
        call s__CDR_calculateCooldown(u , id , level , cooldown)
    endfunction 
    
    function SimulateAbilityCooldown takes unit u,real cooldown returns real
        return s__CDR_simulateCooldown(u , cooldown)
    endfunction 
    
    function RegisterAbility takes unit u,integer id returns nothing
        call s__CDR_register(u , id)
    endfunction

//library CooldownReduction ends
//library DummyRecycler:

  
    //Every time a new dummy unit is retrieved, it will apply this resets
    //If it is redundant/you dont need it, remove it.
// =============================================================== //
// ==================== END CONFIGURATION ======================== //
// =============================================================== //
  
  
  



















  
  
//Implemented from module DummyRecycler__M:
      




      
        function s__DummyRecycler__S_DummyRecycler__M___onInit takes nothing returns nothing
            local real add= 360.0 / DummyRecycler__ANGLES_COUNT
            local real a= 0
            local integer this= DummyRecycler__ANGLES_COUNT
            local integer head= 0
            local integer cHead= JASS_MAX_ARRAY_SIZE - 1
            local integer i= R2I(DummyRecycler__MAX_DUMMY_COUNT / DummyRecycler__ANGLES_COUNT + 0.5)
            set DummyRecycler__upper=DummyRecycler__STORED_UNIT_COUNT
            set DummyRecycler__lower=DummyRecycler__STORED_UNIT_COUNT

                set s__DummyRecycler__S_tb=s__Table_create()

            //Initialize countHeads
            loop
                exitwhen i < 0
                set DummyRecycler__countNext[cHead]=cHead
                set DummyRecycler__countPrev[cHead]=cHead
                set DummyRecycler__countHead[i]=cHead
                set cHead=cHead - 1
                set i=i - 1
            endloop
            set cHead=DummyRecycler__countHead[DummyRecycler__STORED_UNIT_COUNT] //All heads will be inserted here initially
            //Create the Dummy units
            loop
                exitwhen a >= 360
                //Initialize head
                set DummyRecycler__next[head]=head
                set DummyRecycler__prev[head]=head
                set DummyRecycler__count[head]=DummyRecycler__STORED_UNIT_COUNT
                set DummyRecycler__angle[head]=a
                //Insert head in the Count List
                set DummyRecycler__countNext[head]=cHead
                set DummyRecycler__countPrev[head]=DummyRecycler__countPrev[cHead]
                set DummyRecycler__countNext[DummyRecycler__countPrev[head]]=head
                set DummyRecycler__countPrev[DummyRecycler__countNext[head]]=head
                set i=0
                loop
                    exitwhen i >= DummyRecycler__STORED_UNIT_COUNT
                    //Queued Linked List
                    set DummyRecycler__next[this]=head
                    set DummyRecycler__prev[this]=DummyRecycler__prev[head]
                    set DummyRecycler__next[DummyRecycler__prev[this]]=this
                    set DummyRecycler__prev[DummyRecycler__next[this]]=this


                            set DummyRecycler__dummy[this]=CreateUnit(DummyRecycler__OWNER, DummyRecycler__DUMMY_ID, s__WorldBounds_maxX, s__WorldBounds_maxY, a)






                    call PauseUnit(DummyRecycler__dummy[this], true)

                        call SaveInteger(Table__ht, (s__DummyRecycler__S_tb), (GetHandleId(DummyRecycler__dummy[this])), ( this)) // INLINED!!



                    set this=this + 1
                    set i=i + 1
                endloop
                set head=head + 1
                set a=a + add
            endloop
            set DummyRecycler__lastInstance=this
        endfunction
      
  
    function DummyRecycler__GetHead takes integer facing returns integer
        if facing < 0 or facing >= 360 then
            set facing=facing - ( facing / 360 ) * 360
            if facing < 0 then
                set facing=facing + 360
            endif
        endif
        return R2I(( facing * DummyRecycler__ANGLES_COUNT / 360.0 ))
    endfunction
  
    function ShowDummy takes unit u,boolean flag returns nothing
        if IsUnitHidden(u) == flag then
            call ShowUnit(u, flag)
            if flag and GetUnitTypeId(u) == DummyRecycler__DUMMY_ID then
                call UnitRemoveAbility(u, 'Aloc')
                call UnitAddAbility(u, 'Aloc')
            endif
        endif
    endfunction
  
    function GetRecycledDummy takes real x,real y,real z,real facing returns unit
        local integer head= DummyRecycler__GetHead(R2I(facing + DummyRecycler__FACING_OFFSET))
        local integer this= DummyRecycler__next[head]
        local integer cHead
      
        //If there are Dummy Units in the Queue List already facing close to the appropriate angle
        if this != head and RAbsBJ(GetUnitFacing(DummyRecycler__dummy[this]) - DummyRecycler__angle[head]) <= DummyRecycler__ANGLE_TOLERANCE then
            //Remove from the Queue List
            set DummyRecycler__next[DummyRecycler__prev[this]]=DummyRecycler__next[this]
            set DummyRecycler__prev[DummyRecycler__next[this]]=DummyRecycler__prev[this]
            //For double free protection
            set DummyRecycler__next[this]=- 1
            //Unit Properties
            set bj_lastCreatedUnit=DummyRecycler__dummy[this]
            call SetUnitX(bj_lastCreatedUnit, x)
            call SetUnitY(bj_lastCreatedUnit, y)
            call SetUnitFacing(bj_lastCreatedUnit, facing)
            call SetUnitFlyHeight(bj_lastCreatedUnit, z, 0)
//textmacro instance: DUMMY_UNIT_RESET()
        call SetUnitScale(bj_lastCreatedUnit, 1, 0, 0)
        call SetUnitVertexColor(bj_lastCreatedUnit, 255, 255, 255, 255)
        call SetUnitAnimationByIndex(bj_lastCreatedUnit, 90)
        call ShowDummy(bj_lastCreatedUnit , true)
//end of: DUMMY_UNIT_RESET()
            //Update Count and Bounds
            set DummyRecycler__count[head]=DummyRecycler__count[head] - 1
          
            //------------------------------------------------
            //                 Unit Sharing
            //------------------------------------------------
            if DummyRecycler__count[head] < DummyRecycler__BORROW_REQUEST and DummyRecycler__count[DummyRecycler__countNext[DummyRecycler__countHead[DummyRecycler__upper]]] > DummyRecycler__count[head] then
                set DummyRecycler__count[head]=DummyRecycler__count[head] + 1
                set this=DummyRecycler__next[DummyRecycler__countNext[DummyRecycler__countHead[DummyRecycler__upper]]]
                call SetUnitFacing(DummyRecycler__dummy[this], DummyRecycler__angle[head])
                //Remove
                set DummyRecycler__next[DummyRecycler__prev[this]]=DummyRecycler__next[this]
                set DummyRecycler__prev[DummyRecycler__next[this]]=DummyRecycler__prev[this]
                //Add to the Current List
                set DummyRecycler__next[this]=head
                set DummyRecycler__prev[this]=DummyRecycler__prev[head]
                set DummyRecycler__next[DummyRecycler__prev[this]]=this
                set DummyRecycler__prev[DummyRecycler__next[this]]=this
                set head=DummyRecycler__countNext[DummyRecycler__countHead[DummyRecycler__upper]]
                set DummyRecycler__count[head]=DummyRecycler__count[head] - 1
            endif
          
            //---------------------------
            //Update Count Lists
            //---------------------------
            //Remove from the current Count List
            set DummyRecycler__countNext[DummyRecycler__countPrev[head]]=DummyRecycler__countNext[head]
            set DummyRecycler__countPrev[DummyRecycler__countNext[head]]=DummyRecycler__countPrev[head]
            //Add to the new Count List
            set cHead=DummyRecycler__countHead[DummyRecycler__count[head]]
            set DummyRecycler__countNext[head]=cHead
            set DummyRecycler__countPrev[head]=DummyRecycler__countPrev[cHead]
            set DummyRecycler__countNext[DummyRecycler__countPrev[head]]=head
            set DummyRecycler__countPrev[DummyRecycler__countNext[head]]=head
          
            //---------------------------
            //  Update Bounds
            //---------------------------
            set cHead=DummyRecycler__countHead[DummyRecycler__upper]
            if DummyRecycler__countNext[cHead] == cHead then
                set DummyRecycler__upper=DummyRecycler__upper - 1
            endif
            if DummyRecycler__count[head] < DummyRecycler__lower then
                set DummyRecycler__lower=DummyRecycler__count[head]
            endif
        else
            set bj_lastCreatedUnit=CreateUnit(DummyRecycler__OWNER, DummyRecycler__DUMMY_ID, x, y, facing)
            call PauseUnit(bj_lastCreatedUnit, true)
            call SetUnitFlyHeight(bj_lastCreatedUnit, z, 0)
            if DummyRecycler__dummyCount < DummyRecycler__MAX_DUMMY_COUNT then
                set this=DummyRecycler__lastInstance
                //For double free protection
                set DummyRecycler__next[this]=- 1
                set DummyRecycler__dummy[this]=bj_lastCreatedUnit

                    call SaveInteger(Table__ht, (s__DummyRecycler__S_tb), (GetHandleId(bj_lastCreatedUnit)), ( this)) // INLINED!!



                set DummyRecycler__lastInstance=DummyRecycler__lastInstance + 1
            endif
            set DummyRecycler__dummyCount=DummyRecycler__dummyCount + 1
        endif

        return bj_lastCreatedUnit
    endfunction
  
    function RecycleDummy takes unit u returns nothing

            local integer this= (LoadInteger(Table__ht, (s__DummyRecycler__S_tb), (GetHandleId(u)))) // INLINED!!



        local integer head
        local integer cHead
      
        //If the unit is a legit Dummy Unit
        if this > 0 and DummyRecycler__next[this] == - 1 then
            //Find where to insert based on the list having the least number of units
            set head=DummyRecycler__countNext[DummyRecycler__countHead[DummyRecycler__lower]]
            set DummyRecycler__next[this]=head
            set DummyRecycler__prev[this]=DummyRecycler__prev[head]
            set DummyRecycler__next[DummyRecycler__prev[this]]=this
            set DummyRecycler__prev[DummyRecycler__next[this]]=this
            //Update Status
            call SetUnitFacing(u, DummyRecycler__angle[head])
            call PauseUnit(u, true)
            call SetUnitOwner(u, DummyRecycler__OWNER, false)


                    call SetUnitX(u, s__WorldBounds_maxX)
                    call SetUnitY(u, s__WorldBounds_maxY)








            set DummyRecycler__count[head]=DummyRecycler__count[head] + 1
          
            //---------------------------
            //    Update Count Lists
            //---------------------------
            //Remove
            set DummyRecycler__countNext[DummyRecycler__countPrev[head]]=DummyRecycler__countNext[head]
            set DummyRecycler__countPrev[DummyRecycler__countNext[head]]=DummyRecycler__countPrev[head]
            //Add to the new Count List
            set cHead=DummyRecycler__countHead[DummyRecycler__count[head]]
            set DummyRecycler__countNext[head]=cHead
            set DummyRecycler__countPrev[head]=DummyRecycler__countPrev[cHead]
            set DummyRecycler__countNext[DummyRecycler__countPrev[head]]=head
            set DummyRecycler__countPrev[DummyRecycler__countNext[head]]=head
          
            //---------------------------
            //  Update Bounds
            //---------------------------
            set cHead=DummyRecycler__countHead[DummyRecycler__lower]
            if DummyRecycler__countNext[cHead] == cHead then
                set DummyRecycler__lower=DummyRecycler__lower + 1
            endif
            if DummyRecycler__count[head] > DummyRecycler__upper then
                set DummyRecycler__upper=DummyRecycler__count[head]
            endif
        elseif this == 0 then
            call RemoveUnit(u)
        endif
      
    endfunction
  
    function DummyRecycler__Expires takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer id= GetHandleId(t)

            call RecycleDummy((LoadUnitHandle(Table__ht, (((s__DummyRecycler__S_tb))), (id)))) // INLINED!!
            call RemoveSavedHandle(Table__ht, (((s__DummyRecycler__S_tb))), (id)) // INLINED!!




        call DestroyTimer(t)
        set t=null
    endfunction

    function DummyAddRecycleTimer takes unit u,real time returns nothing
        local timer t= CreateTimer()

            call SaveUnitHandle(Table__ht, (((s__DummyRecycler__S_tb))), (GetHandleId(t)), ( u)) // INLINED!!



        call TimerStart(t, time, false, function DummyRecycler__Expires)
        set t=null
    endfunction
  
    function GetRecycledDummyAnyAngle takes real x,real y,real z returns unit
        return GetRecycledDummy(x , y , z , DummyRecycler__angle[DummyRecycler__countNext[DummyRecycler__countHead[DummyRecycler__upper]]])
    endfunction

    function GetDummyFacingTarget takes unit u returns unit
        local real facing= GetRandomReal(0, bj_PI * 2)
        local real x= GetUnitX(u) + 50 * Cos(facing + bj_PI)
        local real y= GetUnitY(u) + 50 * Sin(facing + bj_PI)
        return GetRecycledDummy(x , y , 0 , facing)
    endfunction
  
    // runtextmacro DUMMY_DEBUG_TOOLS()
  

//library DummyRecycler ends
//library ExtendableBonusesBasicBonuses:
    

    
    
    

    //===== Integer Ability Based =====
        function s__BonusDamage_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__DAMAGE_ABILITY
        endfunction
        function s__BonusDamage_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__DAMAGE_FIELD
        endfunction
        function s__BonusDamage_onInit takes nothing returns nothing
            set BONUS_DAMAGE=s__ExtendableBonus_Register(s__BonusDamage__allocate())
        endfunction
        function s__BonusArmor_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__ARMOR_ABILITY
        endfunction
        function s__BonusArmor_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__ARMOR_FIELD
        endfunction
        function s__BonusArmor_onInit takes nothing returns nothing
            set BONUS_ARMOR=s__ExtendableBonus_Register(s__BonusArmor__allocate())
        endfunction

    
        function s__BonusMovementSpeed_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__MOVEMENTSPEED_ABILITY
        endfunction
        function s__BonusMovementSpeed_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__MOVEMENTSPEED_FIELD
        endfunction
        function s__BonusMovementSpeed_onInit takes nothing returns nothing
            set BONUS_MOVEMENT_SPEED=s__ExtendableBonus_Register(s__BonusMovementSpeed__allocate())
        endfunction
        function s__BonusSightRange_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__SIGHT_RANGE_ABILITY
        endfunction
        function s__BonusSightRange_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__SIGHT_RANGE_FIELD
        endfunction
        function s__BonusSightRange_onInit takes nothing returns nothing
            set BONUS_SIGHT_RANGE=s__ExtendableBonus_Register(s__BonusSightRange__allocate())
        endfunction
    //Hero stats
        function s__BonusAgility_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
        endfunction
        function s__BonusAgility_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__AGILITY_FIELD
        endfunction
        function s__BonusAgility_onInit takes nothing returns nothing
            set BONUS_AGILITY=s__ExtendableBonus_Register(s__BonusAgility__allocate())
        endfunction
        function s__BonusStrength_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
        endfunction
        function s__BonusStrength_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__STRENGTH_FIELD
        endfunction
        function s__BonusStrength_onInit takes nothing returns nothing
            set BONUS_STRENGTH=s__ExtendableBonus_Register(s__BonusStrength__allocate())
        endfunction
        function s__BonusIntelligence_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__STATS_ABILITY
        endfunction
        function s__BonusIntelligence_Field takes integer this returns abilityintegerlevelfield
            return ExtendableBonusesBasicBonuses__INTELLIGENCE_FIELD
        endfunction
        function s__BonusIntelligence_onInit takes nothing returns nothing
            set BONUS_INTELLIGENCE=s__ExtendableBonus_Register(s__BonusIntelligence__allocate())
        endfunction

    //===== Real Ability Based =====
        function s__BonusAttackSpeed_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__ATTACKSPEED_ABILITY
        endfunction
        function s__BonusAttackSpeed_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__ATTACKSPEED_FIELD
        endfunction
        function s__BonusAttackSpeed_onInit takes nothing returns nothing
            set BONUS_ATTACK_SPEED=s__ExtendableBonus_Register(s__BonusAttackSpeed__allocate())
        endfunction
        function s__BonusHealthRegen_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__HEALTHREGEN_ABILITY
        endfunction
        function s__BonusHealthRegen_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__HEALTHREGEN_FIELD
        endfunction
        function s__BonusHealthRegen_onInit takes nothing returns nothing
            set BONUS_HEALTH_REGEN=s__ExtendableBonus_Register(s__BonusHealthRegen__allocate())
        endfunction
        function s__BonusManaRegen_AbilityCode takes integer this returns integer
            return ExtendableBonusesBasicBonuses__MANAREGEN_ABILITY
        endfunction
        function s__BonusManaRegen_Field takes integer this returns abilityreallevelfield
            return ExtendableBonusesBasicBonuses__MANAREGEN_FIELD
        endfunction
        function s__BonusManaRegen_onInit takes nothing returns nothing
            set BONUS_MANA_REGEN=s__ExtendableBonus_Register(s__BonusManaRegen__allocate())
        endfunction

    //===== Custom handled =====
    //I just copy pasted 
        function s__BonusHealth_IsIntegerBonus takes integer this returns boolean
            return true
        endfunction
        function s__BonusHealth_Get takes integer this,unit u returns real
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY), ExtendableBonusesBasicBonuses__HEALTH_FIELD, 0))
        endfunction
        function s__BonusHealth_Set takes integer this,unit u,real value returns real
            local real p= GetUnitLifePercent(u)
            local integer amount= R2I(value)
            call BlzSetUnitMaxHP(u, ( BlzGetUnitMaxHP(u) + amount - BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY), ExtendableBonusesBasicBonuses__HEALTH_FIELD, 0) ))
            call SetUnitLifePercentBJ(u, p)

            if GetUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY) == 0 then
                call UnitAddAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY)
                call UnitMakeAbilityPermanent(u, true, ExtendableBonusesBasicBonuses__HEALTH_ABILITY)
            endif
        
            if BlzSetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY), ExtendableBonusesBasicBonuses__HEALTH_FIELD, 0, amount) then
                call IncUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY)
                call DecUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY)
            endif

            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__HEALTH_ABILITY), ExtendableBonusesBasicBonuses__HEALTH_FIELD, 0))
        endfunction
        function s__BonusHealth_onInit takes nothing returns nothing
            set BONUS_HEALTH=s__ExtendableBonus_Register(s__BonusHealth__allocate())
        endfunction
        function s__BonusMana_IsIntegerBonus takes integer this returns boolean
            return true
        endfunction
        function s__BonusMana_Get takes integer this,unit u returns real
            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY), ExtendableBonusesBasicBonuses__MANA_FIELD, 0))
        endfunction
        function s__BonusMana_Set takes integer this,unit u,real value returns real
            local real p= GetUnitManaPercent(u)
            local integer amount= R2I(value)
            call BlzSetUnitMaxMana(u, ( BlzGetUnitMaxMana(u) + amount - BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY), ExtendableBonusesBasicBonuses__MANA_FIELD, 0) ))
            call SetUnitManaPercentBJ(u, p)

            if GetUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__MANA_ABILITY) == 0 then
                call UnitAddAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY)
                call UnitMakeAbilityPermanent(u, true, ExtendableBonusesBasicBonuses__MANA_ABILITY)
            endif
        
            if BlzSetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY), ExtendableBonusesBasicBonuses__MANA_FIELD, 0, amount) then
                call IncUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__MANA_ABILITY)
                call DecUnitAbilityLevel(u, ExtendableBonusesBasicBonuses__MANA_ABILITY)
            endif

            return I2R(BlzGetAbilityIntegerLevelField(BlzGetUnitAbility(u, ExtendableBonusesBasicBonuses__MANA_ABILITY), ExtendableBonusesBasicBonuses__MANA_FIELD, 0))
        endfunction
        function s__BonusMana_onInit takes nothing returns nothing
            set BONUS_MANA=s__ExtendableBonus_Register(s__BonusMana__allocate())
        endfunction

//library ExtendableBonusesBasicBonuses ends
//library MissileEffect:
    
    // This is a simple helper library for the Relativistic Missiles system.
    // Credits:
    //     Sevion for the Alloc module
    //         - www.hiveworkshop.com/threads/snippet-alloc.192348/
    //     Nestharus for World Bounds Library
    
    
    
    
    

//Implemented from module MissileEffect__LinkedList:

        function s__MissileEffect__Effect_init takes integer this returns integer
            set s__MissileEffect__Effect_next[this]=this
            set s__MissileEffect__Effect_prev[this]=this

            return this
        endfunction

        function s__MissileEffect__Effect_pushBack takes integer this,integer node returns integer
            set s__MissileEffect__Effect_prev[node]=s__MissileEffect__Effect_prev[this]
            set s__MissileEffect__Effect_next[node]=this
            set s__MissileEffect__Effect_next[s__MissileEffect__Effect_prev[this]]=node
            set s__MissileEffect__Effect_prev[this]=node

            return node
        endfunction

        function s__MissileEffect__Effect_pushFront takes integer this,integer node returns integer
            set s__MissileEffect__Effect_prev[node]=this
            set s__MissileEffect__Effect_next[node]=s__MissileEffect__Effect_next[this]
            set s__MissileEffect__Effect_prev[s__MissileEffect__Effect_next[this]]=node
            set s__MissileEffect__Effect_next[this]=node

            return node
        endfunction

        function s__MissileEffect__Effect_pop takes integer this returns nothing
            set s__MissileEffect__Effect_next[s__MissileEffect__Effect_prev[this]]=s__MissileEffect__Effect_next[this]
            set s__MissileEffect__Effect_prev[s__MissileEffect__Effect_next[this]]=s__MissileEffect__Effect_prev[this]
        endfunction
//Implemented from module Alloc:
    
        function s__MissileEffect__Effect_allocate takes nothing returns integer
            local integer this
    
            if ( s__MissileEffect__Effect_Alloc___recycle[(0)] == 0 ) then
                set s__MissileEffect__Effect_Alloc___instanceCount=s__MissileEffect__Effect_Alloc___instanceCount + 1
                set this=s__MissileEffect__Effect_Alloc___instanceCount
            else
                set this=s__MissileEffect__Effect_Alloc___recycle[(0)]
                set s__MissileEffect__Effect_Alloc___recycle[(0)]=s__MissileEffect__Effect_Alloc___recycle[s__MissileEffect__Effect_Alloc___recycle[(0)]]
            endif

    
            return this
        endfunction
    
        function s__MissileEffect__Effect_deallocate takes integer this returns nothing
            set s__MissileEffect__Effect_Alloc___recycle[this]=s__MissileEffect__Effect_Alloc___recycle[(0)]
            set s__MissileEffect__Effect_Alloc___recycle[(0)]=this
        endfunction


        function s__MissileEffect__Effect_remove takes integer this returns nothing
            call DestroyEffect(s__MissileEffect__Effect_effect[this])
            call s__MissileEffect__Effect_pop(this)
            call s__MissileEffect__Effect_deallocate(this)
            set s__MissileEffect__Effect_effect[this]=null
        endfunction

        function s__MissileEffect__Effect_insert takes integer this,string fxpath,real x,real y,real z,real scale returns integer
            local integer node= s__MissileEffect__Effect_pushBack(this,s__MissileEffect__Effect_allocate())

            set s__MissileEffect__Effect_x[node]=x
            set s__MissileEffect__Effect_y[node]=y
            set s__MissileEffect__Effect_z[node]=z
            set s__MissileEffect__Effect_yaw[node]=0.
            set s__MissileEffect__Effect_pitch[node]=0.
            set s__MissileEffect__Effect_roll[node]=0.
            set s__MissileEffect__Effect_path[node]=fxpath
            set s__MissileEffect__Effect_size[node]=scale
            set s__MissileEffect__Effect_effect[node]=AddSpecialEffect(fxpath, x, y)
            call BlzSetSpecialEffectZ(s__MissileEffect__Effect_effect[node], z)
            call BlzSetSpecialEffectScale(s__MissileEffect__Effect_effect[node], scale)

            return node
        endfunction

        function s__MissileEffect__Effect_create takes nothing returns integer
            return s__MissileEffect__Effect_init((s__MissileEffect__Effect_allocate()))
        endfunction


        
        function s__MissileEffect__set_timeScale takes integer this,real newTimeScale returns nothing
            set s__MissileEffect_time[this]=newTimeScale
            call BlzSetSpecialEffectTimeScale(s__MissileEffect_effect[this], s__MissileEffect_time[this])
        endfunction
        
        function s__MissileEffect__get_timeScale takes integer this returns real
            return s__MissileEffect_time[this]
        endfunction

        function s__MissileEffect__set_alpha takes integer this,integer newAlpha returns nothing
            set s__MissileEffect_transparency[this]=newAlpha
            call BlzSetSpecialEffectAlpha(s__MissileEffect_effect[this], s__MissileEffect_transparency[this])
        endfunction

        function s__MissileEffect__get_alpha takes integer this returns integer
            return s__MissileEffect_transparency[this]
        endfunction

        function s__MissileEffect__set_playerColor takes integer this,integer playerId returns nothing
            set s__MissileEffect_playercolor[this]=playerId
            call BlzSetSpecialEffectColorByPlayer(s__MissileEffect_effect[this], Player(playerId))
        endfunction

        function s__MissileEffect__get_playerColor takes integer this returns integer
            return s__MissileEffect_playercolor[this]
        endfunction

        function s__MissileEffect__set_animation takes integer this,integer animType returns nothing
            set s__MissileEffect_animtype[this]=animType
            call BlzPlaySpecialEffect(s__MissileEffect_effect[this], ConvertAnimType(s__MissileEffect_animtype[this]))
        endfunction

        function s__MissileEffect__get_animation takes integer this returns integer
            return s__MissileEffect_animtype[this]
        endfunction

        
        function s__MissileEffect_scale takes integer this,effect sfx,real scale returns nothing
            set s__MissileEffect_size[this]=scale
            call BlzSetSpecialEffectScale(sfx, scale)
        endfunction   

        function s__MissileEffect_orient takes integer this,real yaw,real pitch,real roll returns nothing
            local integer node= s__MissileEffect__Effect_next[s__MissileEffect_attachments[this]]

            set s__MissileEffect_yaw[this]=yaw
            set s__MissileEffect_pitch[this]=pitch
            set s__MissileEffect_roll[this]=roll
            call BlzSetSpecialEffectOrientation(s__MissileEffect_effect[this], yaw, pitch, roll)

            loop
                exitwhen node == s__MissileEffect_attachments[this]
                    set s__MissileEffect__Effect_yaw[node]=yaw
                    set s__MissileEffect__Effect_pitch[node]=pitch
                    set s__MissileEffect__Effect_roll[node]=roll
                    call BlzSetSpecialEffectOrientation(s__MissileEffect__Effect_effect[node], yaw, pitch, roll)
                set node=s__MissileEffect__Effect_next[node]
            endloop
        endfunction

        function s__MissileEffect_move takes integer this,real x,real y,real z returns boolean
            local integer node= s__MissileEffect__Effect_next[s__MissileEffect_attachments[this]]

            if not ( x > s__WorldBounds_maxX or x < s__WorldBounds_minX or y > s__WorldBounds_maxY or y < s__WorldBounds_minY ) then
                call BlzSetSpecialEffectPosition(s__MissileEffect_effect[this], x, y, z)
                loop
                    exitwhen node == s__MissileEffect_attachments[this]
                        call BlzSetSpecialEffectPosition(s__MissileEffect__Effect_effect[node], x - s__MissileEffect__Effect_x[node], y - s__MissileEffect__Effect_y[node], z - s__MissileEffect__Effect_z[node])
                    set node=s__MissileEffect__Effect_next[node]
                endloop
                return true
            endif
            return false
        endfunction

        function s__MissileEffect_attach takes integer this,string fxpath,real dx,real dy,real dz,real scale returns effect
            local integer node= s__MissileEffect__Effect_insert(s__MissileEffect_attachments[this],fxpath , dx , dy , dz , scale)

            call BlzSetSpecialEffectPosition(s__MissileEffect__Effect_effect[node], BlzGetLocalSpecialEffectX(s__MissileEffect_effect[this]) - dx, BlzGetLocalSpecialEffectY(s__MissileEffect_effect[this]) - dy, BlzGetLocalSpecialEffectZ(s__MissileEffect_effect[this]) - dz)

            return s__MissileEffect__Effect_effect[node]
        endfunction

        function s__MissileEffect_detach takes integer this,effect sfx returns nothing
            local integer node= s__MissileEffect__Effect_next[s__MissileEffect_attachments[this]]

            loop
                exitwhen node == s__MissileEffect_attachments[this]
                    if GetHandleId(s__MissileEffect__Effect_effect[node]) == GetHandleId(sfx) then
                        call s__MissileEffect__Effect_remove(node)
                        exitwhen true
                    endif
                set node=s__MissileEffect__Effect_next[node]
            endloop
        endfunction

        function s__MissileEffect_setColor takes integer this,integer red,integer green,integer blue returns nothing
            call BlzSetSpecialEffectColor(s__MissileEffect_effect[this], red, green, blue)
        endfunction

        
        function s__MissileEffect_destroy takes integer this returns nothing
            local integer node= s__MissileEffect__Effect_next[s__MissileEffect_attachments[this]]

            loop
                exitwhen node == s__MissileEffect_attachments[this]
                    call s__MissileEffect__Effect_remove(node)
                set node=s__MissileEffect__Effect_next[node]
            endloop
            call DestroyEffect(s__MissileEffect_effect[this])
            call s__MissileEffect__Effect_deallocate(s__MissileEffect_attachments[this])
            
            set s__MissileEffect_effect[this]=null
            set s__MissileEffect_path[this]=null
            set s__MissileEffect_size[this]=1.
            call s__MissileEffect_deallocate(this)
        endfunction

        function s__MissileEffect_create takes real x,real y,real z returns integer
            local integer this= s__MissileEffect__allocate()

            set s__MissileEffect_effect[this]=AddSpecialEffect("", x, y)
            set s__MissileEffect_path[this]=""
            set s__MissileEffect_size[this]=1
            set s__MissileEffect_time[this]=0
            set s__MissileEffect_transparency[this]=0
            set s__MissileEffect_animtype[this]=0
            set s__MissileEffect_playercolor[this]=0
            set s__MissileEffect_attachments[this]=(s__MissileEffect__Effect_init((s__MissileEffect__Effect_allocate()))) // INLINED!!
            call BlzSetSpecialEffectZ(s__MissileEffect_effect[this], z)

            return this
        endfunction

//library MissileEffect ends
//library MouseUtilsLockCamExtension:

        function s__LockCamExtension_get takes player p returns integer
            return (GetPlayerId(p))
        endfunction
        function s__LockCamExtension_onMouseMovement takes nothing returns nothing
            local player p= GetTriggerPlayer()
            local integer this= (GetPlayerId((p))) // INLINED!!
            set s__LockCamExtension_relativeX[this]=(s__UserMouse_mouseX[s__UserMouse__staticgetindex((p))]) - GetUnitX(s__LockCamExtension_u[this]) // INLINED!!
            set s__LockCamExtension_relativeY[this]=(s__UserMouse_mouseY[s__UserMouse__staticgetindex((p))]) - GetUnitY(s__LockCamExtension_u[this]) // INLINED!!
            //call BJDebugMsg("OnMouseMovement: " + I2S(GetPlayerId(p)) + ", this=" + I2S(this) + ", x=" + R2S(.relativeX))

            set p=null
        endfunction

        function s__LockCamExtension_registerUnit takes unit u returns nothing
            local integer this= (GetPlayerId((GetOwningPlayer(u)))) // INLINED!!
            //call BJDebugMsg("Registering for: " + I2S(GetPlayerId(GetOwningPlayer(u))) + ", " + GetUnitName(u))
            set s__LockCamExtension_u[this]=u
        endfunction

        function s__LockCamExtension_mx takes integer this returns real
            return GetUnitX(s__LockCamExtension_u[this]) + s__LockCamExtension_relativeX[this]
        endfunction
        function s__LockCamExtension_my takes integer this returns real
            return GetUnitY(s__LockCamExtension_u[this]) + s__LockCamExtension_relativeY[this]
        endfunction

    function registerLockCamUnit takes unit u returns nothing
        call s__LockCamExtension_registerUnit(u)
    endfunction
    function initLockCamExtension takes nothing returns nothing
        call s__UserMouse_registerCode(function s__LockCamExtension_onMouseMovement , EVENT_MOUSE_MOVE)
    endfunction
    function GetMouseX takes player p returns real
        //call BJDebugMsg("GetMouseX: " + I2S(GetPlayerId(p)))
        return s__LockCamExtension_mx((GetPlayerId((p)))) // INLINED!!
    endfunction
    function GetMouseY takes player p returns real
        return s__LockCamExtension_my((GetPlayerId((p)))) // INLINED!!
    endfunction

//library MouseUtilsLockCamExtension ends
//library NewBonusUtils:
    
    
    
    
    
    

        


        function s__NewBonusUtils__NewBonusUtils_remove takes integer this,integer i,boolean isItem returns integer
call s__ExtendableBonus_Add((s__NewBonusUtils__NewBonusUtils_unit[this] ) , ( s__NewBonusUtils__NewBonusUtils_type[this] ) , (( - s__NewBonusUtils__NewBonusUtils_amount[this])*1.0)) // INLINED!!

            if isItem then
                set s__NewBonusUtils__NewBonusUtils_items[i]=s__NewBonusUtils__NewBonusUtils_items[s__NewBonusUtils__NewBonusUtils_k]
                set s__NewBonusUtils__NewBonusUtils_k=s__NewBonusUtils__NewBonusUtils_k - 1
            else
                set s__NewBonusUtils__NewBonusUtils_array[i]=s__NewBonusUtils__NewBonusUtils_array[s__NewBonusUtils__NewBonusUtils_key]
                set s__NewBonusUtils__NewBonusUtils_key=s__NewBonusUtils__NewBonusUtils_key - 1

                if s__NewBonusUtils__NewBonusUtils_key == - 1 then
                    call PauseTimer(s__NewBonusUtils__NewBonusUtils_timer)
                endif
            endif

            set s__NewBonusUtils__NewBonusUtils_unit[this]=null
            set s__NewBonusUtils__NewBonusUtils_item[this]=null
            
            call s__NewBonusUtils__NewBonusUtils_deallocate(this)

            return i - 1
        endfunction

        function s__NewBonusUtils__NewBonusUtils_removeBonusTypeForItem takes item itm,integer bonusToRemove returns nothing
            local integer i= 0
            local integer this

            loop
                exitwhen i > s__NewBonusUtils__NewBonusUtils_k
                    set this=s__NewBonusUtils__NewBonusUtils_items[i]

                    if s__NewBonusUtils__NewBonusUtils_item[this] == itm and s__NewBonusUtils__NewBonusUtils_type[this] == bonusToRemove then
                        set i=s__NewBonusUtils__NewBonusUtils_remove(this,i , true)
                    endif
                set i=i + 1
            endloop
        endfunction

        function s__NewBonusUtils__NewBonusUtils_onDrop takes nothing returns nothing
            local item itm= GetManipulatedItem()
            local integer i= 0
            local integer this

            loop
                exitwhen i > s__NewBonusUtils__NewBonusUtils_k
                    set this=s__NewBonusUtils__NewBonusUtils_items[i]

                    if s__NewBonusUtils__NewBonusUtils_item[this] == itm then
                        set i=s__NewBonusUtils__NewBonusUtils_remove(this,i , true)
                    endif
                set i=i + 1
            endloop
        endfunction
     
        function s__NewBonusUtils__NewBonusUtils_onPeriod takes nothing returns nothing
            local integer i= 0
            local integer this

            loop
                exitwhen i > s__NewBonusUtils__NewBonusUtils_key
                    set this=s__NewBonusUtils__NewBonusUtils_array[i]

                    if s__NewBonusUtils__NewBonusUtils_link[this] then
                        set s__NewBonusUtils__NewBonusUtils_ticks[this]=s__NewBonusUtils__NewBonusUtils_ticks[this] - 1

                        if s__NewBonusUtils__NewBonusUtils_ticks[this] <= 0 then
                            set i=s__NewBonusUtils__NewBonusUtils_remove(this,i , false)
                        endif
                    else
                        if GetUnitAbilityLevel(s__NewBonusUtils__NewBonusUtils_unit[this], s__NewBonusUtils__NewBonusUtils_buff[this]) == 0 then
                            set i=s__NewBonusUtils__NewBonusUtils_remove(this,i , false)
                        endif
                    endif
                set i=i + 1
            endloop
        endfunction

        function s__NewBonusUtils__NewBonusUtils_linkTimed takes unit u,integer bonus_type,real amount,real duration,boolean link returns nothing
            local integer this= s__NewBonusUtils__NewBonusUtils__allocate()

            set s__NewBonusUtils__NewBonusUtils_unit[this]=u
            set s__NewBonusUtils__NewBonusUtils_type[this]=bonus_type
            set s__NewBonusUtils__NewBonusUtils_ticks[this]=duration / 0.03125000
            set s__NewBonusUtils__NewBonusUtils_link[this]=link
            set s__NewBonusUtils__NewBonusUtils_amount[this]=(s__ExtendableBonus_Add((u ) , ( bonus_type ) , (( amount)*1.0))) // INLINED!!
            set s__NewBonusUtils__NewBonusUtils_key=s__NewBonusUtils__NewBonusUtils_key + 1
            set s__NewBonusUtils__NewBonusUtils_array[s__NewBonusUtils__NewBonusUtils_key]=this
         
            if s__NewBonusUtils__NewBonusUtils_key == 0 then
                call TimerStart(s__NewBonusUtils__NewBonusUtils_timer, 0.03125000, true, function s__NewBonusUtils__NewBonusUtils_onPeriod)
            endif
        endfunction

        function s__NewBonusUtils__NewBonusUtils_linkBuff takes unit u,integer bonus_type,real amount,integer buffId,boolean link returns nothing
            local integer this= s__NewBonusUtils__NewBonusUtils__allocate()

            set s__NewBonusUtils__NewBonusUtils_unit[this]=u
            set s__NewBonusUtils__NewBonusUtils_type[this]=bonus_type
            set s__NewBonusUtils__NewBonusUtils_buff[this]=buffId
            set s__NewBonusUtils__NewBonusUtils_link[this]=link
            set s__NewBonusUtils__NewBonusUtils_amount[this]=(s__ExtendableBonus_Add((u ) , ( bonus_type ) , (( amount)*1.0))) // INLINED!!
            set s__NewBonusUtils__NewBonusUtils_key=s__NewBonusUtils__NewBonusUtils_key + 1
            set s__NewBonusUtils__NewBonusUtils_array[s__NewBonusUtils__NewBonusUtils_key]=this
         
            if s__NewBonusUtils__NewBonusUtils_key == 0 then
                call TimerStart(s__NewBonusUtils__NewBonusUtils_timer, 0.03125000, true, function s__NewBonusUtils__NewBonusUtils_onPeriod)
            endif
        endfunction

        function s__NewBonusUtils__NewBonusUtils_linkItem takes unit u,integer bonus_type,real amount,item i returns nothing
            local integer this= s__NewBonusUtils__NewBonusUtils__allocate()

            set s__NewBonusUtils__NewBonusUtils_unit[this]=u
            set s__NewBonusUtils__NewBonusUtils_item[this]=i
            set s__NewBonusUtils__NewBonusUtils_type[this]=bonus_type
            set s__NewBonusUtils__NewBonusUtils_amount[this]=(s__ExtendableBonus_Add((u ) , ( bonus_type ) , (( amount)*1.0))) // INLINED!!
            set s__NewBonusUtils__NewBonusUtils_k=s__NewBonusUtils__NewBonusUtils_k + 1
            set s__NewBonusUtils__NewBonusUtils_items[s__NewBonusUtils__NewBonusUtils_k]=this
        endfunction

        function s__NewBonusUtils__NewBonusUtils_copy takes unit source,unit target returns nothing
            local integer i= 1

            loop
                exitwhen i > 17
                    if (s__ExtendableBonus_Get((source ) , ( i))) != 0 then // INLINED!!
call s__ExtendableBonus_Add((target ) , ( i ) , (( (s__ExtendableBonus_Get((source ) , ( i))))*1.0)) // INLINED!!
                    endif
                set i=i + 1
            endloop
        endfunction

        function s__NewBonusUtils__NewBonusUtils_mirror takes unit source,unit target returns nothing
            local integer i= 1

            loop
                exitwhen i > 17
call s__ExtendableBonus_Set((target ) , ( i ) , (( (s__ExtendableBonus_Get((source ) , ( i))))*1.0)) // INLINED!!
                set i=i + 1
            endloop
        endfunction

        function s__NewBonusUtils__NewBonusUtils_onInit takes nothing returns nothing
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM , function s__NewBonusUtils__NewBonusUtils_onDrop)
        endfunction

    
    
    
    function AddUnitBonusTimed takes unit u,integer bonus_type,real amount,real duration returns nothing
        call s__NewBonusUtils__NewBonusUtils_linkTimed(u , bonus_type , amount , duration , true)
    endfunction

    function LinkBonusToBuff takes unit u,integer bonus_type,real amount,integer buffId returns nothing
        call s__NewBonusUtils__NewBonusUtils_linkBuff(u , bonus_type , amount , buffId , false)
    endfunction

    function LinkBonusToItem takes unit u,integer bonus_type,real amount,item i returns nothing
        call s__NewBonusUtils__NewBonusUtils_linkItem(u , bonus_type , amount , i)
    endfunction

    function RemoveSpecificBonusFromItem takes item i,integer bonus_type returns nothing
        call s__NewBonusUtils__NewBonusUtils_removeBonusTypeForItem(i , bonus_type)
    endfunction

    function UnitCopyBonuses takes unit source,unit target returns nothing
        call s__NewBonusUtils__NewBonusUtils_copy(source , target)
    endfunction

    function UnitMirrorBonuses takes unit source,unit target returns nothing
        call s__NewBonusUtils__NewBonusUtils_mirror(source , target)
    endfunction

//library NewBonusUtils ends
//library SimpleDelayedDestroyer:
//--------------- Effect ------------

        function s__EffectDestroyer_destroy takes integer this returns nothing
            call DestroyEffect(s__EffectDestroyer_effect[this])
            set s__EffectDestroyer_effect[this]=null
            call s__EffectDestroyer_deallocate(this)
        endfunction

        function s__EffectDestroyer_destroyFromTimer takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            call s__EffectDestroyer_destroy(this)
            call ReleaseTimer(t)
            set t=null
        endfunction

        function s__EffectDestroyer_destroyLater takes effect e,real delay returns nothing
            local integer this= s__EffectDestroyer__allocate()
            local timer t= NewTimerEx(this)
            call TimerStart(t, delay, false, function s__EffectDestroyer_destroyFromTimer)
            set s__EffectDestroyer_effect[this]=e
            set t=null
        endfunction

    function DestroyEffectLater takes effect e,real delay returns nothing
        call s__EffectDestroyer_destroyLater(e , delay)
    endfunction

    function DestroyLastCreatedEffectLater takes real delay returns nothing
        call s__EffectDestroyer_destroyLater(bj_lastCreatedEffect , delay)
    endfunction
//--------------- Lightning ------------

        function s__LightningDestroyer_destroy takes integer this returns nothing
            call DestroyLightning(s__LightningDestroyer_effect[this])
            set s__LightningDestroyer_effect[this]=null
            call s__LightningDestroyer_deallocate(this)
        endfunction

        function s__LightningDestroyer_destroyFromTimer takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            call s__LightningDestroyer_destroy(this)
            call ReleaseTimer(t)
            set t=null
        endfunction

        function s__LightningDestroyer_destroyLater takes lightning e,real delay returns nothing
            local integer this= s__LightningDestroyer__allocate()
            local timer t= NewTimerEx(this)
            call TimerStart(t, delay, false, function s__LightningDestroyer_destroyFromTimer)
            set s__LightningDestroyer_effect[this]=e
            set t=null
        endfunction

    function DestroyLightningLater takes lightning e,real delay returns nothing
        call s__LightningDestroyer_destroyLater(e , delay)
    endfunction

//--------------- Item ------------


        function s__ItemDestroyer_destroy takes integer this returns nothing
            call RemoveItem(s__ItemDestroyer_itemToDestroy[this])
            set s__ItemDestroyer_itemToDestroy[this]=null
            call s__ItemDestroyer_deallocate(this)
        endfunction

        function s__ItemDestroyer_destroyFromTimer takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            call s__ItemDestroyer_destroy(this)
            call ReleaseTimer(t)
            set t=null
        endfunction

        function s__ItemDestroyer_destroyLater takes item i,real delay returns nothing
            local integer this= s__ItemDestroyer__allocate()
            local timer t= NewTimerEx(this)
            call TimerStart(t, delay, false, function s__ItemDestroyer_destroyFromTimer)
            set s__ItemDestroyer_itemToDestroy[this]=i
            set t=null
        endfunction

    function DestroyItemLater takes item i,real delay returns nothing
        call s__ItemDestroyer_destroyLater(i , delay)
    endfunction

    function DestroyLastCreatedItemLater takes real delay returns nothing
        call s__ItemDestroyer_destroyLater(bj_lastCreatedItem , delay)
    endfunction

//library SimpleDelayedDestroyer ends
//library SpellEffectEvent:
 
//============================================================================
 
//============================================================================
//Implemented from module SpellEffectEvent__M:
   




   
    function s__SpellEffectEvent__S_onCast takes nothing returns nothing

            call TriggerEvaluate((LoadTriggerHandle(Table__ht, (((s__SpellEffectEvent__S_tb))), (GetSpellAbilityId())))) // INLINED!!



    endfunction
 
    function s__SpellEffectEvent__S_SpellEffectEvent__M___onInit takes nothing returns nothing

            set s__SpellEffectEvent__S_tb=s__Table_create()

        call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT , function s__SpellEffectEvent__S_onCast)
    endfunction
 
//============================================================================
function RegisterSpellEffectEvent takes integer abil,code onCast returns nothing

        if not (HaveSavedHandle(Table__ht, (((s__SpellEffectEvent__S_tb))), (abil))) then // INLINED!!
            call SaveTriggerHandle(Table__ht, (((s__SpellEffectEvent__S_tb))), (abil), ( CreateTrigger())) // INLINED!!
        endif
        call TriggerAddCondition((LoadTriggerHandle(Table__ht, (((s__SpellEffectEvent__S_tb))), (abil))), Filter(onCast)) // INLINED!!






endfunction
 

//library SpellEffectEvent ends
//library CooldownReductionUtils:
    
    // Intro
    //     Utility Library that include a few extra functions to deal with 
    //     Cooldown Reduction

    // JASS API
    //     function UnitAddCooldownReductionTimed takes unit u, real value, real duration returns nothing
    //         -> Add to the amount of cdr of a unit for a given duration. Accepts positive and negative values. 
    //         -> It handles removing the bonus automatically
    
    //     function UnitAddCooldownReductionFlatTimed takes unit u, real value, real duration returns nothing
    //         -> Add to the amount of cdr flat of a unit for a given period. Accepts positive and negative values.
    //         -> It handles removing the bonus automatically
    
    //     function UnitAddCooldownOffsetTimed takes unit u, real value, real duration returns nothing
    //         -> Add to the amount of cdr offset of a unit for a given period. Accepts positive and negative values.
    //         -> It handles removing the bonus automatically
        
    //     function GetUnitCooldownReductionEx takes unit u returns string
    //         -> Returns the amount of cdr a unit has as a string factored by 100
    //         -> example of return: 10.50 -> 0.105 internally.
    
    //     function GetUnitCooldownReductionFlatEx takes unit u returns string
    //         -> Returns the amount of cdr flat a unit has as a string factored by 100
    //         -> example of return: 10.50 -> 0.105 internally.
    
    //     function GetUnitCooldownOffsetEx takes unit u returns string
    //         -> Returns the amount of cdr offset a unit has as a string
    
    //     function GetAbilityTable takes nothing returns hashtable
    //         -> Returns the hashtable that holds the units default cooldown reduction values. 
    //         -> Use with caution! you might break stuff
    
    
    
    
    
        //----------------------------------------------
        //----------------------------------------------


        function s__CooldownReductionUtils__CDRUtils_destroy takes integer this returns nothing
            if s__CooldownReductionUtils__CDRUtils_didx == - 1 then
                call PauseTimer(s__CooldownReductionUtils__CDRUtils_t)
            endif

            set s__CooldownReductionUtils__CDRUtils_u[this]=null
            set s__CooldownReductionUtils__CDRUtils_ticks[this]=0
            call sc__CDR_deallocate(this)
        endfunction

        function s__CooldownReductionUtils__CDRUtils_onPeriod takes nothing returns nothing
            local integer i= 0
            local integer this
            
            loop
                exitwhen i > s__CooldownReductionUtils__CDRUtils_didx
                    set this=s__CooldownReductionUtils__CDRUtils_data[i]
                    set s__CooldownReductionUtils__CDRUtils_ticks[this]=s__CooldownReductionUtils__CDRUtils_ticks[this] - 1

                    if s__CooldownReductionUtils__CDRUtils_ticks[this] <= 0 then
                        if s__CooldownReductionUtils__CDRUtils_tipo[this] == 0 then
                            call s__CDR_remove(s__CooldownReductionUtils__CDRUtils_u[this] , s__CooldownReductionUtils__CDRUtils_amount[this])
                        elseif s__CooldownReductionUtils__CDRUtils_tipo[this] == 1 then
                            call s__CDR_Set(s__CooldownReductionUtils__CDRUtils_u[this] , s__CDR_get(s__CooldownReductionUtils__CDRUtils_u[this] , 1) - s__CooldownReductionUtils__CDRUtils_amount[this] , 1)
                        else
                            call s__CDR_Set(s__CooldownReductionUtils__CDRUtils_u[this] , s__CDR_get(s__CooldownReductionUtils__CDRUtils_u[this] , 2) - s__CooldownReductionUtils__CDRUtils_amount[this] , 2)
                        endif

                        set s__CooldownReductionUtils__CDRUtils_data[i]=s__CooldownReductionUtils__CDRUtils_data[s__CooldownReductionUtils__CDRUtils_didx]
                        set s__CooldownReductionUtils__CDRUtils_didx=s__CooldownReductionUtils__CDRUtils_didx - 1
                        set i=i - 1
                        call s__CooldownReductionUtils__CDRUtils_destroy(this)
                    endif
                set i=i + 1
            endloop
        endfunction

        function s__CooldownReductionUtils__CDRUtils_addTimed takes unit u,real amount,real duration,integer tipo returns nothing
            local integer this= s__CooldownReductionUtils__CDRUtils__allocate()

            set s__CooldownReductionUtils__CDRUtils_u[this]=u
            set s__CooldownReductionUtils__CDRUtils_amount[this]=amount
            set s__CooldownReductionUtils__CDRUtils_tipo[this]=tipo
            set s__CooldownReductionUtils__CDRUtils_ticks[this]=duration / 0.03125000
            set s__CooldownReductionUtils__CDRUtils_didx=s__CooldownReductionUtils__CDRUtils_didx + 1
            set s__CooldownReductionUtils__CDRUtils_data[s__CooldownReductionUtils__CDRUtils_didx]=this

            if tipo == 0 then
                call s__CDR_add(u , amount)
            elseif tipo == 1 then
                call s__CDR_Set(u , s__CDR_get(u , 1) + amount , 1)
            else
                call s__CDR_Set(u , s__CDR_get(u , 2) + amount , 2)
            endif
            
            if s__CooldownReductionUtils__CDRUtils_didx == 0 then
                call TimerStart(s__CooldownReductionUtils__CDRUtils_t, 0.03125000, true, function s__CooldownReductionUtils__CDRUtils_onPeriod)
            endif
        endfunction

    
    
    
    function UnitAddCooldownReductionTimed takes unit u,real value,real duration returns nothing
        call s__CooldownReductionUtils__CDRUtils_addTimed(u , value , duration , 0)
    endfunction

    function UnitAddCooldownReductionFlatTimed takes unit u,real value,real duration returns nothing
        call s__CooldownReductionUtils__CDRUtils_addTimed(u , value , duration , 1)
    endfunction

    function UnitAddCooldownOffsetTimed takes unit u,real value,real duration returns nothing
        call s__CooldownReductionUtils__CDRUtils_addTimed(u , value , duration , 2)
    endfunction

    function GetUnitCooldownReductionEx takes unit u returns string
        return R2SW(s__CDR_get(u , 0) * 100, 1, 2)
    endfunction

    function GetUnitCooldownReductionFlatEx takes unit u returns string
        return R2SW(s__CDR_get(u , 1) * 100, 1, 2)
    endfunction

    function GetUnitCooldownOffsetEx takes unit u returns string
        return R2SW(s__CDR_get(u , 2), 1, 2)
    endfunction

    function GetAbilityTable takes nothing returns hashtable
        return s__CDR_hashtable
    endfunction

//library CooldownReductionUtils ends
//library ExtendableBonusesMetroidvania:
    

    
    
    



        function s__BonusSystemPower_IsIntegerBonus takes integer this returns boolean
            return true
        endfunction
        function s__BonusSystemPower_Get takes integer this,unit u returns real
            return I2R(systempower[GetUnitUserData(u)])
        endfunction
        function s__BonusSystemPower_Set takes integer this,unit u,real value returns real
            local integer unitIndex= GetUnitUserData(u)
            set systempower[unitIndex]=R2I(value)
            return I2R(systempower[unitIndex])
        endfunction
        function s__BonusSystemPower_onInit takes nothing returns nothing
            set BONUS_SYSTEM_POWER=s__ExtendableBonus_Register(s__BonusSystemPower__allocate())
        endfunction

        function s__BonusSystemSpeed_IsIntegerBonus takes integer this returns boolean
            return true
        endfunction
        function s__BonusSystemSpeed_Get takes integer this,unit u returns real
            //return 100. * (1. / (1. - GetUnitCooldownReductionFlat(u)) - 1.0)
            return I2R(systemspeed[GetUnitUserData(u)])
        endfunction
        function s__BonusSystemSpeed_Set takes integer this,unit u,real value returns real
            //call SetUnitCooldownReductionFlat(u, 1. - 1. / (1. + value / 100.))
            local integer unitIndex= GetUnitUserData(u)
            set systemspeed[unitIndex]=R2I(value)
            return I2R(systemspeed[unitIndex])
        endfunction
        function s__BonusSystemSpeed_onInit takes nothing returns nothing
            set BONUS_SYSTEM_SPEED=s__ExtendableBonus_Register(s__BonusSystemSpeed__allocate())
        endfunction
    
    function GetCDR takes unit u returns real
        return 100. / ( 100. + systemspeed[GetUnitUserData(u)] )
    endfunction

//library ExtendableBonusesMetroidvania ends
//library Missiles:
    
    // Thanks and Credits to BPower, Dirac and Vexorian for the Missile Library's at which i based
    // this Missiles library. Credits and thanks to AGD and for the effect orientation ideas.
    // This version of Missiles requires patch 1.31+
    
    // How to Import:
    //     1 - Copy this, MissileEffect and optionaly the MissileUtils libraries to your map
    
    
    
    
    

    
    function Missiles__GetLocZ takes real x,real y returns real
        call MoveLocation(Missiles__LOC, x, y)
        return GetLocationZ(Missiles__LOC)
    endfunction
    
    function Missiles__GetUnitZ takes unit u returns real
        return Missiles__GetLocZ(GetUnitX(u) , GetUnitY(u)) + GetUnitFlyHeight(u)
    endfunction
    
    function Missiles__SetUnitZ takes unit u,real z returns nothing
        call SetUnitFlyHeight(u, z - Missiles__GetLocZ(GetUnitX(u) , GetUnitY(u)), 0)
    endfunction
    
    function Missiles__GetMapCliffLevel takes nothing returns integer
        return GetTerrainCliffLevel(s__WorldBounds_maxX, s__WorldBounds_maxY)
    endfunction



        function s__Missiles__Pool_recycle takes unit dummy returns nothing
            if GetUnitTypeId(dummy) == Missiles__DUMMY then
                call GroupAddUnit(s__Missiles__Pool_group, dummy)
                call SetUnitX(dummy, s__WorldBounds_maxX)
                call SetUnitY(dummy, s__WorldBounds_maxY)
                call SetUnitOwner(dummy, s__Missiles__Pool_player, false)
                call PauseUnit(dummy, true)
            endif
        endfunction

        function s__Missiles__Pool_retrieve takes real x,real y,real z,real face returns unit
            if BlzGroupGetSize(s__Missiles__Pool_group) > 0 then
                set bj_lastCreatedUnit=FirstOfGroup(s__Missiles__Pool_group)
                call PauseUnit(bj_lastCreatedUnit, false)
                call GroupRemoveUnit(s__Missiles__Pool_group, bj_lastCreatedUnit)
                call SetUnitX(bj_lastCreatedUnit, x)
                call SetUnitY(bj_lastCreatedUnit, y)
                call Missiles__SetUnitZ(bj_lastCreatedUnit , z)
                //call BlzSetUnitFacingEx(bj_lastCreatedUnit, face)
            else
                set bj_lastCreatedUnit=CreateUnit(s__Missiles__Pool_player, Missiles__DUMMY, x, y, face)
                call Missiles__SetUnitZ(bj_lastCreatedUnit , z)
                call UnitRemoveAbility(bj_lastCreatedUnit, 'Amrf')
            endif

            return bj_lastCreatedUnit
        endfunction

        function s__Missiles__Pool_onExpire takes nothing returns nothing
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((GetExpiredTimer())))) // INLINED!!

            call s__Missiles__Pool_recycle(s__Missiles__Pool_unit[this])
            call ReleaseTimer(s__Missiles__Pool_timer[this])
            
            set s__Missiles__Pool_timer[this]=null
            set s__Missiles__Pool_unit[this]=null

            call s__Missiles__Pool_deallocate(this)
        endfunction

        function s__Missiles__Pool_recycleTimed takes unit dummy,real delay returns nothing
            local integer this

            if GetUnitTypeId(dummy) != Missiles__DUMMY then
            else
                set this=s__Missiles__Pool__allocate()

                set s__Missiles__Pool_timer[this]=NewTimerEx(this)
                set s__Missiles__Pool_unit[this]=dummy
                
                call TimerStart(s__Missiles__Pool_timer[this], delay, false, function s__Missiles__Pool_onExpire)
            endif
        endfunction

        function s__Missiles__Pool_onInit takes nothing returns nothing
            local integer i= 0
            local unit u

            loop
                exitwhen i == Missiles_SWEET_SPOT
                    set u=CreateUnit(s__Missiles__Pool_player, Missiles__DUMMY, s__WorldBounds_maxX, s__WorldBounds_maxY, 0)
                    call PauseUnit(u, false)
                    call GroupAddUnit(s__Missiles__Pool_group, u)
                    call UnitRemoveAbility(u, 'Amrf')
                set i=i + 1
            endloop

            set u=null
        endfunction


        // Creates an origin - impact link.

        function s__Missiles__Coordinates_math takes integer a,integer b returns nothing
            local real dx
            local real dy
            loop
                set dx=s__Missiles__Coordinates_x[b] - s__Missiles__Coordinates_x[a]
                set dy=s__Missiles__Coordinates_y[b] - s__Missiles__Coordinates_y[a]
                set dx=dx * dx + dy * dy
                set dy=SquareRoot(dx)
                exitwhen dx != 0. and dy != 0.
                set s__Missiles__Coordinates_x[b]=s__Missiles__Coordinates_x[b] + .01
                set s__Missiles__Coordinates_z[b]=s__Missiles__Coordinates_z[b] - Missiles__GetLocZ(s__Missiles__Coordinates_x[b] - .01 , s__Missiles__Coordinates_y[b]) + Missiles__GetLocZ(s__Missiles__Coordinates_x[b] , s__Missiles__Coordinates_y[b])
            endloop

            set s__Missiles__Coordinates_square[a]=dx
            set s__Missiles__Coordinates_distance[a]=dy
            set s__Missiles__Coordinates_angle[a]=Atan2(s__Missiles__Coordinates_y[b] - s__Missiles__Coordinates_y[a], s__Missiles__Coordinates_x[b] - s__Missiles__Coordinates_x[a])
            set s__Missiles__Coordinates_slope[a]=( s__Missiles__Coordinates_z[b] - s__Missiles__Coordinates_z[a] ) / dy
            set s__Missiles__Coordinates_alpha[a]=Atan(s__Missiles__Coordinates_slope[a])
            // Set b.
            if s__Missiles__Coordinates_ref[b] == a then
                set s__Missiles__Coordinates_angle[b]=s__Missiles__Coordinates_angle[a] + bj_PI
                set s__Missiles__Coordinates_distance[b]=dy
                set s__Missiles__Coordinates_slope[b]=- s__Missiles__Coordinates_slope[a]
                set s__Missiles__Coordinates_alpha[b]=- s__Missiles__Coordinates_alpha[a]
                set s__Missiles__Coordinates_square[b]=dx
            endif
        endfunction

        function s__Missiles__Coordinates_link takes integer a,integer b returns nothing
            set s__Missiles__Coordinates_ref[a]=b
            set s__Missiles__Coordinates_ref[b]=a
            call s__Missiles__Coordinates_math(a , b)
        endfunction

        function s__Missiles__Coordinates_move takes integer this,real toX,real toY,real toZ returns nothing
            set s__Missiles__Coordinates_x[this]=toX
            set s__Missiles__Coordinates_y[this]=toY
            set s__Missiles__Coordinates_z[this]=toZ + Missiles__GetLocZ(toX , toY)
            if s__Missiles__Coordinates_ref[this] != this then
                call s__Missiles__Coordinates_math(this , s__Missiles__Coordinates_ref[this])
            endif
        endfunction

        function s__Missiles__Coordinates_destroy takes integer this returns nothing
            call s__Missiles__Coordinates_deallocate(this)
        endfunction

        function s__Missiles__Coordinates_create takes real x,real y,real z returns integer
            local integer this= s__Missiles__Coordinates__allocate()
            set s__Missiles__Coordinates_ref[this]=this
            call s__Missiles__Coordinates_move(this,x , y , z)
            return this
        endfunction
        
    
    
    
    


       
       
    
    
    
    
    
    
    
    
    
    

        
        
        
        
        
        
//Implemented from module Missiles__Operators:
        
        function s__Missiles__set_model takes integer this,string fx returns nothing
            call DestroyEffect(s__MissileEffect_effect[s__Missiles_effect[this]])
            set s__MissileEffect_path[s__Missiles_effect[this]]=fx
            set s__MissileEffect_effect[s__Missiles_effect[this]]=AddSpecialEffect(fx, s__Missiles__Coordinates_x[s__Missiles_origin[this]], s__Missiles__Coordinates_y[s__Missiles_origin[this]])
            call BlzSetSpecialEffectZ(s__MissileEffect_effect[s__Missiles_effect[this]], s__Missiles__Coordinates_z[s__Missiles_origin[this]])
            call BlzSetSpecialEffectYaw(s__MissileEffect_effect[s__Missiles_effect[this]], s__Missiles_cA[this])
        endfunction

        function s__Missiles__get_model takes integer this returns string
            return s__MissileEffect_path[s__Missiles_effect[this]]
        endfunction
        
        
        function s__Missiles__set_curve takes integer this,real value returns nothing
            set s__Missiles_open[this]=Tan(value * bj_DEGTORAD) * s__Missiles__Coordinates_distance[s__Missiles_origin[this]]
        endfunction
        
        function s__Missiles__get_curve takes integer this returns real
            return Atan(s__Missiles_open[this] / s__Missiles__Coordinates_distance[s__Missiles_origin[this]]) * bj_RADTODEG
        endfunction
        
        
        function s__Missiles__set_arc takes integer this,real value returns nothing
            set s__Missiles_height[this]=Tan(value * bj_DEGTORAD) * s__Missiles__Coordinates_distance[s__Missiles_origin[this]] / 4
        endfunction
        
        function s__Missiles__get_arc takes integer this returns real
            return Atan(4 * s__Missiles_height[this] / s__Missiles__Coordinates_distance[s__Missiles_origin[this]]) * bj_RADTODEG
        endfunction
        
        
        function s__Missiles__set_scale takes integer this,real value returns nothing
            set s__MissileEffect_size[s__Missiles_effect[this]]=value
            call s__MissileEffect_scale(s__Missiles_effect[this],s__MissileEffect_effect[s__Missiles_effect[this]] , value)
        endfunction

        function s__Missiles__get_scale takes integer this returns real
            return s__MissileEffect_size[s__Missiles_effect[this]]
        endfunction

        
        function s__Missiles__set_speed takes integer this,real newspeed returns nothing
            local real d= s__Missiles__Coordinates_distance[s__Missiles_origin[this]]
            local real s
            local real vel
        
            set s__Missiles_veloc[this]=newspeed * Missiles_PERIOD
            set vel=s__Missiles_veloc[this] * s__Missiles_dilation
            set s=s__Missiles_travel[this] + vel
            set s__Missiles_nextX[this]=s__Missiles_x[this] + vel * Cos(s__Missiles_cA[this])
            set s__Missiles_nextY[this]=s__Missiles_y[this] + vel * Sin(s__Missiles_cA[this])

            if s__Missiles_height[this] != 0 or s__Missiles__Coordinates_slope[s__Missiles_origin[this]] != 0 then
                set s__Missiles_nextZ[this]=4 * s__Missiles_height[this] * s * ( d - s ) / ( d * d ) + s__Missiles__Coordinates_slope[s__Missiles_origin[this]] * s + s__Missiles__Coordinates_z[s__Missiles_origin[this]]
                set s__Missiles_z[this]=s__Missiles_nextZ[this]
            endif
        endfunction

        function s__Missiles__get_speed takes integer this returns real
            return s__Missiles_veloc[this] / Missiles_PERIOD
        endfunction

        
        function s__Missiles__set_duration takes integer this,real flightTime returns nothing
            local real d= s__Missiles__Coordinates_distance[s__Missiles_origin[this]]
            local real s
            local real vel
        
            set s__Missiles_veloc[this]=RMaxBJ(0.00000001, ( s__Missiles__Coordinates_distance[s__Missiles_origin[this]] - s__Missiles_travel[this] ) * Missiles_PERIOD / RMaxBJ(0.00000001, flightTime))
            set s__Missiles_time[this]=flightTime
            set vel=s__Missiles_veloc[this] * s__Missiles_dilation
            set s=s__Missiles_travel[this] + vel
            set s__Missiles_nextX[this]=s__Missiles_x[this] + vel * Cos(s__Missiles_cA[this])
            set s__Missiles_nextY[this]=s__Missiles_y[this] + vel * Sin(s__Missiles_cA[this])

            if s__Missiles_height[this] != 0 or s__Missiles__Coordinates_slope[s__Missiles_origin[this]] != 0 then
                set s__Missiles_nextZ[this]=4 * s__Missiles_height[this] * s * ( d - s ) / ( d * d ) + s__Missiles__Coordinates_slope[s__Missiles_origin[this]] * s + s__Missiles__Coordinates_z[s__Missiles_origin[this]]
                set s__Missiles_z[this]=s__Missiles_nextZ[this]
            endif
        endfunction
        
        function s__Missiles__get_duration takes integer this returns real
            return s__Missiles_time[this]
        endfunction
        
        
        function s__Missiles__set_vision takes integer this,real sightRange returns nothing
            set s__Missiles_sight[this]=sightRange
            
            if s__Missiles_dummy[this] == null then
                if s__Missiles_owner[this] == null then
                    if s__Missiles_source[this] != null then
                        set s__Missiles_dummy[this]=s__Missiles__Pool_retrieve(s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this] , 0)
                        call SetUnitOwner(s__Missiles_dummy[this], GetOwningPlayer(s__Missiles_source[this]), false)
                        call BlzSetUnitRealField(s__Missiles_dummy[this], UNIT_RF_SIGHT_RADIUS, sightRange)
                    endif
                else
                    set s__Missiles_dummy[this]=s__Missiles__Pool_retrieve(s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this] , 0)
                    call SetUnitOwner(s__Missiles_dummy[this], s__Missiles_owner[this], false)
                    call BlzSetUnitRealField(s__Missiles_dummy[this], UNIT_RF_SIGHT_RADIUS, sightRange)
                endif
            else
                call SetUnitOwner(s__Missiles_dummy[this], s__Missiles_owner[this], false)
                call BlzSetUnitRealField(s__Missiles_dummy[this], UNIT_RF_SIGHT_RADIUS, sightRange)
            endif
        endfunction
        
        function s__Missiles__get_vision takes integer this returns real
            return s__Missiles_sight[this]
        endfunction

        
        function s__Missiles__set_timeScale takes integer this,real newTimeScale returns nothing
            call s__MissileEffect__set_timeScale(s__Missiles_effect[this],newTimeScale)
        endfunction
        
        function s__Missiles__get_timeScale takes integer this returns real
            return (s__MissileEffect_time[(s__Missiles_effect[this])]) // INLINED!!
        endfunction

        
        function s__Missiles__set_alpha takes integer this,integer newAlpha returns nothing
            call s__MissileEffect__set_alpha(s__Missiles_effect[this],newAlpha)
        endfunction

        function s__Missiles__get_alpha takes integer this returns integer
            return (s__MissileEffect_transparency[(s__Missiles_effect[this])]) // INLINED!!
        endfunction

        
        function s__Missiles__set_playerColor takes integer this,integer playerId returns nothing
            call s__MissileEffect__set_playerColor(s__Missiles_effect[this],playerId)
        endfunction

        function s__Missiles__get_playerColor takes integer this returns integer
            return (s__MissileEffect_playercolor[(s__Missiles_effect[this])]) // INLINED!!
        endfunction

        
        function s__Missiles__set_animation takes integer this,integer animType returns nothing
            call s__MissileEffect__set_animation(s__Missiles_effect[this],animType)
        endfunction

        function s__Missiles__get_animation takes integer this returns integer
            return (s__MissileEffect_animtype[(s__Missiles_effect[this])]) // INLINED!!
        endfunction
//Implemented from module Missiles__Methods:
        
        function s__Missiles_bounce takes integer this returns nothing
            call s__Missiles__Coordinates_move(s__Missiles_origin[this],s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this] - Missiles__GetLocZ(s__Missiles_x[this] , s__Missiles_y[this]))
            
            set s__Missiles_travel[this]=0
            set s__Missiles_finished[this]=false
        endfunction

        function s__Missiles_deflect takes integer this,real tx,real ty,real tz returns nothing
            local real locZ= Missiles__GetLocZ(s__Missiles_x[this] , s__Missiles_y[this])
            
            set s__Missiles_target[this]=null
            set s__Missiles_toZ[this]=tz
            
            if s__Missiles_z[this] < locZ then
                set s__Missiles_nextX[this]=s__Missiles_prevX[this]
                set s__Missiles_nextY[this]=s__Missiles_prevY[this]
                set s__Missiles_nextZ[this]=s__Missiles_prevZ[this]
            endif
            
            call s__Missiles__Coordinates_move(s__Missiles_impact[this],tx , ty , tz)
            call s__Missiles__Coordinates_move(s__Missiles_origin[this],s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this] - locZ)
            
            set s__Missiles_travel[this]=0
            set s__Missiles_finished[this]=false
        endfunction
        
        function s__Missiles_deflectTarget takes integer this,unit u returns nothing
            call s__Missiles_deflect(this,GetUnitX(u) , GetUnitY(u) , s__Missiles_toZ[this])
            set s__Missiles_target[this]=u
        endfunction

        
        function s__Missiles_flushAll takes integer this returns nothing
            call FlushChildHashtable(s__Missiles_table, this)
        endfunction

        function s__Missiles_flush takes integer this,widget w returns nothing
            if w != null then
                call RemoveSavedBoolean(s__Missiles_table, this, GetHandleId(w))
            endif
        endfunction

        function s__Missiles_hitted takes integer this,widget w returns boolean
            return HaveSavedBoolean(s__Missiles_table, this, GetHandleId(w))
        endfunction

        
        function s__Missiles_attach takes integer this,string model,real dx,real dy,real dz,real scale returns effect
            return s__MissileEffect_attach(s__Missiles_effect[this],model , dx , dy , dz , scale)
        endfunction

        function s__Missiles_detach takes integer this,effect attachment returns nothing
            if attachment != null then
                call s__MissileEffect_detach(s__Missiles_effect[this],attachment)
            endif
        endfunction

        
        function s__Missiles_pause takes integer this,boolean flag returns nothing
        local integer aux
        
        set s__Missiles_paused[this]=flag
        if not s__Missiles_paused[this] and s__Missiles_pkey[this] != - 1 then
            set s__Missiles_id=s__Missiles_id + 1
            set s__Missiles_missiles[s__Missiles_id]=this
            set aux=s__Missiles_frozen[s__Missiles_pid]
            set s__Missiles_pkey[aux]=s__Missiles_pkey[this]
            set s__Missiles_frozen[s__Missiles_pkey[this]]=s__Missiles_frozen[s__Missiles_pid]
            set s__Missiles_pid=s__Missiles_pid - 1
            set s__Missiles_pkey[this]=- 1

            if s__Missiles_id + 1 > Missiles_SWEET_SPOT and Missiles_SWEET_SPOT > 0 then
                set s__Missiles_dilation=( s__Missiles_id + 1 ) / Missiles_SWEET_SPOT
            else
                set s__Missiles_dilation=1.
            endif

            if s__Missiles_id == 0 then
                call TimerStart(s__Missiles_timer, Missiles_PERIOD, true, function sc__Missiles_move)
            endif
            
            if (st__Missiles__MissileEvents_onResume[si__Missiles__MissileEvents_type[this]]!=null) then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onResume(this) then
                    call sc__Missiles_terminate(this)
                else
                    if s__Missiles_finished[this] then
                        call sc__Missiles_terminate(this)
                    endif
                endif
            else
                if s__Missiles_finished[this] then
                    call sc__Missiles_terminate(this)
                endif
            endif
        endif
        endfunction

        
        function s__Missiles_color takes integer this,integer red,integer green,integer blue returns nothing
            call BlzSetSpecialEffectColor(s__MissileEffect_effect[(s__Missiles_effect[this])], (red ), ( green ), ( blue)) // INLINED!!
        endfunction
        
        
        function s__Missiles_onDest takes nothing returns nothing
            local integer this= s__Missiles_temp
            local destructable d= GetEnumDestructable()
            local real dz
            local real tz
            local real dx
            local real dy

            if not HaveSavedBoolean(s__Missiles_table, this, GetHandleId(d)) then
                set dx=GetWidgetX(d) - s__Missiles_x[this]
                set dy=GetWidgetY(d) - s__Missiles_y[this]
                if SquareRoot(dx * dx + dy * dy) < GetDestructableLife(d) + s__Missiles_collision[this] then
                    if s__Missiles_collideZ[this] then
                        set dz=Missiles__GetLocZ(GetWidgetX(d) , GetWidgetY(d))
                        set tz=GetDestructableOccluderHeight(d)
                        if dz + tz >= s__Missiles_z[this] - s__Missiles_collision[this] and dz <= s__Missiles_z[this] + s__Missiles_collision[this] then
                            call SaveBoolean(s__Missiles_table, this, GetHandleId(d), true)
                            if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onDestructable(this,d) then
                                set d=null
                                call sc__Missiles_terminate(this)
                                return
                            endif
                        endif
                    else
                        call SaveBoolean(s__Missiles_table, this, GetHandleId(d), true)
                        if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onDestructable(this,d) then
                            set d=null
                            call sc__Missiles_terminate(this)
                            return
                        endif
                    endif
                endif
            endif

            set d=null
        endfunction

        
        function s__Missiles_onItems takes nothing returns nothing
            local integer this= s__Missiles_temp
            local item i= GetEnumItem()
            local real dz

            if not HaveSavedBoolean(s__Missiles_table, this, GetHandleId(i)) then
                if s__Missiles_collideZ[this] then
                    set dz=Missiles__GetLocZ(GetItemX(i) , GetItemY(i))
                    if dz + Missiles__ITEM_SIZE >= s__Missiles_z[this] - s__Missiles_collision[this] and dz <= s__Missiles_z[this] + s__Missiles_collision[this] then
                        call SaveBoolean(s__Missiles_table, this, GetHandleId(i), true)
                        if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onItem(this,i) then
                            set i=null
                            call sc__Missiles_terminate(this)
                            return
                        endif
                    endif
                else
                    call SaveBoolean(s__Missiles_table, this, GetHandleId(i), true)
                    if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onItem(this,i) then
                        set i=null
                        call sc__Missiles_terminate(this)
                        return
                    endif
                endif
            endif

            set i=null
        endfunction

        
        function s__Missiles_terminate takes integer this returns nothing
        local integer aux
    
        if s__Missiles_allocated[this] and s__Missiles_launched[this] then
            set s__Missiles_allocated[this]=false
            
            if s__Missiles_pkey[this] != - 1 then
                set aux=s__Missiles_frozen[s__Missiles_pid]
                set s__Missiles_pkey[aux]=s__Missiles_pkey[this]
                set s__Missiles_frozen[s__Missiles_pkey[this]]=s__Missiles_frozen[s__Missiles_pid]
                set s__Missiles_pid=s__Missiles_pid - 1
                set s__Missiles_pkey[this]=- 1
            endif
            
            if (st__Missiles__MissileEvents_onRemove[si__Missiles__MissileEvents_type[this]]!=null) then
                call sc__Missiles__MissileEvents_onRemove(this)
            endif
            
            if s__Missiles_dummy[this] != null then
                call s__Missiles__Pool_recycle(s__Missiles_dummy[this])
            endif
            
            set aux=s__Missiles_collection[s__Missiles_count]
            set s__Missiles_index[aux]=s__Missiles_index[this]
            set s__Missiles_collection[s__Missiles_index[this]]=s__Missiles_collection[s__Missiles_count]
            set s__Missiles_count=s__Missiles_count - 1
            set s__Missiles_index[this]=- 1
            
            call s__Missiles__Coordinates_deallocate((s__Missiles_origin[this])) // INLINED!!
            call s__Missiles__Coordinates_deallocate((s__Missiles_impact[this])) // INLINED!!
            call s__MissileEffect_destroy(s__Missiles_effect[this])
            call sc__Missiles_reset(this)
            call FlushChildHashtable(s__Missiles_table, this)
        endif
        endfunction

        
        function s__Missiles_reset takes integer this returns nothing
            set s__Missiles_launched[this]=false
            set s__Missiles_finished[this]=false
            set s__Missiles_collideZ[this]=false
            set s__Missiles_paused[this]=false
            set s__Missiles_roll[this]=false
            set s__Missiles_source[this]=null
            set s__Missiles_target[this]=null
            set s__Missiles_owner[this]=null
            set s__Missiles_dummy[this]=null
            set s__Missiles_open[this]=0.
            set s__Missiles_height[this]=0.
            set s__Missiles_veloc[this]=0.
            set s__Missiles_acceleration[this]=0.
            set s__Missiles_collision[this]=0.
            set s__Missiles_damage[this]=0.
            set s__Missiles_travel[this]=0.
            set s__Missiles_turn[this]=0.
            set s__Missiles_time[this]=0.
            set s__Missiles_sight[this]=0.
            set s__Missiles_data[this]=0
            set s__Missiles_type[this]=0
            set s__Missiles_tileset[this]=0
            set s__Missiles_pkey[this]=- 1
            set s__Missiles_index[this]=- 1
        endfunction

        
        function s__Missiles_remove takes integer this,integer i returns integer
            if s__Missiles_paused[this] then
//Implemented from module Missiles__OnPause:
        set s__Missiles_pid=s__Missiles_pid + 1
        set s__Missiles_pkey[this]=s__Missiles_pid
        set s__Missiles_frozen[s__Missiles_pid]=this
        
        if (st__Missiles__MissileEvents_onPause[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onPause(this) then
                call s__Missiles_terminate(this)
            endif
        endif
            else
//Implemented from module Missiles__OnRemove:
            endif
            
            set s__Missiles_missiles[i]=s__Missiles_missiles[s__Missiles_id]
            set s__Missiles_id=s__Missiles_id - 1

            if s__Missiles_id + 1 > Missiles_SWEET_SPOT and Missiles_SWEET_SPOT > 0 then
                set s__Missiles_dilation=( s__Missiles_id + 1 ) / Missiles_SWEET_SPOT
            else
                set s__Missiles_dilation=1
            endif

            if s__Missiles_id == - 1 then
                call PauseTimer(s__Missiles_timer)
            endif
            
            if not s__Missiles_allocated[this] then
                call sc__Missiles__MissileEvents_deallocate(this)
            endif

            return i - 1
        endfunction
        
        
        function s__Missiles_move takes nothing returns nothing
            local integer j= 0
            local integer i
            local integer k
            local unit u
            local real a
            local real d
            local real s
            local real h
            local real c
            local real dx
            local real dy
            local real vel
            local real yaw
            local real pitch
            local integer missile
            local integer o
            local integer this

            if Missiles_SWEET_SPOT > 0 then
                set i=s__Missiles_last
            else
                set i=0
            endif
            
            loop
                exitwhen ( ( j >= Missiles_SWEET_SPOT and Missiles_SWEET_SPOT > 0 ) or j > s__Missiles_id )
                    set this=s__Missiles_missiles[i]
                    set s__Missiles_temp=this
                    if s__Missiles_allocated[this] and not s__Missiles_paused[this] then
//Implemented from module Missiles__OnHit:
        set o=s__Missiles_origin[this]
        set h=s__Missiles_height[this]
        set c=s__Missiles_open[this]
        set d=s__Missiles__Coordinates_distance[o]
    
        if (st__Missiles__MissileEvents_onHit[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                call GroupEnumUnitsInRange(s__Missiles_group, s__Missiles_x[this], s__Missiles_y[this], s__Missiles_collision[this] + Missiles__COLLISION_SIZE, null)
                loop
                    set u=FirstOfGroup(s__Missiles_group)
                    exitwhen u == null
                        if not HaveSavedBoolean(s__Missiles_table, this, GetHandleId(u)) then
                            if IsUnitInRangeXY(u, s__Missiles_x[this], s__Missiles_y[this], s__Missiles_collision[this]) then
                                if s__Missiles_collideZ[this] then
                                    set dx=Missiles__GetLocZ(GetUnitX(u) , GetUnitY(u)) + GetUnitFlyHeight(u)
                                    set dy=BlzGetUnitCollisionSize(u)
                                    if dx + dy >= s__Missiles_z[this] - s__Missiles_collision[this] and dx <= s__Missiles_z[this] + s__Missiles_collision[this] then
                                        call SaveBoolean(s__Missiles_table, this, GetHandleId(u), true)
                                        if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onHit(this,u) then
                                            call s__Missiles_terminate(this)
                                            exitwhen true
                                        endif
                                    endif
                                else
                                    call SaveBoolean(s__Missiles_table, this, GetHandleId(u), true)
                                    if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onHit(this,u) then
                                        call s__Missiles_terminate(this)
                                        exitwhen true
                                    endif
                                endif
                            endif
                        endif
                    call GroupRemoveUnit(s__Missiles_group, u)
                endloop
            endif
        endif
//Implemented from module Missiles__OnMissile:
        if (st__Missiles__MissileEvents_onMissile[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set k=0
                loop
                    exitwhen k > s__Missiles_count
                        set missile=s__Missiles_collection[k]
                        if missile != this then
                            if not HaveSavedBoolean(s__Missiles_table, this, missile) then
                                set dx=s__Missiles_x[missile] - s__Missiles_x[this]
                                set dy=s__Missiles_y[missile] - s__Missiles_y[this]
                                if SquareRoot(dx * dx + dy * dy) <= s__Missiles_collision[this] then
                                    call SaveBoolean(s__Missiles_table, this, missile, true)
                                    if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onMissile(this,missile) then
                                        call s__Missiles_terminate(this)
                                        exitwhen true
                                    endif
                                endif
                            endif
                        endif
                    set k=k + 1
                endloop
            endif
        endif
//Implemented from module Missiles__OnDestructable:
        if (st__Missiles__MissileEvents_onDestructable[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set dx=s__Missiles_collision[this] + 64.0
                call SetRect(s__Missiles_rect, s__Missiles_x[this] - dx, s__Missiles_y[this] - dx, s__Missiles_x[this] + dx, s__Missiles_y[this] + dx)
                call EnumDestructablesInRect(s__Missiles_rect, null, function s__Missiles_onDest)
            endif
        endif
//Implemented from module Missiles__OnItem:
        if (st__Missiles__MissileEvents_onItem[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set dx=s__Missiles_collision[this]
                call SetRect(s__Missiles_rect, s__Missiles_x[this] - dx, s__Missiles_y[this] - dx, s__Missiles_x[this] + dx, s__Missiles_y[this] + dx)
                call EnumItemsInRect(s__Missiles_rect, null, function s__Missiles_onItems)
            endif
        endif
//Implemented from module Missiles__OnCliff:
        if (st__Missiles__MissileEvents_onCliff[si__Missiles__MissileEvents_type[this]]!=null) then
            set dx=GetTerrainCliffLevel(s__Missiles_nextX[this], s__Missiles_nextY[this])
            set dy=GetTerrainCliffLevel(s__Missiles_x[this], s__Missiles_y[this])
            if dy < dx and s__Missiles_z[this] < ( dx - (GetTerrainCliffLevel(s__WorldBounds_maxX, s__WorldBounds_maxY)) ) * bj_CLIFFHEIGHT then // INLINED!!
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onCliff(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        endif
//Implemented from module Missiles__OnTerrain:
        if (st__Missiles__MissileEvents_onTerrain[si__Missiles__MissileEvents_type[this]]!=null) then
            if Missiles__GetLocZ(s__Missiles_x[this] , s__Missiles_y[this]) > s__Missiles_z[this] then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onTerrain(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        endif
//Implemented from module Missiles__OnTileset:
        if (st__Missiles__MissileEvents_onTileset[si__Missiles__MissileEvents_type[this]]!=null) then
            set k=GetTerrainType(s__Missiles_x[this], s__Missiles_y[this])
            if k != s__Missiles_tileset[this] then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onTileset(this,k) then
                    call s__Missiles_terminate(this)
                endif
            endif
            set s__Missiles_tileset[this]=k
        endif
//Implemented from module Missiles__OnPeriod:
        if (st__Missiles__MissileEvents_onPeriod[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onPeriod(this) then
                call s__Missiles_terminate(this)
            endif
        endif
//Implemented from module Missiles__OnOrient:
        // Homing or not
        set u=s__Missiles_target[this]
        if u != null and GetUnitTypeId(u) != 0 then
            call s__Missiles__Coordinates_move(s__Missiles_impact[this],GetUnitX(u) , GetUnitY(u) , GetUnitFlyHeight(u) + s__Missiles_toZ[this])
            set dx=s__Missiles__Coordinates_x[s__Missiles_impact[this]] - s__Missiles_nextX[this]
            set dy=s__Missiles__Coordinates_y[s__Missiles_impact[this]] - s__Missiles_nextY[this]
            set a=Atan2(dy, dx)
            set s__Missiles_travel[this]=s__Missiles__Coordinates_distance[o] - SquareRoot(dx * dx + dy * dy)
        else
            set a=s__Missiles__Coordinates_angle[o]
            set s__Missiles_target[this]=null
        endif
        
        // turn rate
        if s__Missiles_turn[this] != 0 and not ( Cos(s__Missiles_cA[this] - a) >= Cos(s__Missiles_turn[this]) ) then
            if Sin(a - s__Missiles_cA[this]) >= 0 then
                set s__Missiles_cA[this]=s__Missiles_cA[this] + s__Missiles_turn[this]
            else
                set s__Missiles_cA[this]=s__Missiles_cA[this] - s__Missiles_turn[this]
            endif
        else
            set s__Missiles_cA[this]=a
        endif

        set vel=s__Missiles_veloc[this] * s__Missiles_dilation
        set yaw=s__Missiles_cA[this]
        set s=s__Missiles_travel[this] + vel
        set s__Missiles_veloc[this]=s__Missiles_veloc[this] + s__Missiles_acceleration[this]
        set s__Missiles_travel[this]=s
        set pitch=s__Missiles__Coordinates_alpha[o]
        set s__Missiles_prevX[this]=s__Missiles_x[this]
        set s__Missiles_prevY[this]=s__Missiles_y[this]
        set s__Missiles_prevZ[this]=s__Missiles_z[this]
        set s__Missiles_x[this]=s__Missiles_nextX[this]
        set s__Missiles_y[this]=s__Missiles_nextY[this]
        set s__Missiles_z[this]=s__Missiles_nextZ[this]
        set s__Missiles_nextX[this]=s__Missiles_x[this] + vel * Cos(yaw)
        set s__Missiles_nextY[this]=s__Missiles_y[this] + vel * Sin(yaw)

        // arc calculation
        if h != 0 or s__Missiles__Coordinates_slope[o] != 0 then
            set s__Missiles_nextZ[this]=4 * h * s * ( d - s ) / ( d * d ) + s__Missiles__Coordinates_slope[o] * s + s__Missiles__Coordinates_z[o]
            set pitch=pitch - Atan(( ( 4 * h ) * ( 2 * s - d ) ) / ( d * d ))
        endif
        
        // curve calculation
        if c != 0 then
            set dx=4 * c * s * ( d - s ) / ( d * d )
            set a=yaw + bj_PI / 2
            set s__Missiles_x[this]=s__Missiles_x[this] + dx * Cos(a)
            set s__Missiles_y[this]=s__Missiles_y[this] + dx * Sin(a)
            set yaw=yaw + Atan(- ( ( 4 * c ) * ( 2 * s - d ) ) / ( d * d ))
        endif
//Implemented from module Missiles__OnFinish:
        if s >= d - 0.0001 then
            set s__Missiles_finished[this]=true
            if (st__Missiles__MissileEvents_onFinish[si__Missiles__MissileEvents_type[this]]!=null) then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onFinish(this) then
                    call s__Missiles_terminate(this)
                //else
                //    if travel > 0 and not paused then
                //        call terminate()
                //    endif
                endif
            else
                call s__Missiles_terminate(this)
            endif
        else
            if not s__Missiles_roll[this] then
                call s__MissileEffect_orient(s__Missiles_effect[this],yaw , - pitch , 0)
            else
                call s__MissileEffect_orient(s__Missiles_effect[this],yaw , - pitch , Atan2(c, h))
            endif
        endif
//Implemented from module Missiles__OnBoundaries:
        if not s__MissileEffect_move(s__Missiles_effect[this],s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this]) then
            if (st__Missiles__MissileEvents_onBoundaries[si__Missiles__MissileEvents_type[this]]!=null) then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onBoundaries(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        else
            if s__Missiles_dummy[this] != null then
                call SetUnitX(s__Missiles_dummy[this], s__Missiles_x[this])
                call SetUnitY(s__Missiles_dummy[this], s__Missiles_y[this])
            endif
        endif
                    else
                        set i=s__Missiles_remove(this,i)
                        set j=j - 1
                    endif
                set i=i + 1
                set j=j + 1

                if i > s__Missiles_id and Missiles_SWEET_SPOT > 0 then
                    set i=0
                endif
            endloop
            set s__Missiles_last=i

            set u=null
        endfunction
        
        
        function s__Missiles_launch takes integer this returns nothing
            if not s__Missiles_launched[this] and s__Missiles_allocated[this] then
                set s__Missiles_launched[this]=true
                set s__Missiles_id=s__Missiles_id + 1
                set s__Missiles_missiles[s__Missiles_id]=this
                set s__Missiles_count=s__Missiles_count + 1
                set s__Missiles_index[this]=s__Missiles_count
                set s__Missiles_collection[s__Missiles_count]=this
                
                if s__Missiles_id + 1 > Missiles_SWEET_SPOT and Missiles_SWEET_SPOT > 0 then
                    set s__Missiles_dilation=( s__Missiles_id + 1 ) / Missiles_SWEET_SPOT
                else
                    set s__Missiles_dilation=1.
                endif

                if s__Missiles_id == 0 then
                    call TimerStart(s__Missiles_timer, Missiles_PERIOD, true, function s__Missiles_move)
                endif
            endif
        endfunction

        
        function s__Missiles_create takes real x,real y,real z,real toX,real toY,real toZ returns integer
            local integer this= s__Missiles__allocate()

            call s__Missiles_reset(this)
            set s__Missiles_origin[this]=s__Missiles__Coordinates_create(x , y , z)
            set s__Missiles_impact[this]=s__Missiles__Coordinates_create(toX , toY , toZ)
            set s__Missiles_effect[this]=s__MissileEffect_create(x , y , s__Missiles__Coordinates_z[s__Missiles_origin[this]])
            call s__Missiles__Coordinates_link(s__Missiles_origin[this] , s__Missiles_impact[this])
            set s__Missiles_allocated[this]=true
            set s__Missiles_cA[this]=s__Missiles__Coordinates_angle[s__Missiles_origin[this]]
            set s__Missiles_x[this]=x
            set s__Missiles_y[this]=y
            set s__Missiles_z[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_prevX[this]=x
            set s__Missiles_prevY[this]=y
            set s__Missiles_prevZ[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_nextX[this]=x
            set s__Missiles_nextY[this]=y
            set s__Missiles_nextZ[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_toZ[this]=toZ
            
            return this
        endfunction

//library Missiles ends
//library UnitAddAbilityTimed:
   
   
   
   
        function s__TimedAbility_destroy takes integer this returns nothing
            call s__TimedAbility_deallocate(this)
            set s__TimedAbility_u[this]=null
            set s__TimedAbility_abil[this]=0
            set s__TimedAbility_recycle[this]=false
        endfunction
   
        function s__TimedAbility_removeAbil takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            call UnitRemoveAbility(s__TimedAbility_u[this], s__TimedAbility_abil[this])
            if s__TimedAbility_recycle[this] then
                call RecycleDummy(s__TimedAbility_u[this])
            endif
            call s__TimedAbility_destroy(this)
            call ReleaseTimer(t)
            set t=null
        endfunction
     
        function s__TimedAbility_create takes unit source,integer abil_code,real timeout,boolean recycle_source returns integer
            local integer this= s__TimedAbility__allocate()
            local timer t= NewTimerEx(this)
            set s__TimedAbility_u[this]=source
            set s__TimedAbility_abil[this]=abil_code
            set s__TimedAbility_recycle[this]=recycle_source
            call TimerStart(t, timeout, false, function s__TimedAbility_removeAbil)
            set t=null
            return this
        endfunction
   


//library UnitAddAbilityTimed ends
//library MetroidvaniaUtils:
    function GetZ takes real x,real y returns real
        call MoveLocation(zTester, x, y)
        return GetLocationZ(zTester)
    endfunction
    function R2I2S takes real r returns string
        return I2S(R2I(r + 0.1))
    endfunction
    function R2SHumanReadable takes real r returns string
        if r > 10. then
            return I2S(R2I(r + 0.01))
        elseif r > 0.99 then
            return R2SW(r, 0, 1)
        elseif r == 0 then
            return R2SW(r, 0, 1)
        else
            return R2SW(r, 0, 2)
        endif
    endfunction
    function strStartsWith takes string str,string start returns boolean
        return start == SubString(str, 0, StringLength(start))
    endfunction
    function strEndsWith takes string str,string end returns boolean
        return end == SubString(str, StringLength(str) - StringLength(end), StringLength(str))
    endfunction
    function statIndexToBonusId takes integer statIndex returns integer
        if statIndex == STAT_INDEX_HP then
            return si__BonusHealth
        elseif statIndex == STAT_INDEX_HP_REPAIR then
            return si__BonusHealthRegen
        elseif statIndex == STAT_INDEX_ENERGY then
            return si__BonusMana
        elseif statIndex == STAT_INDEX_ENERGY_RECHARGE then
            return si__BonusManaRegen
        elseif statIndex == STAT_INDEX_FIREPOWER then
            return si__BonusDamage
        elseif statIndex == STAT_INDEX_SYSTEM_POWER then
            return si__BonusSystemPower
        elseif statIndex == STAT_INDEX_SYSTEM_SPEED then
            return si__BonusSystemSpeed
        elseif statIndex == STAT_INDEX_MOBILITY then
            return si__BonusMovementSpeed
        endif
        call BJDebugMsg("Didn't find bonus id for statIndex=" + I2S(statIndex))
        return - 1
    endfunction

    function Si2Color takes integer statIndex returns string
        if statIndex == STAT_INDEX_HP then
            return "|c0096f064"
        elseif statIndex == STAT_INDEX_HP_REPAIR then
            return "|c0050b478"
        elseif statIndex == STAT_INDEX_ENERGY then
            return "|c0072AAEE"
        elseif statIndex == STAT_INDEX_ENERGY_RECHARGE then
            return "|c008064EC"
        elseif statIndex == STAT_INDEX_FIREPOWER then
            return "|c00FF7800"
        elseif statIndex == STAT_INDEX_SYSTEM_POWER then
            return "|c00DF00FF"
        elseif statIndex == STAT_INDEX_SYSTEM_SPEED then
            return "|c00D2B2FF"
        elseif statIndex == STAT_INDEX_MOBILITY then
            return "|c00EEE8AA"
        endif
        call BJDebugMsg("Didn't find color id for statIndex=" + I2S(statIndex))
        return ""
    endfunction

    function Si2Name takes integer statIndex returns string
        if statIndex == STAT_INDEX_HP then
            return "Structural Integrity"
        elseif statIndex == STAT_INDEX_HP_REPAIR then
            return "Repair Rate"
        elseif statIndex == STAT_INDEX_ENERGY then
            return "Energy Capacity"
        elseif statIndex == STAT_INDEX_ENERGY_RECHARGE then
            return "Energy Recharge"
        elseif statIndex == STAT_INDEX_FIREPOWER then
            return "Firepower"
        elseif statIndex == STAT_INDEX_SYSTEM_POWER then
            return "Auxiliary Power"
        elseif statIndex == STAT_INDEX_SYSTEM_SPEED then
            return "System Speed"
        elseif statIndex == STAT_INDEX_MOBILITY then
            return "Mobility"
        endif
        call BJDebugMsg("Didn't find color id for statIndex=" + I2S(statIndex))
        return ""
    endfunction

    function statIndexToBonusAmount takes integer statIndex returns real
        if statIndex == STAT_INDEX_HP then
            return BONUS_PER_CORE_HP
        elseif statIndex == STAT_INDEX_HP_REPAIR then
            return BONUS_PER_CORE_HP_REPAIR
        elseif statIndex == STAT_INDEX_ENERGY then
            return BONUS_PER_CORE_ENERGY
        elseif statIndex == STAT_INDEX_ENERGY_RECHARGE then
            return BONUS_PER_CORE_ENERGY_RECHARGE
        elseif statIndex == STAT_INDEX_FIREPOWER then
            return BONUS_PER_CORE_FIREPOWER
        elseif statIndex == STAT_INDEX_SYSTEM_POWER then
            return BONUS_PER_CORE_SYSTEM_POWER
        elseif statIndex == STAT_INDEX_SYSTEM_SPEED then
            return BONUS_PER_CORE_SYSTEM_SPEED
        elseif statIndex == STAT_INDEX_MOBILITY then
            return BONUS_PER_CORE_MOBILITY
        endif
        call BJDebugMsg("Didn't find bonus amount for statIndex=" + I2S(statIndex))
        return - 1.
    endfunction


        //every 3 points spent will increase cost by 1 for all different stats
        function s__HeroStatsCore_coreCostForNext takes player p,integer statIndex returns integer
            return 1 + (s__HeroStatsCore_coresApplied[GetPlayerId((p )) * STAT_COUNT + ( statIndex)]) / 3 // INLINED!!
        endfunction
        
        function s__HeroStatsCore_coresAppliedToStat takes player p,integer statIndex returns integer
            return s__HeroStatsCore_coresApplied[GetPlayerId(p) * STAT_COUNT + statIndex]
        endfunction

        function s__HeroStatsCore_addCore takes player p,integer numberOfCores returns nothing
            local integer i= GetPlayerId(p)
            set coresAvailable[i]=coresAvailable[i] + numberOfCores
            //Note: You'll probably need to update stats-panel after calling this. 
            //updateStatsPanel(p)
        endfunction
        
        function s__HeroStatsCore_available takes player p returns integer
            return coresAvailable[GetPlayerId(p)]
        endfunction

        function s__HeroStatsCore_addCoresForAll takes integer numberOfCores returns nothing
            call s__HeroStatsCore_addCore(Player(0) , numberOfCores)
            call s__HeroStatsCore_addCore(Player(1) , numberOfCores)
            call s__HeroStatsCore_addCore(Player(2) , numberOfCores)
            call s__HeroStatsCore_addCore(Player(3) , numberOfCores)
            call s__HeroStatsCore_addCore(Player(4) , numberOfCores)
            call s__HeroStatsCore_addCore(Player(5) , numberOfCores)
            set totalCoresCollected=totalCoresCollected + IMaxBJ(0, numberOfCores)
        endfunction

        function s__HeroStatsCore_applyCore takes unit u,integer statIndex returns nothing
            local player p= GetOwningPlayer(u)
            local integer i= GetPlayerId(p) * STAT_COUNT + statIndex
            local integer cost= (1 + (s__HeroStatsCore_coresApplied[GetPlayerId(((p ) )) * STAT_COUNT + ( ( statIndex))]) / 3) // INLINED!!
            if (coresAvailable[GetPlayerId((p))]) >= cost then // INLINED!!
                call s__HeroStatsCore_addCore(p , - cost)
                set s__HeroStatsCore_coresApplied[i]=s__HeroStatsCore_coresApplied[i] + 1
call s__ExtendableBonus_Add((u ) , ( statIndexToBonusId(statIndex) ) , (( statIndexToBonusAmount(statIndex))*1.0)) // INLINED!!
                call sc__MetroidvaniaController_updateAbilityDetails(sc__MetroidvaniaController_getMetroidvaniaController(p))
            endif
            set p=null
        endfunction 

    

    function setTextTagToPlayerColor takes texttag text,player p returns nothing
        if p == Player(0) then
            call SetTextTagColor(text, 255, 3, 3, 200)
        elseif p == Player(1) then
            call SetTextTagColor(text, 0, 66, 255, 200)
        elseif p == Player(2) then
            call SetTextTagColor(text, 28, 230, 185, 200)
        elseif p == Player(3) then
            call SetTextTagColor(text, 84, 0, 129, 200)
        elseif p == Player(4) then
            call SetTextTagColor(text, 255, 252, 1, 200)
        //TODO: all, I guess: https://www.hiveworkshop.com/threads/warcraft-iii-color-tags-and-linebreaks.31386/
        //Convert hex -> rgb with ctrl+alt+r
        endif
    endfunction

    function GetMissingHp takes unit u returns real
        return GetUnitState(u, UNIT_STATE_MAX_LIFE) - GetWidgetLife(u)
    endfunction

    function GetMissingMana takes unit u returns real
        return GetUnitState(u, UNIT_STATE_MAX_MANA) - GetUnitState(u, UNIT_STATE_MANA)
    endfunction

    function GetMaxHp takes unit u returns real
        return GetUnitState(u, UNIT_STATE_MAX_LIFE)
    endfunction

    function GetMaxMana takes unit u returns real
        return GetUnitState(u, UNIT_STATE_MAX_MANA)
    endfunction

    function GetHp takes unit u returns real
        return GetWidgetLife(u)
    endfunction

    function GetMana takes unit u returns real
        return GetUnitState(u, UNIT_STATE_MANA)
    endfunction

    function GetHpReg takes unit u returns real
        return BlzGetUnitRealField(u, UNIT_RF_HIT_POINTS_REGENERATION_RATE) + (s__ExtendableBonus_Get((u ) , ( si__BonusHealthRegen))) // INLINED!!
    endfunction

    function GetManaReg takes unit u returns real
        return BlzGetUnitRealField(u, UNIT_RF_MANA_REGENERATION) + (s__ExtendableBonus_Get((u ) , ( si__BonusManaRegen))) // INLINED!!
    endfunction

    function ConsumeMana takes unit u,real amount returns nothing
        local texttag text
        if amount > 0. then
            set text=CreateTextTag()
            call SetTextTagPermanent(text, false)
            call SetTextTagLifespan(text, 1.0)
            call SetTextTagFadepoint(text, 0.7)
            call SetTextTagColor(text, 128, 100, 236, 180)
            call SetTextTagPos(text, GetUnitX(u) + GetRandomReal(- 18., 18), GetUnitY(u) + GetRandomReal(- 18., 18), 72.)
            call SetTextTagVelocityBJ(text, 32., GetRandomReal(75., 105.))
            call SetTextTagText(text, "-" + R2SHumanReadable(amount), TextTagSize2Height(6))
            set text=null
            call SetUnitState(u, UNIT_STATE_MANA, (GetUnitState((u), UNIT_STATE_MANA)) - amount) // INLINED!!
        endif
    endfunction
    function RestoreMana takes unit u,real amount returns nothing
        local texttag text
        if amount > 0. then
            set text=CreateTextTag()
            call SetTextTagPermanent(text, false)
            call SetTextTagLifespan(text, 1.0)
            call SetTextTagFadepoint(text, 0.7)
            call SetTextTagColor(text, 128, 100, 236, 180)
            call SetTextTagPos(text, GetUnitX(u) + GetRandomReal(- 18., 18), GetUnitY(u) + GetRandomReal(- 18., 18), 72.)
            call SetTextTagVelocityBJ(text, 32., GetRandomReal(75., 105.))
            call SetTextTagText(text, "+" + R2SHumanReadable(amount), TextTagSize2Height(6))
            set text=null
            call SetUnitState(u, UNIT_STATE_MANA, (GetUnitState((u), UNIT_STATE_MANA)) + amount) // INLINED!!
        endif
    endfunction
    function GetDamage takes unit u returns real
        return BlzGetUnitBaseDamage(u, 0) + (s__ExtendableBonus_Get((u ) , ( BONUS_DAMAGE))) + 1. // INLINED!!
    endfunction

    function GetAttackSpeed takes unit u returns real
        return (s__ExtendableBonus_Get((u ) , ( BONUS_ATTACK_SPEED))) // INLINED!!
    endfunction
    function GetUtilProcessingRating takes unit u returns real
        return 1.0
    endfunction

    function GetMovementSpeed takes unit u returns real
        return GetUnitMoveSpeed(u)
    endfunction

    function GetStat takes integer statIndex,unit u returns real
        if statIndex == STAT_INDEX_HP then
            return (GetUnitState((u), UNIT_STATE_MAX_LIFE)) // INLINED!!
        elseif statIndex == STAT_INDEX_HP_REPAIR then
            return GetHpReg(u)
        elseif statIndex == STAT_INDEX_ENERGY then
            return (GetUnitState((u), UNIT_STATE_MAX_MANA)) // INLINED!!
        elseif statIndex == STAT_INDEX_ENERGY_RECHARGE then
            return GetManaReg(u)
        elseif statIndex == STAT_INDEX_FIREPOWER then
            return GetDamage(u)
        elseif statIndex == STAT_INDEX_SYSTEM_POWER then
            return (s__ExtendableBonus_Get((u ) , ( si__BonusSystemPower))) // INLINED!!
        elseif statIndex == STAT_INDEX_SYSTEM_SPEED then
            return (s__ExtendableBonus_Get((u ) , ( si__BonusSystemSpeed))) // INLINED!!
        elseif statIndex == STAT_INDEX_MOBILITY then
            return GetUnitMoveSpeed(u)
        endif
        call BJDebugMsg("Didn't find stat for statIndex=" + I2S(statIndex))
        return - 1.
    endfunction

    function ScalingText takes real value,real percent,integer statIndex returns string
        return Si2Color(statIndex) + R2SHumanReadable(value * percent) + " (" + R2SHumanReadable(percent * 100.) + "% of " + Si2Name(statIndex) + ")|r"
    endfunction

    function playSound3d takes real x,real y,string sound_file_name returns nothing
        local sound snd= CreateSound(sound_file_name, false, true, true, 10, 10, "")
        local integer sound_duration_msec= GetSoundFileDuration(sound_file_name)

        call SetSoundDistances(snd, 600.00, 10000.00)
        call SetSoundDistanceCutoff(snd, 3000.00)
        call SetSoundPosition(snd, x, y, 0)
        call SetSoundDuration(snd, sound_duration_msec)
        call SetSoundVolume(snd, 127)
        call StartSound(snd)
        call KillSoundWhenDone(snd)
        set snd=null
    endfunction

    function IsHero takes unit u returns boolean
        return IsUnitInGroup(u, udg_heroes_all)
    endfunction

    function GetRandomHero takes nothing returns unit
        return BlzGroupUnitAt(udg_heroes_all, GetRandomInt(0, BlzGroupGetSize(udg_heroes_all) - 1))
    endfunction

    function IsUnitTargetableNoFF takes unit target,player friend returns boolean
        return BlzIsUnitSelectable(target) and ( not IsUnitAlly(target, friend) or GetPlayerId(GetOwningPlayer(target)) == PLAYER_NEUTRAL_PASSIVE )
    endfunction

    function AttackMoveTowardsRandomHero takes unit u returns nothing
        local unit hero= (BlzGroupUnitAt(udg_heroes_all, GetRandomInt(0, BlzGroupGetSize(udg_heroes_all) - 1))) // INLINED!!
        call IssuePointOrder(u, "attack", GetUnitX(hero), GetUnitY(hero))
        set hero=null
    endfunction

//library MetroidvaniaUtils ends
//library MissileUtils:
    
    // This is a simple Utils library for the Relativistic Missiles system.
    // Credits:
    //     Sevion for the Alloc module
    //         - www.hiveworkshop.com/threads/snippet-alloc.192348/
    
    
    
    
    

//Implemented from module MissileUtils__LinkedList:

        function s__MGroup_init takes integer this returns integer
            set s__MGroup_next[this]=this
            set s__MGroup_prev[this]=this

            return this
        endfunction

        function s__MGroup_pushBack takes integer this,integer node returns integer
            set s__MGroup_prev[node]=s__MGroup_prev[this]
            set s__MGroup_next[node]=this
            set s__MGroup_next[s__MGroup_prev[this]]=node
            set s__MGroup_prev[this]=node

            return node
        endfunction

        function s__MGroup_pushFront takes integer this,integer node returns integer
            set s__MGroup_prev[node]=this
            set s__MGroup_next[node]=s__MGroup_next[this]
            set s__MGroup_prev[s__MGroup_next[this]]=node
            set s__MGroup_next[this]=node

            return node
        endfunction

        function s__MGroup_pop takes integer this returns nothing
            set s__MGroup_next[s__MGroup_prev[this]]=s__MGroup_next[this]
            set s__MGroup_prev[s__MGroup_next[this]]=s__MGroup_prev[this]
        endfunction
//Implemented from module Alloc:
    
        function s__MGroup_allocate takes nothing returns integer
            local integer this
    
            if ( s__MGroup_Alloc___recycle[(0)] == 0 ) then
                set s__MGroup_Alloc___instanceCount=s__MGroup_Alloc___instanceCount + 1
                set this=s__MGroup_Alloc___instanceCount
            else
                set this=s__MGroup_Alloc___recycle[(0)]
                set s__MGroup_Alloc___recycle[(0)]=s__MGroup_Alloc___recycle[s__MGroup_Alloc___recycle[(0)]]
            endif

    
            return this
        endfunction
    
        function s__MGroup_deallocate takes integer this returns nothing
            set s__MGroup_Alloc___recycle[this]=s__MGroup_Alloc___recycle[(0)]
            set s__MGroup_Alloc___recycle[(0)]=this
        endfunction
        
        
        function s__MGroup_remove takes integer this returns nothing
            call s__MGroup_pop(this)
            call s__MGroup_deallocate(this)
        endfunction

        function s__MGroup_insert takes integer this,integer m returns integer
            local integer node= s__MGroup_pushBack(this,s__MGroup_allocate())

            set s__MGroup_missile[node]=m

            return node
        endfunction
        
        function s__MGroup_create takes nothing returns integer
            return s__MGroup_init((s__MGroup_allocate()))
        endfunction

        
        function s__MissileGroup_destroy takes integer this returns nothing
            call s__MGroup_deallocate(s__MissileGroup_group[this])
            call s__MissileGroup_deallocate(this)
        endfunction
        
        function s__MissileGroup_missileAt takes integer this,integer i returns integer
            local integer node= s__MGroup_next[s__MissileGroup_group[this]]
            local integer j= 0
        
            if s__MissileGroup_size[this] > 0 and i <= s__MissileGroup_size[this] - 1 then
                loop
                    exitwhen j == i
                        set node=s__MGroup_next[node]
                    set j=j + 1
                endloop
                
                return s__MGroup_missile[node]
            else
                return 0
            endif
        endfunction
        
        function s__MissileGroup_remove takes integer this,integer missile returns nothing
            local integer node= s__MGroup_next[s__MissileGroup_group[this]]
        
            loop
                exitwhen node == s__MissileGroup_group[this]
                    if s__MGroup_missile[node] == missile then
                        set s__MissileGroup_size[this]=s__MissileGroup_size[this] - 1
                        call s__MGroup_remove(node)
                        exitwhen true
                    endif
                set node=s__MGroup_next[node]
            endloop
        endfunction
        
        function s__MissileGroup_insert takes integer this,integer missile returns nothing
            set s__MissileGroup_size[this]=s__MissileGroup_size[this] + 1
            call s__MGroup_insert(s__MissileGroup_group[this],missile)
        endfunction
        
        function s__MissileGroup_clear takes integer this returns nothing
            local integer node= s__MGroup_next[s__MissileGroup_group[this]]
            
            loop
                exitwhen node == s__MissileGroup_group[this]
                    call s__MGroup_remove(node)
                set node=s__MGroup_next[node]
            endloop
            
            set s__MissileGroup_size[this]=0
        endfunction
        
        function s__MissileGroup_contains takes integer this,integer missile returns boolean
            local integer node= s__MGroup_next[s__MissileGroup_group[this]]
            local boolean found= false
        
            loop
                exitwhen node == s__MissileGroup_group[this]
                    if s__MGroup_missile[node] == missile then
                        set found=true
                        exitwhen true
                    endif
                set node=s__MGroup_next[node]
            endloop
            
            return found
        endfunction
        
        function s__MissileGroup_addGroup takes integer this,integer source returns nothing
            local integer node= s__MGroup_next[s__MissileGroup_group[source]]
        
            loop
                exitwhen node == s__MissileGroup_group[source]
                    if not s__MissileGroup_contains(this,s__MGroup_missile[node]) then
                        call s__MissileGroup_insert(this,s__MGroup_missile[node])
                    endif
                set node=s__MGroup_next[node]
            endloop
        endfunction
        
        function s__MissileGroup_removeGroup takes integer this,integer source returns nothing
            local integer node= s__MGroup_next[s__MissileGroup_group[source]]
        
            loop
                exitwhen node == s__MissileGroup_group[source]
                    if s__MissileGroup_contains(this,s__MGroup_missile[node]) then
                        call s__MissileGroup_remove(this,s__MGroup_missile[node])
                    endif
                set node=s__MGroup_next[node]
            endloop
        endfunction
        
        function s__MissileGroup_create takes nothing returns integer
            local integer this= s__MissileGroup__allocate()
            
            set s__MissileGroup_group[this]=(s__MGroup_init((s__MGroup_allocate()))) // INLINED!!
            set s__MissileGroup_size[this]=0
            
            return this
        endfunction

    
    
    
    function CreateMissileGroup takes nothing returns integer
        return s__MissileGroup_create()
    endfunction
    
    function DestroyMissileGroup takes integer missiles returns nothing
        if missiles != 0 then
            call s__MissileGroup_clear(missiles)
            call s__MissileGroup_destroy(missiles)
        endif
    endfunction
    
    function MissileGroupGetSize takes integer missiles returns integer
        if missiles != 0 then
            return s__MissileGroup_size[missiles]
        else
            return 0
        endif
    endfunction
    
    function GroupMissileAt takes integer missiles,integer position returns integer
        if missiles != 0 then
            return s__MissileGroup_missileAt(missiles,position)
        else
            return 0
        endif
    endfunction
    
    function ClearMissileGroup takes integer missiles returns nothing
        if missiles != 0 then
            call s__MissileGroup_clear(missiles)
        endif
    endfunction
    
    function IsMissileInGroup takes integer missile,integer missiles returns boolean
        if missiles != 0 and missile != 0 then
            if s__MissileGroup_size[missiles] > 0 then
                return s__MissileGroup_contains(missiles,missile)
            else
                return false
            endif
        else
            return false
        endif
    endfunction
    
    function GroupRemoveMissile takes integer missiles,integer missile returns nothing
        if missiles != 0 and missile != 0 then
            if s__MissileGroup_size[missiles] > 0 then
                call s__MissileGroup_remove(missiles,missile)
            endif
        endif
    endfunction
    
    function GroupAddMissile takes integer missiles,integer missile returns nothing
        if missiles != 0 and missile != 0 then
            if not s__MissileGroup_contains(missiles,missile) then
                call s__MissileGroup_insert(missiles,missile)
            endif
        endif
    endfunction
    
    function GroupPickRandomMissile takes integer missiles returns integer
        if missiles != 0 then
            if s__MissileGroup_size[missiles] > 0 then
                return s__MissileGroup_missileAt(missiles,GetRandomInt(0, s__MissileGroup_size[missiles] - 1))
            else
                return 0
            endif
        else
            return 0
        endif
    endfunction
    
    function FirstOfMissileGroup takes integer missiles returns integer
        if missiles != 0 then
            if s__MissileGroup_size[missiles] > 0 then
                return s__MGroup_missile[s__MGroup_next[s__MissileGroup_group[missiles]]]
            else
                return 0
            endif
        else
            return 0
        endif
    endfunction
    
    function GroupAddMissileGroup takes integer source,integer destiny returns nothing
        if source != 0 and destiny != 0 then
            if s__MissileGroup_size[source] > 0 and source != destiny then
                call s__MissileGroup_addGroup(destiny,source)
            endif
        endif
    endfunction
    
    function GroupRemoveMissileGroup takes integer source,integer destiny returns nothing
        if source != 0 and destiny != 0 then
            if source == destiny then
                call s__MissileGroup_clear(source)
            elseif s__MissileGroup_size[source] > 0 then
                call s__MissileGroup_removeGroup(destiny,source)
            endif
        endif
    endfunction
    
    function GroupEnumMissilesOfType takes integer missiles,integer whichType returns nothing
        local integer i
        local integer missile
        
        if missiles != 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count
                        set missile=s__Missiles_collection[i]
                        
                        if s__Missiles_type[missile] == whichType then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesOfTypeCounted takes integer missiles,integer whichType,integer amount returns nothing
        local integer i
        local integer j= amount
        local integer missile
        
        if missiles != 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count or j == 0
                        set missile=s__Missiles_collection[i]
                        
                        if s__Missiles_type[missile] == whichType then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                        set j=j - 1
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesOfPlayer takes integer missiles,player p returns nothing
        local integer i
        local integer missile
        
        if missiles != 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count
                        set missile=s__Missiles_collection[i]
                        
                        if s__Missiles_owner[missile] == p then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesOfPlayerCounted takes integer missiles,player p,integer amount returns nothing
        local integer i
        local integer j= amount
        local integer missile
        
        if missiles != 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count or j == 0
                        set missile=s__Missiles_collection[i]
                        
                        if s__Missiles_owner[missile] == p then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                        set j=j - 1
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRect takes integer missiles,rect r returns nothing
        local integer i
        local integer missile
        
        if missiles != 0 and r != null then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count
                        set missile=s__Missiles_collection[i]
                        
                        if GetRectMinX(r) <= s__Missiles_x[missile] and s__Missiles_x[missile] <= GetRectMaxX(r) and GetRectMinY(r) <= s__Missiles_y[missile] and s__Missiles_y[missile] <= GetRectMaxY(r) then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRectCounted takes integer missiles,rect r,integer amount returns nothing
        local integer i
        local integer j= amount
        local integer missile
        
        if missiles != 0 and r != null then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count or j == 0
                        set missile=s__Missiles_collection[i]
                        
                        if GetRectMinX(r) <= s__Missiles_x[missile] and s__Missiles_x[missile] <= GetRectMaxX(r) and GetRectMinY(r) <= s__Missiles_y[missile] and s__Missiles_y[missile] <= GetRectMaxY(r) then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                        set j=j - 1
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRangeOfLoc takes integer missiles,location loc,real radius returns nothing
        local real dx
        local real dy
        local integer i
        local integer missile
    
        if missiles != 0 and radius > 0 and loc != null then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count
                        set missile=s__Missiles_collection[i]
                        set dx=s__Missiles_x[missile] - GetLocationX(loc)
                        set dy=s__Missiles_y[missile] - GetLocationY(loc)
                        
                        if SquareRoot(dx * dx + dy * dy) <= radius then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRangeOfLocCounted takes integer missiles,location loc,real radius,integer amount returns nothing
        local real dx
        local real dy
        local integer i
        local integer j= amount
        local integer missile
    
        if missiles != 0 and radius > 0 and loc != null then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count or j == 0
                        set missile=s__Missiles_collection[i]
                        set dx=s__Missiles_x[missile] - GetLocationX(loc)
                        set dy=s__Missiles_y[missile] - GetLocationY(loc)
                        
                        if SquareRoot(dx * dx + dy * dy) <= radius then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                        set j=j - 1
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRange takes integer missiles,real x,real y,real radius returns nothing
        local real dx
        local real dy
        local integer i
        local integer missile
    
        if missiles != 0 and radius > 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count
                        set missile=s__Missiles_collection[i]
                        set dx=s__Missiles_x[missile] - x
                        set dy=s__Missiles_y[missile] - y
                        
                        if SquareRoot(dx * dx + dy * dy) <= radius then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                    set i=i + 1
                endloop
            endif
        endif
    endfunction
    
    function GroupEnumMissilesInRangeCounted takes integer missiles,real x,real y,real radius,integer amount returns nothing
        local real dx
        local real dy
        local integer i
        local integer j= amount
        local integer missile
    
        if missiles != 0 and radius > 0 then
            if s__Missiles_count > - 1 then
                set i=0
                
                if s__MissileGroup_size[missiles] > 0 then
                    call s__MissileGroup_clear(missiles)
                endif
                
                loop
                    exitwhen i > s__Missiles_count or j == 0
                        set missile=s__Missiles_collection[i]
                        set dx=s__Missiles_x[missile] - x
                        set dy=s__Missiles_y[missile] - y
                        
                        if SquareRoot(dx * dx + dy * dy) <= radius then
                            call s__MissileGroup_insert(missiles,missile)
                        endif
                        set j=j - 1
                    set i=i + 1
                endloop
            endif
        endif
    endfunction

//library MissileUtils ends
//library KnockbackTZ:


function updateWalkablePoint takes real x,real y returns nothing
    call SetItemPosition(udg_CP_Item, x, y)
    call MoveLocation(walkablePoint, GetItemX(udg_CP_Item), GetItemY(udg_CP_Item))
    call SetItemVisible(udg_CP_Item, false)
endfunction
function isPointWalkable takes real x,real y returns boolean
    call updateWalkablePoint(x , y)
    return RAbsBJ(x - GetLocationX(walkablePoint)) < KnockbackTZ__WALKABLE_EPSILON and RAbsBJ(y - GetLocationY(walkablePoint)) < KnockbackTZ__WALKABLE_EPSILON
endfunction
function isPointWalableNoUpdate takes real x,real y returns boolean
    return x == GetLocationX(walkablePoint) and y == GetLocationY(walkablePoint)
endfunction
function walkablePointsIn takes real x,real y,integer size returns integer
    local integer walkablePoints= 0
    local integer i= 0
    local integer sizeCubed= size * size
    local real halfSize= ( size / 2 ) * 32.
    local real tx
    local real ty
    if isPointWalkable(x , y) then
        loop
            exitwhen i == sizeCubed
            set tx=x - halfSize + ModuloInteger(i, size) * 32.
            set ty=y - halfSize + ( i / size ) * 32.
            if isPointWalkable(tx , ty) then
                set walkablePoints=walkablePoints + 1
            endif
            set i=i + 1
        endloop
    endif
    return walkablePoints
endfunction

function IsWalkableWithCollisionSize takes real x,real y,real c returns boolean
    return isPointWalkable(x , y) and isPointWalkable(x + c , y + c) and isPointWalkable(x - c , y + c) and isPointWalkable(x - c , y - c) and isPointWalkable(x + c , y - c)
endfunction
    //313 units over 0.36 seconds
    //(313^2)/(0.78*400)
        //private static group knockbackUnits

        function s__KnockbackTZ_endKnockback takes integer this,unit u returns nothing
            call GroupRemoveUnit(KnockbackTZ__knockbackUnits, u)
            set s__KnockbackTZ_timeLeft[this]=0.
            set s__KnockbackTZ_vx[this]=0.
            set s__KnockbackTZ_vy[this]=0.
            set s__KnockbackTZ_fx[this]=0.
            set s__KnockbackTZ_fy[this]=0.
            set s__KnockbackTZ_collision[this]=0.
            set s__KnockbackTZ_fPercent[this]=DEFAULT_FRICTION
            set s__KnockbackTZ_bounce[this]=KnockbackTZ__DEFAULT_BOUNCEY
            set s__KnockbackTZ_ticksSinceLastUpdate[this]=0
            if not (IsUnitInGroup((u), udg_heroes_all)) and not UnitAlive(u) then // INLINED!!
                set s__KnockbackTZ_mass[this]=0.
                set s__KnockbackTZ_massOverridden[this]=false
            endif
            if BlzGroupGetSize(KnockbackTZ__knockbackUnits) == 0 then
                call PauseTimer(s__KnockbackTZ_updTimer)
            endif
        endfunction

        function s__KnockbackTZ_doKnockback takes unit u,real angle,real speed,real time,real friction,real frictionPercentOfSpeed,real collider returns integer
            local integer this= GetUnitUserData(u)
            local real speedPerTick= speed * KnockbackTZ__TICK_RATE
            local real colSize= BlzGetUnitCollisionSize(u)
            if not s__KnockbackTZ_massOverridden[this] then
                set s__KnockbackTZ_mass[this]=10. * colSize
            endif
            set s__KnockbackTZ_timeLeft[this]=RMaxBJ(s__KnockbackTZ_timeLeft[this], time)
            set s__KnockbackTZ_vx[this]=s__KnockbackTZ_vx[this] + Cos(angle) * speedPerTick
            set s__KnockbackTZ_vy[this]=s__KnockbackTZ_vy[this] + Sin(angle) * speedPerTick
            set s__KnockbackTZ_fx[this]=s__KnockbackTZ_fx[this] + Cos(angle) * friction
            set s__KnockbackTZ_fy[this]=s__KnockbackTZ_fy[this] + Sin(angle) * friction
            set s__KnockbackTZ_fPercent[this]=frictionPercentOfSpeed
            set s__KnockbackTZ_collision[this]=RMaxBJ(s__KnockbackTZ_collision[this], collider)
            if BlzGroupGetSize(KnockbackTZ__knockbackUnits) == 0 then
                call TriggerEvaluate(st___prototype1[(2)]) // INLINED!!
            endif
            call GroupAddUnit(KnockbackTZ__knockbackUnits, u)
            return this
        endfunction

        function s__KnockbackTZ_doKnockbackSimple takes unit u,real angle,real speed,real time returns integer
            return s__KnockbackTZ_doKnockback(u , angle , speed , time , DEFAULT_FRICTION , KnockbackTZ__DEFAULT_FRICTION_PERCENT , KnockbackTZ__DEFAULT_COLLISION)
        endfunction

        function s__KnockbackTZ_unitCollision takes integer sourceKnock,unit source,unit u returns nothing
            
        endfunction 

        function s__KnockbackTZ_checkCollision takes integer this,unit source returns nothing
            local real x= GetUnitX(source)
            local real y= GetUnitY(source)
            local real col= BlzGetUnitCollisionSize(source)
            local real angle
            local integer other
            //local real 
            local unit u
            local group g= CreateGroup()
            call GroupEnumUnitsInRange(g, x, y, col + s__KnockbackTZ_collision[this] + KnockbackTZ__CHECK_RADIUS, null)

            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                if IsUnitInRange(source, u, s__KnockbackTZ_collision[this]) then
                    set other=GetUnitUserData(u)
                    if IsUnitInGroup(u, KnockbackTZ__knockbackUnits) then
                    else
                    endif
                    if s__KnockbackTZ_mass[other] > 0. then

                    endif
                    set angle=Atan2(GetUnitY(u) - y, GetUnitX(u) - x)
                    //call doKnockback(u, angle, )
                endif
                call GroupRemoveUnit(g, u)
            endloop
        endfunction

        function s__KnockbackTZ_tickUnit takes integer this,unit u returns nothing
            local real x= GetUnitX(u)
            local real y= GetUnitY(u)
            local real col= BlzGetUnitCollisionSize(u)
            local real newX
            local real newY
            local real tickVx
            local real tickVy
            local integer i= 0
            set s__KnockbackTZ_ticksSinceLastUpdate[this]=s__KnockbackTZ_ticksSinceLastUpdate[this] + 1
            set tickVx=s__KnockbackTZ_vx[this] * s__KnockbackTZ_ticksSinceLastUpdate[this]
            set tickVy=s__KnockbackTZ_vy[this] * s__KnockbackTZ_ticksSinceLastUpdate[this]
            set newX=x + tickVx
            set newY=y + tickVy
            //call BJDebugMsg("Tick vx=" + R2S(tickVx) + ", vy=" + R2S(tickVy) + ", fx=" + R2S(fx) + ", fy=" + R2S(fy))
            if not IsWalkableWithCollisionSize(newX , newY , col) and s__KnockbackTZ_bounce[this] then
                if IsWalkableWithCollisionSize(x - tickVx , newY , col) then
                    set s__KnockbackTZ_vx[this]=- s__KnockbackTZ_vx[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                    set s__KnockbackTZ_fx[this]=- s__KnockbackTZ_fx[this]
                    set s__KnockbackTZ_vy[this]=s__KnockbackTZ_vy[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                elseif IsWalkableWithCollisionSize(newX , y - tickVy , col) then
                    set s__KnockbackTZ_vx[this]=s__KnockbackTZ_vx[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                    set s__KnockbackTZ_vy[this]=- s__KnockbackTZ_vy[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                    set s__KnockbackTZ_fy[this]=- s__KnockbackTZ_fy[this]
                else
                    set s__KnockbackTZ_vx[this]=- s__KnockbackTZ_vx[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                    set s__KnockbackTZ_vy[this]=- s__KnockbackTZ_vy[this] * KnockbackTZ__BOUNCE_VELOCITY_LOSS
                    set s__KnockbackTZ_fx[this]=- s__KnockbackTZ_fx[this]
                    set s__KnockbackTZ_fy[this]=- s__KnockbackTZ_fy[this]
                endif
            endif
            if s__KnockbackTZ_collision[this] > 0. then
                call s__KnockbackTZ_checkCollision(this,u)
            endif
            set newX=x + tickVx
            set newY=y + tickVy
            call SetUnitX(u, newX)
            call SetUnitY(u, newY)
            loop
                set s__KnockbackTZ_vx[this]=s__KnockbackTZ_vx[this] * s__KnockbackTZ_fPercent[this] - s__KnockbackTZ_fx[this]
                set s__KnockbackTZ_vy[this]=s__KnockbackTZ_vy[this] * s__KnockbackTZ_fPercent[this] - s__KnockbackTZ_fy[this]
                set i=i + 1
                exitwhen i == s__KnockbackTZ_ticksSinceLastUpdate[this]
            endloop
            set s__KnockbackTZ_timeLeft[this]=s__KnockbackTZ_timeLeft[this] - KnockbackTZ__TICK_RATE
            set s__KnockbackTZ_ticksSinceLastUpdate[this]=0
            if s__KnockbackTZ_timeLeft[this] <= 0. then
                call s__KnockbackTZ_endKnockback(this,u)
            endif
        endfunction

        function s__KnockbackTZ_skipUnit takes integer this,unit u returns nothing
            set s__KnockbackTZ_ticksSinceLastUpdate[this]=s__KnockbackTZ_ticksSinceLastUpdate[this] + 1
        endfunction

        function s__KnockbackTZ_update takes nothing returns nothing
            local unit u
            local integer i= s__KnockbackTZ_lastProcessed
            local integer processed= 0
            local integer groupSize= BlzGroupGetSize(KnockbackTZ__knockbackUnits)
            local boolean shouldSetLastIfOverflow= true
            //call BJDebugMsg("upd, lastProcessed=" + I2S(lastProcessed) + ", GroupSize=" + I2S(groupSize))
            if i >= groupSize then
                set i=0
                set s__KnockbackTZ_lastProcessed=0
            endif
            loop
                set u=BlzGroupUnitAt(KnockbackTZ__knockbackUnits, i)
                if processed < KnockbackTZ__MAX_UPDATES_PER_TICK then
                    call s__KnockbackTZ_tickUnit((GetUnitUserData(u)),u)
                else
                    if shouldSetLastIfOverflow then
                        set shouldSetLastIfOverflow=false
                        set s__KnockbackTZ_lastProcessed=i
                    endif
                    call s__KnockbackTZ_skipUnit((GetUnitUserData(u)),u)
                endif
                set processed=processed + 1
                set i=i + 1
                if i == groupSize then
                    set i=0
                endif
                exitwhen processed >= groupSize - 1
            endloop
        endfunction

        function s__KnockbackTZ_onInit takes nothing returns nothing
            set s__KnockbackTZ_updTimer=CreateTimer()
        endfunction

    function KnockbackTZ__StartKnockback takes nothing returns nothing
        call TimerStart(s__KnockbackTZ_updTimer, KnockbackTZ__TICK_RATE, true, function s__KnockbackTZ_update)
    endfunction

//library KnockbackTZ ends
//library MetroidvaniaUi:

function frameToFrameId takes framehandle f returns integer
    if f == ui_frame[UI_STATS] then
        return UI_STATS
    elseif f == ui_frame[UI_MAP] then
        return UI_MAP
    elseif f == ui_hpBarText then
        return 0
    elseif f == ui_energyBarText then
        return 2
    elseif f == ui_frame[UI_STATS_HP] then
        return UI_STATS_HP
    elseif f == ui_frame[UI_STATS_HP + 2] then
        return UI_STATS_HP + 2
    elseif f == ui_frame[UI_STATS_HP_REPAIR] then
        return UI_STATS_HP_REPAIR
    elseif f == ui_frame[UI_STATS_HP_REPAIR + 2] then
        return UI_STATS_HP_REPAIR + 2
    elseif f == ui_frame[UI_STATS_ENERGY] then
        return UI_STATS_ENERGY
    elseif f == ui_frame[UI_STATS_ENERGY + 2] then
        return UI_STATS_ENERGY + 2
    elseif f == ui_frame[UI_STATS_ENERGY_RECHARGE] then
        return UI_STATS_ENERGY_RECHARGE
    elseif f == ui_frame[UI_STATS_ENERGY_RECHARGE + 2] then
        return UI_STATS_ENERGY_RECHARGE + 2
    elseif f == ui_frame[UI_STATS_FIREPOWER] then
        return UI_STATS_FIREPOWER
    elseif f == ui_frame[UI_STATS_FIREPOWER + 2] then
        return UI_STATS_FIREPOWER + 2
    elseif f == ui_frame[UI_STATS_SYSTEM_POWER] then
        return UI_STATS_SYSTEM_POWER
    elseif f == ui_frame[UI_STATS_SYSTEM_POWER + 2] then
        return UI_STATS_SYSTEM_POWER + 2
    elseif f == ui_frame[UI_STATS_SYSTEM_SPEED] then
        return UI_STATS_SYSTEM_SPEED
    elseif f == ui_frame[UI_STATS_SYSTEM_SPEED + 2] then
        return UI_STATS_SYSTEM_SPEED + 2
    elseif f == ui_frame[UI_STATS_MOBILITY] then
        return UI_STATS_MOBILITY
    elseif f == ui_frame[UI_STATS_MOBILITY + 2] then
        return UI_STATS_MOBILITY + 2
    elseif f == ui_frame[UI_STATS_CORES_AVAILABLE] then
        return UI_STATS_CORES_AVAILABLE
    elseif f == ui_frame[UI_TARGET_DAMAGE_TEXT] then
        return UI_TARGET_DAMAGE_TEXT
    elseif f == ui_frame[UI_TARGET_MOVEMENT_TEXT] then
        return UI_TARGET_MOVEMENT_TEXT
    endif
    return 0
endfunction

function ui2Stat takes integer uiStatIndex returns integer
    if uiStatIndex == UI_STATS_HP then
        return STAT_INDEX_HP
    elseif uiStatIndex == UI_STATS_HP_REPAIR then
        return STAT_INDEX_HP_REPAIR
    elseif uiStatIndex == UI_STATS_ENERGY then
        return STAT_INDEX_ENERGY
    elseif uiStatIndex == UI_STATS_ENERGY_RECHARGE then
        return STAT_INDEX_ENERGY_RECHARGE
    elseif uiStatIndex == UI_STATS_FIREPOWER then
        return STAT_INDEX_FIREPOWER
    elseif uiStatIndex == UI_STATS_SYSTEM_POWER then
        return STAT_INDEX_SYSTEM_POWER
    elseif uiStatIndex == UI_STATS_SYSTEM_SPEED then
        return STAT_INDEX_SYSTEM_SPEED
    elseif uiStatIndex == UI_STATS_MOBILITY then
        return STAT_INDEX_MOBILITY
    endif
    return - 1
endfunction

function ui_statIndexToString takes integer statIndex returns string
    return Si2Name(ui2Stat(statIndex))
endfunction

function frameToHeroAction takes framehandle actionButton,player p returns integer
    if actionButton == ui_frame[UI_ATTACK] then
        return (s__MetroidvaniaController_attack[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    elseif actionButton == ui_frame[UI_ATTACK_ALT] then
        return (s__MetroidvaniaController_attackAlt[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    elseif actionButton == ui_frame[UI_UTIL1] then
        return (s__MetroidvaniaController_util1[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    elseif actionButton == ui_frame[UI_UTIL2] then
        return (s__MetroidvaniaController_util2[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    elseif actionButton == ui_frame[UI_DASH] then
        return (s__MetroidvaniaController_dash[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    elseif actionButton == ui_frame[UI_PASSIVE1] then
        //return MetroidvaniaController.getMetroidvaniaController(p).getAttackAlt()
    elseif actionButton == ui_frame[UI_PASSIVE2] then
        //return MetroidvaniaController.getMetroidvaniaController(p).getAttackAlt()
    elseif actionButton == ui_frame[UI_INTERACT] then
        return (s__MetroidvaniaController_interact[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
    endif
    return 0
endfunction

//function uiFieldValue takes integer fieldBase, 

function setUiVisible takes boolean visibile returns nothing
    call BlzFrameSetVisible(ui_mainBackDrop, visibile)
    call BlzFrameSetVisible(ui_statsBackdrop, visibile)
    call BlzFrameSetVisible(ui_targetBackdrop, visibile)
    call BlzFrameSetVisible(ui_hpBarFull, visibile)
    call BlzFrameSetVisible(ui_energyBarFull, visibile)
endfunction

function updateApplyCoreBtn takes player p,integer l__coresAvailable,integer uiStatIndex returns nothing
    if l__coresAvailable >= (1 + (s__HeroStatsCore_coresApplied[GetPlayerId(((p ) )) * STAT_COUNT + ( ( ui2Stat(uiStatIndex)))]) / 3) then // INLINED!!
        call BlzFrameSetTexture(ui_frame[uiStatIndex + 3], STAT_BTN_ADD, 0, true)
        call BlzFrameSetEnable(ui_frame[uiStatIndex + 2], true)
    else
        call BlzFrameSetTexture(ui_frame[uiStatIndex + 3], STAT_BTN_ADD_DIS, 0, true)
        call BlzFrameSetEnable(ui_frame[uiStatIndex + 2], false)
    endif
endfunction

function updateStatsPanel takes player p returns nothing
    local unit u
    local integer l__coresAvailable
    if p == GetLocalPlayer() then
        set u=(s__MetroidvaniaController_u[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) // INLINED!!
        set l__coresAvailable=(coresAvailable[GetPlayerId((p))]) // INLINED!!
        call BlzFrameSetText(ui_frame[UI_STATS_HP], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_HP) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_HP_REPAIR], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_HP_REPAIR) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_ENERGY], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_ENERGY) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_ENERGY_RECHARGE], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_ENERGY_RECHARGE) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_FIREPOWER], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_FIREPOWER) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_SYSTEM_POWER], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_SYSTEM_POWER) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_SYSTEM_SPEED], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_SYSTEM_SPEED) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_MOBILITY], R2SHumanReadable(GetStat(ui2Stat(UI_STATS_MOBILITY) , u)))
        call BlzFrameSetText(ui_frame[UI_STATS_CORES_AVAILABLE], "Cores Available: " + I2S(l__coresAvailable))

        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_HP)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_HP_REPAIR)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_ENERGY)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_ENERGY_RECHARGE)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_FIREPOWER)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_SYSTEM_POWER)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_SYSTEM_SPEED)
        call updateApplyCoreBtn(p , l__coresAvailable , UI_STATS_MOBILITY)
    endif
    set u=null
endfunction

function updateLocalStatsPanel takes nothing returns nothing
    call updateStatsPanel(GetLocalPlayer())
endfunction

//set udg_t_string1 = SubString("012345678", 0, 5) -> 01234
function updateBar takes framehandle barFrame,framehandle textFrame,real max,real curr returns nothing
    local integer barValue= R2I(curr / max * 100. + 0.01)
    call BlzFrameSetText(textFrame, "|cffffffff" + (I2S(R2I(((curr)*1.0) + 0.1))) + "/" + (I2S(R2I(((max)*1.0) + 0.1)))) // INLINED!!
    call BlzFrameSetValue(barFrame, barValue)
endfunction

function updateCooldown takes integer uiButtonIndex,real totalCooldown,real remainingCooldown returns nothing
    local integer cdValue= R2I(remainingCooldown / totalCooldown * 100. + 0.01)
    call BlzFrameSetValue(ui_frame[uiButtonIndex + UI_ABIL_COOLDOWN_OFFSET], cdValue)
endfunction

function clearUiTarget takes integer controller returns nothing
    call BlzFrameSetText(ui_frame[UI_TARGET_NAME], "Target: N/A")
    call BlzFrameSetText(ui_frame[UI_TARGET_HP_BAR_TEXT], "N/A")
    call BlzFrameSetText(ui_frame[UI_TARGET_DAMAGE_TEXT], "N/A")
    call BlzFrameSetText(ui_frame[UI_TARGET_MOVEMENT_TEXT], "N/A")
    call BlzFrameSetValue(ui_frame[UI_TARGET_HP_BAR_FULL], 0)
endfunction
function updateTarget takes integer controller returns nothing
    local unit u= (s__MetroidvaniaController_target[(controller)]) // INLINED!!
    call updateBar(ui_frame[UI_TARGET_HP_BAR_FULL] , ui_frame[UI_TARGET_HP_BAR_TEXT] , (GetUnitState((u), UNIT_STATE_MAX_LIFE)) , (GetWidgetLife((u)))) // INLINED!!
    call BlzFrameSetText(ui_frame[UI_TARGET_DAMAGE_TEXT], (I2S(R2I(((GetDamage(u))*1.0) + 0.1)))) // INLINED!!
    call BlzFrameSetText(ui_frame[UI_TARGET_MOVEMENT_TEXT], (I2S(R2I(((GetUnitMoveSpeed(u))*1.0) + 0.1)))) // INLINED!!
    if UnitAlive(u) then
        set targetDeadTicks=0
    else
        set targetDeadTicks=targetDeadTicks + 1
        //If dead for more than X ticks, deselect
        if targetDeadTicks > UI_TARGET_DEAD_TICKS_DESELECT then
            set s__MetroidvaniaController_target[(controller)]=(null) // INLINED!!
            call clearUiTarget(controller)
        endif
    endif
endfunction

function setUiTarget takes unit u returns nothing
    call BlzFrameSetText(ui_frame[UI_TARGET_NAME], "Target: " + GetUnitName(u))
    call BlzFrameSetText(ui_frame[UI_TARGET_DAMAGE_TEXT], (I2S(R2I(((GetDamage(u))*1.0) + 0.1)))) // INLINED!!
    call BlzFrameSetText(ui_frame[UI_TARGET_MOVEMENT_TEXT], (I2S(R2I(((GetUnitMoveSpeed(u))*1.0) + 0.1)))) // INLINED!!
    set targetDeadTicks=0
endfunction
function updateTargetField takes integer controller,integer fieldIndex returns nothing

endfunction

function updateUi takes nothing returns nothing
    local player p= GetLocalPlayer()
    local integer controller= sc__MetroidvaniaController_getMetroidvaniaController(p)
    local unit u= (s__MetroidvaniaController_u[(controller)]) // INLINED!!
    call updateBar(ui_hpBarFull , ui_hpBarText , (GetUnitState((u), UNIT_STATE_MAX_LIFE)) , (GetWidgetLife((u)))) // INLINED!!
    call updateBar(ui_energyBarFull , ui_energyBarText , (GetUnitState((u), UNIT_STATE_MAX_MANA)) , (GetUnitState((u), UNIT_STATE_MANA))) // INLINED!!
    if (s__MetroidvaniaController_target[(controller)]) != null then // INLINED!!
        call updateTarget(controller)
    endif
    set u=null
    set p=null
endfunction


//---- UI TOOPTIPS

function updateUITooltip takes player p,framehandle f returns nothing
    local integer frameId= frameToFrameId(f)
    call BlzFrameSetPoint(ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOM, f, FRAMEPOINT_TOP, 0., UI_MAIN_PADDING)
    call BlzFrameSetSize(ui_frame[UI_TOOLTIP_FRAME], UI_TOOLTIP_BASE_W, UI_TOOLTIP_BASE_H - 1.5 * UI_TOOLTIP_ICON_H + 0.0003 * StringLength(ui_strings[frameId + 1]))
    
    call BlzFrameSetText(ui_frame[UI_TOOLTIP_HEADER], ui_strings[frameId])
    call BlzFrameSetText(ui_frame[UI_TOOLTIP_TEXT], ui_strings[frameId + 1])
endfunction
function showUITooltip takes nothing returns nothing
    if GetTriggerPlayer() == GetLocalPlayer() then
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_FRAME], true)
        
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA], false)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA_ICON_FRAME], false)
        
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN], false)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN_ICON_FRAME], false)
        call updateUITooltip(GetTriggerPlayer() , BlzGetTriggerFrame())
    endif
endfunction

// ---- ABILITY-TOOLTIP ----
function updateTooltipContent takes string header,string text,real manacost,real cooldown returns nothing
    call BlzFrameSetText(ui_frame[UI_TOOLTIP_HEADER], header)
    call BlzFrameSetText(ui_frame[UI_TOOLTIP_TEXT], text)
    if manacost == 0. then
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA], false)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA_ICON_FRAME], false)
    else
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA], true)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_MANA_ICON_FRAME], true)
        call BlzFrameSetText(ui_frame[UI_TOOLTIP_MANA], R2SHumanReadable(manacost))
    endif
    if cooldown == 0. then
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN], false)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN_ICON_FRAME], false)
    else
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN], true)
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_COOLDOWN_ICON_FRAME], true)
        call BlzFrameSetText(ui_frame[UI_TOOLTIP_COOLDOWN], R2SW(cooldown, 0, 2) + " seconds")
    endif
endfunction

function updateTooltipMain takes player p,framehandle frame returns nothing
    local integer a= frameToHeroAction(frame , p)
    local integer tooltipLength
    if a != 0 then
        set tooltipLength=StringLength(sc__MetroidvaniaController__ActionInterface_abilityText(a))
        call BlzFrameSetPoint(ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOM, frame, FRAMEPOINT_TOP, 0., UI_MAIN_PADDING)
        call BlzFrameSetSize(ui_frame[UI_TOOLTIP_FRAME], UI_TOOLTIP_BASE_W, UI_TOOLTIP_BASE_H + 0.000255 * tooltipLength)
        call updateTooltipContent(sc__MetroidvaniaController__ActionInterface_abilityName(a) , sc__MetroidvaniaController__ActionInterface_abilityText(a) , s__HeroActionBase_energyCost[a] , s__CooldownDetails_actionCooldown[s__HeroActionBase_cooldownDetails[a]])
    else
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_FRAME], false)
    endif
endfunction

function updateTooltipTrigFunc takes nothing returns nothing
    if GetTriggerPlayer() == GetLocalPlayer() then
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_FRAME], true)
        call updateTooltipMain(GetTriggerPlayer() , BlzGetTriggerFrame())
    endif
endfunction

function hideTooltipMouseLeaveButton takes nothing returns nothing
    //call BJDebugMsg("Hide tooltip! " + I2S(GetRandomInt(0, 999)))
    if GetTriggerPlayer() == GetLocalPlayer() then
        call BlzFrameSetVisible(ui_frame[UI_TOOLTIP_FRAME], false)
    endif
endfunction
function clickUIButton takes nothing returns nothing
    local player p= GetTriggerPlayer()
    local framehandle f= BlzGetTriggerFrame()
    call sc__MetroidvaniaController_tryToExecuteAction(sc__MetroidvaniaController_getMetroidvaniaController(p),frameToHeroAction(f , p))
    if p == GetLocalPlayer() then
        call BlzFrameSetEnable(f, false)
        call BlzFrameSetEnable(f, true)
    endif
    set p=null
    set f=null
endfunction
//---- TOOLTIP END ----

//-------------- Toggle Stats Planel ------------
function clickToggleStatsPanel takes nothing returns nothing
    call BlzFrameSetEnable(ui_frame[UI_STATS], false)
    call BlzFrameSetEnable(ui_frame[UI_STATS], true)
    if GetTriggerPlayer() == GetLocalPlayer() then
        if BlzFrameIsVisible(ui_statsBackdrop) then
            call BlzFrameSetVisible(ui_statsBackdrop, false)
            call BlzFrameSetTexture(ui_frame[UI_STATS + 2], ICON_STATS_OPEN, 0, true)
        else
            call updateStatsPanel(GetTriggerPlayer())
            call BlzFrameSetVisible(ui_statsBackdrop, true)
            call BlzFrameSetTexture(ui_frame[UI_STATS + 2], ICON_STATS_CLOSE, 0, true)
        endif
    endif
endfunction

function addStatFrames takes integer frameBase,string iconPath,integer placementX,integer placementY returns nothing
    local real yTop= - UI_STAT_INSET_TOP - ( 1 + placementY ) * ( UI_STAT_ICON_H + UI_MAIN_PADDING )
    local real yBottom= yTop - UI_STAT_ICON_H
    local real yCenter= ( yTop + yBottom ) / 2.0
    local integer iconIndex= frameBase + 1
    local integer textIndex= frameBase
    local integer buttonIndex= frameBase + 2
    local integer btnIconIndex= frameBase + 3
    
    //call BlzFrameSetAbsPoint(ui_statsBackdrop, FRAMEPOINT_TOPLEFT, UI_STATS_LEFT, UI_MAIN_TOP)
    //call BlzFrameSetAbsPoint(ui_statsBackdrop, FRAMEPOINT_BOTTOMRIGHT, UI_STATS_RIGHT, UI_MAIN_BOT)
    
    local real xBase= UI_STAT_INSET_SIDES
    local real xButtonCenter
    //--- LEFT COLUMN ---
    if placementX == 0 then
        set ui_frame[iconIndex]=BlzCreateFrameByType("BACKDROP", "stat" + I2S(frameBase), ui_statsBackdrop, "", 0)
        call BlzFrameSetPoint(ui_frame[iconIndex], FRAMEPOINT_TOPLEFT, ui_statsBackdrop, FRAMEPOINT_TOPLEFT, xBase, yTop)
        call BlzFrameSetPoint(ui_frame[iconIndex], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOPLEFT, xBase + UI_STAT_ICON_W, yBottom)
        call BlzFrameSetTexture(ui_frame[iconIndex], iconPath, 0, true)

        set xButtonCenter=- UI_MAIN_PADDING - UI_STAT_ICON_ADD_SIZE / 2.
        set xBase=UI_STATS_LEFT + xBase + UI_STAT_ICON_W
        set ui_frame[textIndex]=BlzCreateFrameByType("TEXT", "statText" + I2S(frameBase), ui_statsBackdrop, "", 0)
        call BlzFrameSetScale(ui_frame[textIndex], ui_stat_text_scale)
        call BlzFrameSetAbsPoint(ui_frame[textIndex], FRAMEPOINT_TOPLEFT, xBase, UI_MAIN_TOP + yTop)
        call BlzFrameSetAbsPoint(ui_frame[textIndex], FRAMEPOINT_BOTTOMRIGHT, UI_STATS_CENTER + xButtonCenter - UI_STAT_ICON_ADD_SIZE / 2., UI_MAIN_TOP + yBottom)
        call BlzFrameSetText(ui_frame[textIndex], "17")
        //call BlzFrameSetEnable(ui_frame[textIndex], false)
        
        call BlzFrameSetTextAlignment(ui_frame[textIndex], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
        //call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_ENTER)
        //call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_LEAVE)

        //set xBase = - UI_MAIN_PADDING - UI_STAT_ICON_ADD_SIZE / 2.
        set ui_frame[buttonIndex]=BlzCreateFrame("ScriptDialogButton", ui_statsBackdrop, 0, 0)
        call BlzFrameSetPoint(ui_frame[buttonIndex], FRAMEPOINT_CENTER, ui_statsBackdrop, FRAMEPOINT_TOP, xButtonCenter, yCenter)
        call BlzFrameSetSize(ui_frame[buttonIndex], UI_STAT_ICON_ADD_SIZE, UI_STAT_ICON_ADD_SIZE)

        //call BlzFrameSetPoint(ui_frame[buttonIndex], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOP, xBase + UI_STAT_ICON_H, yBottom)

        set ui_frame[btnIconIndex]=BlzCreateFrameByType("BACKDROP", "statPlusBackdrop" + I2S(frameBase), ui_frame[buttonIndex], "", 0)
        call BlzFrameSetAllPoints(ui_frame[btnIconIndex], ui_frame[buttonIndex])
        call BlzFrameSetTexture(ui_frame[btnIconIndex], STAT_BTN_ADD, 0, true)
    else //--- RIGHT COLUMN ---
        set xBase=UI_MAIN_PADDING
        set ui_frame[iconIndex]=BlzCreateFrameByType("BACKDROP", "stat" + I2S(frameBase), ui_statsBackdrop, "", 0)
        call BlzFrameSetPoint(ui_frame[iconIndex], FRAMEPOINT_TOPLEFT, ui_statsBackdrop, FRAMEPOINT_TOP, xBase, yTop)
        call BlzFrameSetPoint(ui_frame[iconIndex], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOP, xBase + UI_STAT_ICON_W, yBottom)
        call BlzFrameSetTexture(ui_frame[iconIndex], iconPath, 0, true)

        set xButtonCenter=- UI_STAT_INSET_SIDES - UI_STAT_ICON_ADD_SIZE * 0.52
        set xBase=UI_STATS_CENTER + UI_STAT_ICON_W + UI_MAIN_PADDING
        set ui_frame[textIndex]=BlzCreateFrameByType("TEXT", "statText" + I2S(frameBase), ui_statsBackdrop, "", 0)
        call BlzFrameSetScale(ui_frame[textIndex], ui_stat_text_scale)
        call BlzFrameSetAbsPoint(ui_frame[textIndex], FRAMEPOINT_TOPLEFT, xBase, UI_MAIN_TOP + yTop)
        call BlzFrameSetAbsPoint(ui_frame[textIndex], FRAMEPOINT_BOTTOMRIGHT, UI_STATS_RIGHT + xButtonCenter - 0.5 * UI_STAT_ICON_ADD_SIZE, UI_MAIN_TOP + yBottom)
        //call BlzFrameSetPoint(ui_frame[textIndex], FRAMEPOINT_TOPLEFT, ui_statsBackdrop, FRAMEPOINT_TOP, xBase, yTop)
        //call BlzFrameSetPoint(ui_frame[textIndex], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOPRIGHT, -UI_STAT_ICON_H - UI_MAIN_PADDING - UI_STAT_INSET_SIDES, yBottom)
        call BlzFrameSetText(ui_frame[textIndex], "4711")
        //call BlzFrameSetEnable(ui_frame[textIndex], false)
        
        call BlzFrameSetTextAlignment(ui_frame[textIndex], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
        //call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_ENTER)
        //call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_LEAVE)

        set ui_frame[buttonIndex]=BlzCreateFrame("ScriptDialogButton", ui_statsBackdrop, 0, 0)
        call BlzFrameSetPoint(ui_frame[buttonIndex], FRAMEPOINT_CENTER, ui_statsBackdrop, FRAMEPOINT_TOPRIGHT, xButtonCenter, yCenter)
        call BlzFrameSetSize(ui_frame[buttonIndex], UI_STAT_ICON_ADD_SIZE, UI_STAT_ICON_ADD_SIZE)

        //set xBase = -UI_STAT_INSET_SIDES -UI_STAT_ICON_H - UI_MAIN_PADDING
        //call BlzFrameSetPoint(ui_frame[frameBase+2], FRAMEPOINT_TOPLEFT, ui_statsBackdrop, FRAMEPOINT_TOPRIGHT, xBase, yTop)
        //call BlzFrameSetPoint(ui_frame[frameBase+2], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOPRIGHT, xBase + UI_STAT_ICON_H, yBottom)

        set ui_frame[btnIconIndex]=BlzCreateFrameByType("BACKDROP", "statPlusBackdrop" + I2S(frameBase), ui_frame[buttonIndex], "", 0)
        call BlzFrameSetAllPoints(ui_frame[btnIconIndex], ui_frame[buttonIndex])
        call BlzFrameSetTexture(ui_frame[btnIconIndex], STAT_BTN_ADD, 0, true)
    endif
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[buttonIndex], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[textIndex], FRAMEEVENT_MOUSE_LEAVE)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[buttonIndex], FRAMEEVENT_MOUSE_LEAVE)

    call BlzTriggerRegisterFrameEvent(ui_core_bonus_trig, ui_frame[buttonIndex], FRAMEEVENT_CONTROL_CLICK)

    //set ui_frame[i] = BlzCreateFrame("ScriptDialogButton", ui_mainBackDrop, 0, 0) 
    
    //call BlzTriggerRegisterFrameEvent(abilityTooltipMouseEnterTrig, ui_frame[frameBase+3], FRAMEEVENT_MOUSE_ENTER)
    //call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[frameBase+3], FRAMEEVENT_MOUSE_LEAVE)
    //call BlzTriggerRegisterFrameEvent(abilityClickTrig, ui_frame[frameBase+3], FRAMEEVENT_MOUSE_UP)
endfunction

function getPlusButtonText takes integer statIndex,integer coreCost,real bonusPerCore returns string
    return "Consume " + I2S(coreCost) + " cores to increase the " + (Si2Name(ui2Stat((statIndex)))) + " by " + R2SHumanReadable(bonusPerCore) + "." // INLINED!!
endfunction

function coreBonusButton takes nothing returns nothing
    local player p= GetTriggerPlayer()
    local framehandle f= BlzGetTriggerFrame()
    local integer frameId= frameToFrameId(f) - 2
    local integer statIndex= ui2Stat(frameId)
    local integer costForNext
    
    call BlzFrameSetEnable(f, false)
    call BlzFrameSetEnable(f, true)

    call s__HeroStatsCore_applyCore((s__MetroidvaniaController_u[(sc__MetroidvaniaController_getMetroidvaniaController(p))]) , statIndex) // INLINED!!
    set costForNext=(1 + (s__HeroStatsCore_coresApplied[GetPlayerId(((p ) )) * STAT_COUNT + ( ( statIndex))]) / 3) // INLINED!!
    if p == GetLocalPlayer() then
        set ui_strings[frameId + 3]=getPlusButtonText(frameId , costForNext , statIndexToBonusAmount(statIndex))
        call updateStatsPanel(p)
        call updateApplyCoreBtn(p , (coresAvailable[GetPlayerId((p))]) , frameId) // INLINED!!
        call BlzFrameSetText(ui_frame[UI_TOOLTIP_HEADER], ui_strings[frameId + 2])
        call BlzFrameSetText(ui_frame[UI_TOOLTIP_TEXT], ui_strings[frameId + 3])
    endif
    set f=null
    set p=null
endfunction

function hideBaseGui takes nothing returns nothing
    call BlzEnableUIAutoPosition(false)
    call BlzHideOriginFrames(true)
    call BlzFrameSetAbsPoint(BlzGetFrameByName("ConsoleUI", 0), FRAMEPOINT_BOTTOM, 0.4, - 0.18)
    //if IsReforged() then
        call BlzFrameSetVisible(BlzGetFrameByName("ConsoleUIBackdrop", 0), false)
    //else
        call BlzFrameSetAllPoints(BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0), BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI, 0))
    //endif
endfunction
//---------------------------------------------- MAIN INIT -----------------------
function uiInit takes nothing returns nothing
    local framehandle tmp
    local integer i= 0
    local real xBase
    local real yBase
    local trigger abilityClickTrig= CreateTrigger()
    local trigger statsClickToggleTrig= CreateTrigger()
    local trigger abilityTooltipMouseEnterTrig= CreateTrigger()
    if (GetLocalizedString("REFORGED") != "REFORGED") then // INLINED!!
        set ui_stat_text_scale=0.9
    endif
    //set ui_stat_text_scale = 0.8
    //call BJDebugMsg("ui_stat_text_scale=" + R2S(ui_stat_text_scale))
    set ui_show_ui_tooltip_trig=CreateTrigger()
    set ui_hide_tooltip_trig=CreateTrigger()
    set ui_core_bonus_trig=CreateTrigger()
    set targetDeadTimer=CreateTimer()
    call TriggerAddAction(abilityTooltipMouseEnterTrig, function updateTooltipTrigFunc)
    call TriggerAddAction(ui_show_ui_tooltip_trig, function showUITooltip)
    call TriggerAddAction(ui_hide_tooltip_trig, function hideTooltipMouseLeaveButton)
    call TriggerAddAction(abilityClickTrig, function clickUIButton)
    call TriggerAddAction(statsClickToggleTrig, function clickToggleStatsPanel)
    call TriggerAddAction(ui_core_bonus_trig, function coreBonusButton)

    set ui_strings[UI_STATS]="Stats"
    set ui_strings[UI_STATS + 1]="Opens/Closes the stats panel."
    set ui_strings[UI_MAP]="Map"
    set ui_strings[UI_MAP + 1]="Opens/Closes the map panel. Issuing any order also closes the map."
    set ui_strings[0]=(Si2Name(ui2Stat((UI_STATS_HP)))) // INLINED!!
    set ui_strings[0 + 1]="Your current Structural Integrity.|nHits taken lowers it. Upon reaching 0, your current body is destroyed and you will be reassembled at the last activated Emergency Backup Location after a few seconds."
    set ui_strings[2]=(Si2Name(ui2Stat((UI_STATS_ENERGY)))) // INLINED!!
    set ui_strings[2 + 1]="Your current Energy. Attacks and abilities consumes it. |nYou passivly regenerate energy based on your " + (Si2Name(ui2Stat((UI_STATS_ENERGY_RECHARGE)))) + "." // INLINED!!

    set ui_strings[UI_STATS_HP]=ui_strings[0]
    set ui_strings[UI_STATS_HP + 1]=ui_strings[0 + 1]
    set ui_strings[UI_STATS_HP + 2]="Add " + (Si2Name(ui2Stat((UI_STATS_HP)))) // INLINED!!
    set ui_strings[UI_STATS_HP + 3]=getPlusButtonText(UI_STATS_HP , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_HP)))

    set ui_strings[UI_STATS_HP_REPAIR]=(Si2Name(ui2Stat((UI_STATS_HP_REPAIR)))) // INLINED!!
    set ui_strings[UI_STATS_HP_REPAIR + 1]="Your current repair-rate. Passivly restores " + (Si2Name(ui2Stat((UI_STATS_HP)))) + " per second." // INLINED!!
    set ui_strings[UI_STATS_HP_REPAIR + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_HP_REPAIR)))) // INLINED!!
    set ui_strings[UI_STATS_HP_REPAIR + 3]=getPlusButtonText(UI_STATS_HP_REPAIR , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_HP_REPAIR)))
    
    set ui_strings[UI_STATS_ENERGY]=(Si2Name(ui2Stat((UI_STATS_ENERGY)))) // INLINED!!
    set ui_strings[UI_STATS_ENERGY + 1]="Your Energy Capacity. Attacks and abilities drain some amount of energy. "
    set ui_strings[UI_STATS_ENERGY + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_ENERGY)))) // INLINED!!
    set ui_strings[UI_STATS_ENERGY + 3]=getPlusButtonText(UI_STATS_ENERGY , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_ENERGY)))

    set ui_strings[UI_STATS_ENERGY_RECHARGE]=(Si2Name(ui2Stat((UI_STATS_ENERGY_RECHARGE)))) // INLINED!!
    set ui_strings[UI_STATS_ENERGY_RECHARGE + 1]="Passivly restores Energy per second."
    set ui_strings[UI_STATS_ENERGY_RECHARGE + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_ENERGY_RECHARGE)))) // INLINED!!
    set ui_strings[UI_STATS_ENERGY_RECHARGE + 3]=getPlusButtonText(UI_STATS_ENERGY_RECHARGE , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_ENERGY_RECHARGE)))

    set ui_strings[UI_STATS_FIREPOWER]=(Si2Name(ui2Stat((UI_STATS_FIREPOWER)))) // INLINED!!
    set ui_strings[UI_STATS_FIREPOWER + 1]="Offensive attacks and abilities deal damage based on your " + (Si2Name(ui2Stat((UI_STATS_FIREPOWER)))) + " and some times also " + (Si2Name(ui2Stat((UI_STATS_SYSTEM_POWER)))) + "." // INLINED!!
    set ui_strings[UI_STATS_FIREPOWER + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_FIREPOWER)))) // INLINED!!
    set ui_strings[UI_STATS_FIREPOWER + 3]=getPlusButtonText(UI_STATS_FIREPOWER , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_FIREPOWER)))

    set ui_strings[UI_STATS_SYSTEM_POWER]=(Si2Name(ui2Stat((UI_STATS_SYSTEM_POWER)))) // INLINED!!
    set ui_strings[UI_STATS_SYSTEM_POWER + 1]="Most abilities and some attacks increases their effectivness based on the " + (Si2Name(ui2Stat((UI_STATS_SYSTEM_POWER)))) + "." // INLINED!!
    set ui_strings[UI_STATS_SYSTEM_POWER + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_SYSTEM_POWER)))) // INLINED!!
    set ui_strings[UI_STATS_SYSTEM_POWER + 3]=getPlusButtonText(UI_STATS_SYSTEM_POWER , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_SYSTEM_POWER)))
    
    set ui_strings[UI_STATS_SYSTEM_SPEED]=(Si2Name(ui2Stat((UI_STATS_SYSTEM_SPEED)))) // INLINED!!
    set ui_strings[UI_STATS_SYSTEM_SPEED + 1]="Lowered cooldowns on attacks and abilities. Each point result in 1% more casts if you cast as soon as it is available. In other words: 100 points loweres cooldowns to 50% of their original."
    set ui_strings[UI_STATS_SYSTEM_SPEED + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_SYSTEM_SPEED)))) // INLINED!!
    set ui_strings[UI_STATS_SYSTEM_SPEED + 3]=getPlusButtonText(UI_STATS_SYSTEM_SPEED , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_SYSTEM_SPEED)))
    
    set ui_strings[UI_STATS_MOBILITY]=(Si2Name(ui2Stat((UI_STATS_MOBILITY)))) // INLINED!!
    set ui_strings[UI_STATS_MOBILITY + 1]="Your movement speed in world-units per second."
    set ui_strings[UI_STATS_MOBILITY + 2]="Increase " + (Si2Name(ui2Stat((UI_STATS_MOBILITY)))) // INLINED!!
    set ui_strings[UI_STATS_MOBILITY + 3]=getPlusButtonText(UI_STATS_MOBILITY , 1 , statIndexToBonusAmount(ui2Stat(UI_STATS_MOBILITY)))

    set ui_strings[UI_STATS_CORES_AVAILABLE]="Upgrade Cores"
    set ui_strings[UI_STATS_CORES_AVAILABLE + 1]="Upgrade cores allows you to enhance your different stats. Every 3 cores applied to a single stat increases its cost by 1."

    set ui_strings[UI_TARGET_DAMAGE_TEXT]="Firepower"
    set ui_strings[UI_TARGET_DAMAGE_TEXT + 1]="Typically the damage dealt by a regular attack by this target."

    set ui_strings[UI_TARGET_MOVEMENT_TEXT]="Mobility"
    set ui_strings[UI_TARGET_MOVEMENT_TEXT + 1]="Movement Speed in world-units per second for this target."

    set ui_portrait=BlzGetOriginFrame(ORIGIN_FRAME_PORTRAIT, 0)
    call BlzFrameSetAbsPoint(ui_portrait, FRAMEPOINT_TOPLEFT, 0.0, 0.0)
    call BlzFrameSetAbsPoint(ui_portrait, FRAMEPOINT_BOTTOMRIGHT, - 0.1, - 0.1)
    call BlzFrameSetVisible(ui_portrait, false)

    set ui_mainBackDrop=BlzCreateFrameByType("BACKDROP", "ui_mainBackDrop", BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0), "", 0)
    call BlzFrameSetAbsPoint(ui_mainBackDrop, FRAMEPOINT_TOPLEFT, UI_MAIN_LEFT, UI_MAIN_TOP)
    call BlzFrameSetAbsPoint(ui_mainBackDrop, FRAMEPOINT_BOTTOMRIGHT, UI_MAIN_RIGHT, UI_MAIN_BOT)
    call BlzFrameSetTexture(ui_mainBackDrop, "UI\\ScifiCardX2RotCut.blp", 0, true)
    call BlzFrameSetVisible(ui_mainBackDrop, false)

    set ui_statsBackdrop=BlzCreateFrameByType("BACKDROP", "ui_statsBackdrop", BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0), "", 0)
    call BlzFrameSetAbsPoint(ui_statsBackdrop, FRAMEPOINT_TOPLEFT, UI_STATS_LEFT, UI_MAIN_TOP)
    call BlzFrameSetAbsPoint(ui_statsBackdrop, FRAMEPOINT_BOTTOMRIGHT, UI_STATS_RIGHT, UI_MAIN_BOT)
    call BlzFrameSetTexture(ui_statsBackdrop, "UI\\ScifiCardX3Cut.blp", 0, true)
    call BlzFrameSetVisible(ui_statsBackdrop, false)

    set ui_targetBackdrop=BlzCreateFrameByType("BACKDROP", "ui_targetBackdrop", BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0), "", 0)
    call BlzFrameSetAbsPoint(ui_targetBackdrop, FRAMEPOINT_TOPLEFT, UI_TARGET_LEFT, UI_MAIN_TOP)
    call BlzFrameSetAbsPoint(ui_targetBackdrop, FRAMEPOINT_BOTTOMRIGHT, UI_TARGET_RIGHT, UI_MAIN_BOT)
    call BlzFrameSetTexture(ui_targetBackdrop, "UI\\ScifiCardX3Cut.blp", 0, true)
    call BlzFrameSetVisible(ui_targetBackdrop, false)

//HP BAR
    set ui_hpBarEmpty=BlzCreateFrameByType("BACKDROP", "hpEmpty", ui_mainBackDrop, "", 0)
    call BlzFrameSetAbsPoint(ui_hpBarEmpty, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_HP_TOP)
    call BlzFrameSetAbsPoint(ui_hpBarEmpty, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_HP_BOT)
    call BlzFrameSetTexture(ui_hpBarEmpty, "UI\\ScifiBarEmpty.blp", 0, true)
    set ui_hpBarFull=BlzCreateFrameByType("SIMPLESTATUSBAR", "hpFull", ui_hpBarEmpty, "", 0)
    call BlzFrameSetTexture(ui_hpBarFull, "UI\\ScifiBarFull.blp", 0, true)
    call BlzFrameSetAbsPoint(ui_hpBarFull, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_HP_TOP)
    call BlzFrameSetAbsPoint(ui_hpBarFull, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_HP_BOT)
    call BlzFrameSetValue(ui_hpBarFull, 0)

    set ui_hpBarText=BlzCreateFrameByType("TEXT", "hpBarText", ui_mainBackDrop, "", 0)
    call BlzFrameSetAbsPoint(ui_hpBarText, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_HP_TOP)
    call BlzFrameSetAbsPoint(ui_hpBarText, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_HP_BOT)
    call BlzFrameSetText(ui_hpBarText, "|cffffffff100/100|r")
    //call BlzFrameSetEnable(ui_hpBarText, false)
    call BlzFrameSetScale(ui_hpBarText, 1.00)
    call BlzFrameSetTextAlignment(ui_hpBarText, TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_hpBarText, FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_hpBarText, FRAMEEVENT_MOUSE_LEAVE)

    set tmp=BlzCreateFrameByType("BACKDROP", "ui_hpIcon", ui_mainBackDrop, "", 1)
    call BlzFrameSetAbsPoint(tmp, FRAMEPOINT_TOPLEFT, UI_BAR_ICON_LEFT, UI_BAR_HP_TOP)
    call BlzFrameSetAbsPoint(tmp, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_ICON_RIGHT, UI_BAR_HP_BOT)
    call BlzFrameSetTexture(tmp, "UI\\ScifiHexHp.blp", 0, true)

//ENERGY BAR
    set ui_energyBarEmpty=BlzCreateFrameByType("BACKDROP", "", ui_mainBackDrop, "", 1)
    call BlzFrameSetAbsPoint(ui_energyBarEmpty, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_ENERGY_TOP)
    call BlzFrameSetAbsPoint(ui_energyBarEmpty, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_ENERGY_BOT)
    call BlzFrameSetTexture(ui_energyBarEmpty, "UI\\ScifiBarEmpty.blp", 0, true)
    set ui_energyBarFull=BlzCreateFrameByType("SIMPLESTATUSBAR", "", ui_energyBarEmpty, "", 0)
    call BlzFrameSetTexture(ui_energyBarFull, "UI\\ScifiBarFull.blp", 0, true)
    call BlzFrameSetAbsPoint(ui_energyBarFull, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_ENERGY_TOP)
    call BlzFrameSetAbsPoint(ui_energyBarFull, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_ENERGY_BOT)
    call BlzFrameSetValue(ui_energyBarFull, 0)

    set ui_energyBarText=BlzCreateFrameByType("TEXT", "hpBarText", ui_mainBackDrop, "", 0)
    call BlzFrameSetAbsPoint(ui_energyBarText, FRAMEPOINT_TOPLEFT, UI_BAR_LEFT, UI_BAR_ENERGY_TOP)
    call BlzFrameSetAbsPoint(ui_energyBarText, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_RIGHT, UI_BAR_ENERGY_BOT)
    call BlzFrameSetText(ui_energyBarText, "|cffffffff100/100|r")
    //call BlzFrameSetEnable(ui_energyBarText, false)
    call BlzFrameSetScale(ui_energyBarText, 1.00)
    call BlzFrameSetTextAlignment(ui_energyBarText, TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_energyBarText, FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_energyBarText, FRAMEEVENT_MOUSE_LEAVE)
    set tmp=BlzCreateFrameByType("BACKDROP", "ui_energyIcon", ui_mainBackDrop, "", 1)
    call BlzFrameSetAbsPoint(tmp, FRAMEPOINT_TOPLEFT, UI_BAR_ICON_LEFT, UI_BAR_ENERGY_TOP)
    call BlzFrameSetAbsPoint(tmp, FRAMEPOINT_BOTTOMRIGHT, UI_BAR_ICON_RIGHT, UI_BAR_ENERGY_BOT)
    call BlzFrameSetTexture(tmp, "UI\\ScifiHexEnergy.blp", 0, true)

//Icons
    set yBase=UI_ICONS_TOP
    
    
    loop
        exitwhen i > UI_PASSIVE2
        set xBase=UI_ICONS_LEFT + ( i / UI_FRAMES_PER_ABILITY ) * ( UI_ICONS_SIZE + 2.1 * UI_MAIN_PADDING )

        set ui_frame[i]=BlzCreateFrame("ScriptDialogButton", ui_mainBackDrop, 0, 0)
        call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, xBase, yBase)
        call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, xBase + UI_ICONS_SIZE, yBase - UI_ICONS_SIZE)
        call BlzTriggerRegisterFrameEvent(abilityTooltipMouseEnterTrig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)
        call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_LEAVE)
        call BlzTriggerRegisterFrameEvent(abilityClickTrig, ui_frame[i], FRAMEEVENT_MOUSE_UP)
        call BlzFrameSetVisible(ui_frame[i], false)

        set ui_frame[i + 1]=BlzCreateFrameByType("BACKDROP", "icon" + I2S(i), ui_frame[i], "", 0)
        call BlzFrameSetAllPoints(ui_frame[i + 1], ui_frame[i])
        call BlzFrameSetTexture(ui_frame[i + 1], ICON_NONE, 0, true)
        //call BlzFrameSetVisible(ui_frame[i+1], false)
        //call BlzFrameSetAlpha(ui_frame[i], 250)

        set ui_frame[i + 2]=BlzCreateFrameByType("SIMPLESTATUSBAR", "iconCD + + I2S(i)", ui_frame[i], "", 0)
        call BlzFrameSetTexture(ui_frame[i + 2], ICONS + ICON_COOLDOWN, 0, true)
        call BlzFrameSetAllPoints(ui_frame[i + 2], ui_frame[i])
        call BlzFrameSetValue(ui_frame[i + 2], 0.)
        call BlzFrameSetAlpha(ui_frame[i + 2], COOLDOWN_ALPHA)
        set i=i + UI_FRAMES_PER_ABILITY
    endloop

    set i=UI_MAP
    set yBase=UI_BAR_ENERGY_BOT
    set ui_frame[i]=BlzCreateFrame("ScriptDialogButton", ui_mainBackDrop, 0, 0)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, UI_ICONS_EXTRAS_LEFT, yBase + UI_ICONS_EXTRAS_SIZE)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, UI_ICONS_EXTRAS_RIGHT, yBase)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_LEAVE)

    set ui_frame[i + 2]=BlzCreateFrameByType("BACKDROP", "icon" + I2S(i), ui_frame[i], "", 1)
    call BlzFrameSetAllPoints(ui_frame[i + 2], ui_frame[i])
    call BlzFrameSetTexture(ui_frame[i + 2], ICON_MAP, 0, true)
    //call BlzTriggerRegisterFrameEvent(TriggerFrame01, Frame01, FRAMEEVENT_CONTROL_CLICK) 
    //call TriggerAddAction(TriggerFrame01, function Frame01Func)

    set ui_frame[i + 1]=BlzCreateFrameByType("SIMPLESTATUSBAR", "iconCD + + I2S(i)", ui_frame[i], "", 0)
    call BlzFrameSetTexture(ui_frame[i + 1], ICONS + ICON_COOLDOWN, 0, true)
    call BlzFrameSetAllPoints(ui_frame[i + 1], ui_frame[i])
    call BlzFrameSetValue(ui_frame[i + 1], 0)
    call BlzFrameSetAlpha(ui_frame[i + 1], COOLDOWN_ALPHA)

    set i=UI_INTERACT
    set yBase=yBase + UI_ICONS_EXTRAS_SIZE + 0.5 * UI_MAIN_PADDING
    set ui_frame[i]=BlzCreateFrame("ScriptDialogButton", ui_mainBackDrop, 0, 0)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, UI_ICONS_EXTRAS_LEFT, yBase + UI_ICONS_EXTRAS_SIZE)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, UI_ICONS_EXTRAS_RIGHT, yBase)
    
    call BlzTriggerRegisterFrameEvent(abilityTooltipMouseEnterTrig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_LEAVE)
    call BlzTriggerRegisterFrameEvent(abilityClickTrig, ui_frame[i], FRAMEEVENT_MOUSE_UP)

    set ui_frame[i + 2]=BlzCreateFrameByType("BACKDROP", "icon" + I2S(i), ui_frame[i], "", 1)
    call BlzFrameSetAllPoints(ui_frame[i + 2], ui_frame[i])
    call BlzFrameSetTexture(ui_frame[i + 2], ICON_INTERACT, 0, true)

    set ui_frame[i + 1]=BlzCreateFrameByType("SIMPLESTATUSBAR", "iconCD + + I2S(i)", ui_frame[i], "", 0)
    call BlzFrameSetTexture(ui_frame[i + 1], ICONS + ICON_COOLDOWN, 0, true)
    call BlzFrameSetAllPoints(ui_frame[i + 1], ui_frame[i])
    call BlzFrameSetValue(ui_frame[i + 1], 0)
    call BlzFrameSetAlpha(ui_frame[i + 1], COOLDOWN_ALPHA)


    set i=UI_STATS
    set yBase=yBase + UI_ICONS_EXTRAS_SIZE + 0.5 * UI_MAIN_PADDING
    set ui_frame[i]=BlzCreateFrame("ScriptDialogButton", ui_mainBackDrop, 0, 0)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, UI_ICONS_EXTRAS_LEFT, yBase + UI_ICONS_EXTRAS_SIZE)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, UI_ICONS_EXTRAS_RIGHT, yBase)
    call BlzTriggerRegisterFrameEvent(statsClickToggleTrig, ui_frame[i], FRAMEEVENT_MOUSE_UP)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_LEAVE)

    set ui_frame[i + 2]=BlzCreateFrameByType("BACKDROP", "icon" + I2S(i), ui_frame[i], "", 1)
    call BlzFrameSetAllPoints(ui_frame[i + 2], ui_frame[i])
    call BlzFrameSetTexture(ui_frame[i + 2], ICON_STATS_CLOSE, 0, true)

    set ui_frame[i + 1]=BlzCreateFrameByType("SIMPLESTATUSBAR", "iconCD + + I2S(i)", ui_frame[i], "", 0)
    call BlzFrameSetTexture(ui_frame[i + 1], ICONS + ICON_COOLDOWN, 0, true)
    call BlzFrameSetAllPoints(ui_frame[i + 1], ui_frame[i])
    call BlzFrameSetValue(ui_frame[i + 1], 0)
    call BlzFrameSetAlpha(ui_frame[i + 1], COOLDOWN_ALPHA)

    // ---- TOOLTIP ----
    set i=UI_TOOLTIP_FRAME
    set ui_frame[i]=BlzCreateFrameByType("BACKDROP", "tooltipFrame", BlzGetOriginFrame(ORIGIN_FRAME_WORLD_FRAME, 0), "", 1)
    //call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, UI_MAIN_LEFT, UI_MAIN_TOP + UI_TOOLTIP_BASE_H)
    //call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, UI_MAIN_LEFT + UI_TOOLTIP_BASE_W, UI_MAIN_TOP)
    //call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, UI_MAIN_LEFT, UI_MAIN_TOP + UI_TOOLTIP_BASE_H)
    call BlzFrameSetAbsPoint(ui_frame[i], FRAMEPOINT_BOTTOM, UI_MAIN_LEFT, UI_MAIN_TOP - UI_MAIN_PADDING)
    call BlzFrameSetSize(ui_frame[i], UI_TOOLTIP_BASE_W, UI_TOOLTIP_BASE_H)
    call BlzFrameSetTexture(ui_frame[i], "UI\\ScifiCardX3.blp", 0, true)
    call BlzFrameSetVisible(ui_frame[i], false)
    set i=UI_TOOLTIP_HEADER
    set ui_frame[i]=BlzCreateFrameByType("TEXT", "tooltipHeader", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_TOPLEFT, UI_TOOLTIP_INSET_SIDES, - UI_TOOLTIP_INSET_TOP)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_TOPRIGHT, - UI_TOOLTIP_INSET_SIDES, - ( UI_TOOLTIP_HEADER_HEIGHT + UI_TOOLTIP_INSET_TOP ))
    call BlzFrameSetText(ui_frame[i], "|cffffffffHEADER|r")
    call BlzFrameSetEnable(ui_frame[i], false)
    call BlzFrameSetScale(ui_frame[i], 1.10)
    call BlzFrameSetTextAlignment(ui_frame[i], TEXT_JUSTIFY_TOP, TEXT_JUSTIFY_CENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)
    
    set i=UI_TOOLTIP_TEXT
    set ui_frame[i]=BlzCreateFrameByType("TEXT", "tooltipBody", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOP, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_TOP, 0.0, - ( UI_TOOLTIP_HEADER_HEIGHT + UI_TOOLTIP_INSET_TOP + 2.5 * UI_MAIN_PADDING ))
    //call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMRIGHT, -UI_TOOLTIP_INSET, UI_TOOLTIP_INSET)
    //call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMRIGHT, -UI_TOOLTIP_INSET, UI_TOOLTIP_INSET)
    //call BlzFrameSetText(ui_frame[i], "|cffffffffHello! Some bread thext that, will this line break? Who knows? But I'd better test it.|nAlso With new-|nlines :)|nGoing for a few more chars of texts but still less than 256 chars...|r")
    call BlzFrameSetText(ui_frame[i], "Hello!")
    call BlzFrameSetSize(ui_frame[i], UI_TOOLTIP_BASE_W - 2. * UI_TOOLTIP_INSET_SIDES, 0.0)
    call BlzFrameSetEnable(ui_frame[i], false)
    call BlzFrameSetScale(ui_frame[i], 0.90)
    //call BlzFrameSetTextAlignment(ui_frame[i], TEXT_JUSTIFY_TOP, TEXT_JUSTIFY_LEFT)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[i], FRAMEEVENT_MOUSE_ENTER)

    //MANA
    set i=UI_TOOLTIP_MANA
    set xBase=- UI_TOOLTIP_INSET_SIDES * 4.75
    set ui_frame[i]=BlzCreateFrameByType("TEXT", "tooltipMana", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMRIGHT, xBase, UI_TOOLTIP_HEADER_HEIGHT)
    call BlzFrameSetText(ui_frame[i], "|cffffffff12|r")
    call BlzFrameSetEnable(ui_frame[i], false)
    set i=UI_TOOLTIP_MANA_ICON_FRAME
    set xBase=xBase - 0.5 * UI_TOOLTIP_INSET_SIDES
    set ui_frame[i]=BlzCreateFrameByType("BACKDROP", "tooltipManaIcon", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMRIGHT, xBase, UI_TOOLTIP_HEADER_HEIGHT)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMRIGHT, xBase - UI_TOOLTIP_ICON_W, UI_TOOLTIP_HEADER_HEIGHT + UI_TOOLTIP_ICON_H)
    call BlzFrameSetTexture(ui_frame[i], UI_TOOLTIP_MANA_ICON_PATH, 0, true)


    set i=UI_TOOLTIP_COOLDOWN_ICON_FRAME
    set xBase=UI_TOOLTIP_INSET_SIDES * 2.25
    set ui_frame[i]=BlzCreateFrameByType("BACKDROP", "tooltipCooldownIcon", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMLEFT, xBase + UI_TOOLTIP_ICON_W, UI_TOOLTIP_HEADER_HEIGHT)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMLEFT, xBase, UI_TOOLTIP_HEADER_HEIGHT + UI_TOOLTIP_ICON_H)
    call BlzFrameSetTexture(ui_frame[i], UI_TOOLTIP_COOLDOWN_ICON_PATH, 0, true)
    set i=UI_TOOLTIP_COOLDOWN
    set xBase=xBase + UI_MAIN_PADDING + UI_TOOLTIP_ICON_W + UI_MAIN_PADDING
    set ui_frame[i]=BlzCreateFrameByType("TEXT", "tooltipCooldown", ui_frame[UI_TOOLTIP_FRAME], "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMLEFT, ui_frame[UI_TOOLTIP_FRAME], FRAMEPOINT_BOTTOMLEFT, xBase, UI_TOOLTIP_HEADER_HEIGHT)
    call BlzFrameSetText(ui_frame[i], "|cffffffff5.35 s|r")
    call BlzFrameSetEnable(ui_frame[i], false)

    set yBase=- UI_STAT_INSET_TOP

    //---------- Setup Stats -----------
    set ui_frame[UI_STATS_CORES_AVAILABLE]=BlzCreateFrameByType("TEXT", "statCoresAvailable", ui_statsBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_STATS_CORES_AVAILABLE], FRAMEPOINT_TOPLEFT, ui_statsBackdrop, FRAMEPOINT_TOPLEFT, UI_STAT_INSET_SIDES, yBase)
    call BlzFrameSetPoint(ui_frame[UI_STATS_CORES_AVAILABLE], FRAMEPOINT_BOTTOMRIGHT, ui_statsBackdrop, FRAMEPOINT_TOPRIGHT, - UI_STAT_INSET_SIDES, yBase - UI_STAT_ICON_H)
    call BlzFrameSetText(ui_frame[UI_STATS_CORES_AVAILABLE], "Cores Available: 3")
    //call BlzFrameSetEnable(ui_frame[UI_STATS_CORES_AVAILABLE], false)
    call BlzFrameSetScale(ui_frame[UI_STATS_CORES_AVAILABLE], 1.00)
    call BlzFrameSetTextAlignment(ui_frame[UI_STATS_CORES_AVAILABLE], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[UI_STATS_CORES_AVAILABLE], FRAMEEVENT_MOUSE_LEAVE)
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[UI_STATS_CORES_AVAILABLE], FRAMEEVENT_MOUSE_ENTER)


    call addStatFrames(UI_STATS_HP , STATHEX_HP , 0 , 0)
    call addStatFrames(UI_STATS_HP_REPAIR , STATHEX_HP_REPAIR , 0 , 1)
    call addStatFrames(UI_STATS_ENERGY , STATHEX_ENERGY , 0 , 2)
    call addStatFrames(UI_STATS_ENERGY_RECHARGE , STATHEX_ENERGY_CHARGE , 0 , 3)
    call addStatFrames(UI_STATS_FIREPOWER , STATHEX_FIREPOWER , 1 , 0)
    call addStatFrames(UI_STATS_SYSTEM_POWER , STATHEX_SYSTEM_POWER , 1 , 1)
    call addStatFrames(UI_STATS_SYSTEM_SPEED , STATHEX_SYSTEM_SPEED , 1 , 2)
    call addStatFrames(UI_STATS_MOBILITY , STATHEX_MOBILITY , 1 , 3)
    //----------------------------------
    
    //------------- SETUP TARGET ---------
    //UI_STAT_INSET_SIDES
    set yBase=- UI_STAT_INSET_TOP
    set ui_frame[UI_TARGET_NAME]=BlzCreateFrameByType("TEXT", "targetName", ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_NAME], FRAMEPOINT_TOPLEFT, ui_targetBackdrop, FRAMEPOINT_TOPLEFT, UI_MAIN_INSET, yBase)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_NAME], FRAMEPOINT_BOTTOMRIGHT, ui_targetBackdrop, FRAMEPOINT_TOPRIGHT, - UI_MAIN_INSET, yBase - UI_STAT_ICON_H)
    call BlzFrameSetText(ui_frame[UI_TARGET_NAME], "Target: N/A")
       
    set i=UI_TARGET_HP_BAR_EMPTY
    set ui_frame[i]=BlzCreateFrameByType("BACKDROP", "hpEmpty", ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_TOPLEFT, ui_targetBackdrop, FRAMEPOINT_TOPLEFT, UI_STAT_INSET_SIDES, yBase - UI_STAT_ICON_H * 1.5)
    call BlzFrameSetPoint(ui_frame[i], FRAMEPOINT_BOTTOMRIGHT, ui_targetBackdrop, FRAMEPOINT_TOPRIGHT, - UI_STAT_INSET_SIDES, yBase - UI_STAT_ICON_H * 2.5)
    call BlzFrameSetTexture(ui_frame[i], "UI\\ScifiBarEmpty.blp", 0, true)
    set ui_frame[UI_TARGET_HP_BAR_FULL]=BlzCreateFrameByType("SIMPLESTATUSBAR", "hpFull", ui_frame[UI_TARGET_HP_BAR_FULL], "", 0)
    call BlzFrameSetTexture(ui_frame[UI_TARGET_HP_BAR_FULL], "UI\\ScifiBarFull.blp", 0, true)
    call BlzFrameSetAllPoints(ui_frame[UI_TARGET_HP_BAR_FULL], ui_frame[UI_TARGET_HP_BAR_EMPTY])
    call BlzFrameSetValue(ui_frame[UI_TARGET_HP_BAR_FULL], 0)

    set ui_frame[UI_TARGET_HP_BAR_TEXT]=BlzCreateFrameByType("TEXT", "hpBarText", ui_targetBackdrop, "", 0)
    call BlzFrameSetAllPoints(ui_frame[UI_TARGET_HP_BAR_TEXT], ui_frame[UI_TARGET_HP_BAR_EMPTY])
    call BlzFrameSetText(ui_frame[UI_TARGET_HP_BAR_TEXT], "|cffffffffN/A|r")
    //call BlzFrameSetEnable(ui_frame[UI_TARGET_HP_BAR_TEXT], false)
    call BlzFrameSetScale(ui_frame[UI_TARGET_HP_BAR_TEXT], 1.00)
    call BlzFrameSetTextAlignment(ui_frame[UI_TARGET_HP_BAR_TEXT], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_CENTER)

    //TODO: Add dmg + movement speed
    set ui_frame[UI_TARGET_DAMAGE_ICON]=BlzCreateFrameByType("BACKDROP", "stat" + I2S(UI_TARGET_DAMAGE_ICON), ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_DAMAGE_ICON], FRAMEPOINT_TOPLEFT, ui_frame[UI_TARGET_HP_BAR_FULL], FRAMEPOINT_BOTTOMLEFT, 0., - UI_MAIN_PADDING)
    call BlzFrameSetSize(ui_frame[UI_TARGET_DAMAGE_ICON], UI_STAT_ICON_ADD_SIZE, UI_STAT_ICON_ADD_SIZE)
    call BlzFrameSetTexture(ui_frame[UI_TARGET_DAMAGE_ICON], STATHEX_FIREPOWER, 0, true)

    set ui_frame[UI_TARGET_DAMAGE_TEXT]=BlzCreateFrameByType("TEXT", "statText" + I2S(UI_TARGET_DAMAGE_ICON), ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_DAMAGE_TEXT], FRAMEPOINT_TOPLEFT, ui_frame[UI_TARGET_DAMAGE_ICON], FRAMEPOINT_TOPRIGHT, UI_MAIN_PADDING, 0.)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_DAMAGE_TEXT], FRAMEPOINT_BOTTOM, ui_frame[UI_TARGET_DAMAGE_ICON], FRAMEPOINT_BOTTOM, 0., 0.)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_DAMAGE_TEXT], FRAMEPOINT_RIGHT, ui_targetBackdrop, FRAMEPOINT_RIGHT, - UI_MAIN_INSET, 0.)
    call BlzFrameSetText(ui_frame[UI_TARGET_DAMAGE_TEXT], "|cffffffffN/A|r")
    //call BlzFrameSetEnable(ui_frame[UI_TARGET_HP_BAR_TEXT], false)
    call BlzFrameSetScale(ui_frame[UI_TARGET_DAMAGE_TEXT], 1.00)
    call BlzFrameSetTextAlignment(ui_frame[UI_TARGET_DAMAGE_TEXT], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_LEFT)
    
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[UI_TARGET_DAMAGE_TEXT], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[UI_TARGET_DAMAGE_TEXT], FRAMEEVENT_MOUSE_LEAVE)

    //Movement Speed
    set ui_frame[UI_TARGET_MOVEMENT_ICON]=BlzCreateFrameByType("BACKDROP", "stat" + I2S(UI_TARGET_MOVEMENT_ICON), ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_MOVEMENT_ICON], FRAMEPOINT_TOPLEFT, ui_frame[UI_TARGET_DAMAGE_ICON], FRAMEPOINT_BOTTOMLEFT, 0., - UI_MAIN_PADDING)
    call BlzFrameSetSize(ui_frame[UI_TARGET_MOVEMENT_ICON], UI_STAT_ICON_ADD_SIZE, UI_STAT_ICON_ADD_SIZE)
    call BlzFrameSetTexture(ui_frame[UI_TARGET_MOVEMENT_ICON], STATHEX_MOBILITY, 0, true)
    
    set ui_frame[UI_TARGET_MOVEMENT_TEXT]=BlzCreateFrameByType("TEXT", "statText" + I2S(UI_TARGET_MOVEMENT_ICON), ui_targetBackdrop, "", 0)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_MOVEMENT_TEXT], FRAMEPOINT_TOPLEFT, ui_frame[UI_TARGET_MOVEMENT_ICON], FRAMEPOINT_TOPRIGHT, UI_MAIN_PADDING, 0.)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_MOVEMENT_TEXT], FRAMEPOINT_BOTTOM, ui_frame[UI_TARGET_MOVEMENT_ICON], FRAMEPOINT_BOTTOM, 0., 0.)
    call BlzFrameSetPoint(ui_frame[UI_TARGET_MOVEMENT_TEXT], FRAMEPOINT_RIGHT, ui_targetBackdrop, FRAMEPOINT_RIGHT, - UI_MAIN_INSET, 0.)
    call BlzFrameSetText(ui_frame[UI_TARGET_MOVEMENT_TEXT], "|cffffffffN/A|r")
    //call BlzFrameSetEnable(ui_frame[UI_TARGET_HP_BAR_TEXT], false)
    call BlzFrameSetScale(ui_frame[UI_TARGET_MOVEMENT_TEXT], 1.00)
    call BlzFrameSetTextAlignment(ui_frame[UI_TARGET_MOVEMENT_TEXT], TEXT_JUSTIFY_MIDDLE, TEXT_JUSTIFY_LEFT)
    
    call BlzTriggerRegisterFrameEvent(ui_show_ui_tooltip_trig, ui_frame[UI_TARGET_MOVEMENT_TEXT], FRAMEEVENT_MOUSE_ENTER)
    call BlzTriggerRegisterFrameEvent(ui_hide_tooltip_trig, ui_frame[UI_TARGET_MOVEMENT_TEXT], FRAMEEVENT_MOUSE_LEAVE)


    //-----------------------------------------
    set tmp=null
    set abilityTooltipMouseEnterTrig=null
    call TimerStart(CreateTimer(), UI_UPDATE_FREQUENCY, true, function updateUi)
endfunction


//library MetroidvaniaUi ends
//library Respawn:

function heroRespawnIsSoloOwnerOfSpawnPoint takes integer index returns boolean
    local group g= CreateGroup()
    local unit u= null
    local integer i
    local boolean returnValue= true
    local destructable spawnPoint= udg_respawnCurrentPoint[index]
    call BlzGroupAddGroupFast(udg_heroes_all, g)
    loop
        set u=FirstOfGroup(g)
        exitwhen returnValue or u == null
        set i=GetUnitUserData(u)
        if i != index and spawnPoint == udg_respawnCurrentPoint[i] then
            set returnValue=false
        endif
        call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
    set g=null
    set u=null
    set spawnPoint=null
    return returnValue
endfunction

function heroRespawnChangeSpawnText takes unit u,real destx,real desty returns nothing
    local texttag text= CreateTextTag()
    call SetTextTagPermanent(text, false)
    call SetTextTagLifespan(text, 3.5)
    call SetTextTagFadepoint(text, 2.5)
    call setTextTagToPlayerColor(text , GetOwningPlayer(u))
    call SetTextTagPos(text, destx, desty, 64.)
    call SetTextTagVelocityBJ(text, 32., 90.)
    call SetTextTagText(text, "Emergency Backup|nConnected!", TextTagSize2Height(8))
    set text=null
endfunction

function heroRespawnUpdateSpawnPointWithDistanceCheck takes unit u,destructable newSpawnPoint returns nothing
    local integer index= GetUnitUserData(u)
    local real ux= GetUnitX(u)
    local real uy= GetUnitY(u)
    local real destx= GetDestructableX(newSpawnPoint)
    local real desty= GetDestructableY(newSpawnPoint)
    local real dx= ux - destx
    local real dy= uy - desty
    local real distanceSqr= dx * dx + dy * dy
    if distanceSqr < HERO_RESPAWN_DISTANCE_SQR and udg_respawnCurrentPoint[index] != newSpawnPoint then
        if heroRespawnIsSoloOwnerOfSpawnPoint(index) then
            call KillDestructable(udg_respawnCurrentPoint[index])
        endif
        set udg_respawnCurrentPoint[index]=newSpawnPoint
        call DestructableRestoreLife(newSpawnPoint, 20.0, true)
        call heroRespawnChangeSpawnText(u , destx , desty)
    endif
endfunction

function heroRespawnGo takes integer index returns nothing
    local unit u= udg_UDexUnits[index]
    local destructable spawn= udg_respawnCurrentPoint[index]
    local real x= GetDestructableX(spawn)
    local real y= GetDestructableY(spawn)
    call SetUnitX(u, x)
    call SetUnitY(u, y)
    call DestroyFogModifier(hero_respawn_vision[index])
    call GroupAddUnit(udg_heroes_alive, u)
    call GroupRemoveUnit(udg_heroes_dead, u)
    if GetLocalPlayer() == GetOwningPlayer(u) then
        call SelectUnit(u, true)
    endif
    set hero_respawn_vision[index]=null
    set spawn=null
    set u=null
endfunction

function heroRespawnSetupTexttag takes integer index returns nothing
    local unit u= udg_UDexUnits[index]
    local real x= GetUnitX(u)
    local real y= GetUnitY(u)
    local texttag text= CreateTextTag()
    set hero_respawn_texttag[index]=text
    set u=null
    call SetTextTagPermanent(text, false)
    call SetTextTagLifespan(text, 5.5)
    call SetTextTagFadepoint(text, 5.1)
    call SetTextTagColor(text, 236, 60, 60, 190)
    call SetTextTagPos(text, x, y, 128)
    set text=null
endfunction

function heroRespawnTick takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local integer index= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
    set hero_respawn_remaining[index]=hero_respawn_remaining[index] - 1
    if hero_respawn_remaining[index] == 6 then
        call heroRespawnSetupTexttag(index)
    endif
    if hero_respawn_remaining[index] > 0 then
        call SetTextTagText(hero_respawn_texttag[index], "System Reset in:|n" + I2S(hero_respawn_remaining[index]), TextTagSize2Height(8))
    else
        call heroRespawnGo(index)
        call ReleaseTimer(t)
    endif
    set t=null
endfunction

function heroRespawnLater takes unit u returns nothing
    local integer index= GetUnitUserData(u)
    local timer t= NewTimerEx(index)
    set hero_respawn_remaining[index]=7
    set hero_respawn_vision[index]=CreateFogModifierRadius(GetOwningPlayer(u), FOG_OF_WAR_VISIBLE, GetUnitX(u), GetUnitY(u), 250.0, true, true)
    call FogModifierStart(hero_respawn_vision[index])
    call TimerStart(t, 1.0, true, function heroRespawnTick)
    set t=null
    set u=null
endfunction

//library Respawn ends
//library DestructableUpdates:


        function s__DestructableUpdater_setHigh takes destructable d returns nothing
            local integer id= GetHandleId(d)
            local integer flag= (LoadInteger(Table__ht, (s__DestructableUpdater_table), (id))) // INLINED!!
            if flag == LOW_FLAG then
                //LOW and NOT DEAD and not playing animation
                call RemoveSavedInteger(Table__ht, (((s__DestructableUpdater_table))), (id)) // INLINED!!
                call SetDestructableAnimation(d, ANIM_HIGH_ALIVE)
            elseif flag == DEAD_LOW_FLAG then
                call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( DEAD_FLAG)) // INLINED!!
                call SetDestructableAnimation(d, ANIM_HIGH_DEAD)
            endif
        endfunction

        function s__DestructableUpdater_setLow takes destructable d returns nothing
            local integer id= GetHandleId(d)
            local integer flag= (LoadInteger(Table__ht, (s__DestructableUpdater_table), (id))) // INLINED!!
            //call BJDebugMsg("Set Low: " + GetDestructableName(d) + ", flag=" + I2S(flag))
            if flag == NO_FLAG then
                call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( LOW_FLAG)) // INLINED!!
                call SetDestructableAnimation(d, ANIM_LOW_ALIVE)
            elseif flag == DEAD_FLAG then
                call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( DEAD_LOW_FLAG)) // INLINED!!
                call SetDestructableAnimation(d, ANIM_LOW_DEAD)
            endif
        endfunction

        function s__DestructableUpdater_updateLowerableDestructable takes destructable d returns nothing
            local real dx= GetDestructableX(d) - s__DestructableUpdater_ux
            local real y= GetDestructableY(d)
            local real dy= y - s__DestructableUpdater_uy
            if y < s__DestructableUpdater_uy and ( dx * dx + dy * dy ) < WALL_LOW_RANGE_SQR then
                call s__DestructableUpdater_setLow(d)
            else
                call s__DestructableUpdater_setHigh(d)
            endif
        endfunction

        function s__DestructableUpdater_updateDestructable takes nothing returns nothing
            local destructable d= GetEnumDestructable()
            local integer id= GetHandleId(d)
            if not (HaveSavedInteger(Table__ht, (s__DestructableUpdater_table), (id))) and GetDestructableLife(d) == 0. and GetDestructableMaxLife(d) > 0. then // INLINED!!
                call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( DEAD_FLAG)) // INLINED!!
            endif
            if GetDestructableOccluderHeight(d) == 200.00 or strEndsWith(GetDestructableName(d) , "lowerable") then
                call s__DestructableUpdater_updateLowerableDestructable(d)
            elseif GetDestructableTypeId(d) == SPAWN_POINT_DEST then
                call heroRespawnUpdateSpawnPointWithDistanceCheck(s__DestructableUpdater_u , d)
            endif
        endfunction

        function s__DestructableUpdater_foreachUnit takes nothing returns nothing
            set s__DestructableUpdater_u=GetEnumUnit()
            set s__DestructableUpdater_ux=GetUnitX(s__DestructableUpdater_u)
            set s__DestructableUpdater_uy=GetUnitY(s__DestructableUpdater_u)
            call SetRect(enumRect, s__DestructableUpdater_ux - WALL_CHECK_RANGE, s__DestructableUpdater_uy - WALL_CHECK_RANGE, s__DestructableUpdater_ux + WALL_CHECK_RANGE, s__DestructableUpdater_uy + WALL_CHECK_RANGE)
            call EnumDestructablesInRect(enumRect, null, function s__DestructableUpdater_updateDestructable)
        endfunction

        function s__DestructableUpdater_updateLoop takes nothing returns nothing
            call ForGroup(udg_heroes_alive, function s__DestructableUpdater_foreachUnit)
            //For some reason did BlzGroupAddGroupFast lagg my game, so I cannot FirstOfGroup-loop here
        endfunction

        function s__DestructableUpdater_onInit takes nothing returns nothing
            call TimerStart(CreateTimer(), 0.2, true, function s__DestructableUpdater_updateLoop)
            set s__DestructableUpdater_table=s__Table_create()
        endfunction

        function s__DestructableUpdater_resetAnimatingFlag takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer id= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            call ReleaseTimer(t)
            call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( BlzBitAnd((LoadInteger(Table__ht, (s__DestructableUpdater_table), (id))), BlzBitXor(ANIMATING_FLAG, - 1)))) // INLINED!!
            set t=null
        endfunction

//library DestructableUpdates ends
//library MetroidvaniaController:


        //method updateCooldown takes nothing returns nothing defaults nothing
    
//Implemented from module Alloc:
    
        function s__CooldownDetails_allocate takes nothing returns integer
            local integer this
    
            if ( s__CooldownDetails_Alloc___recycle[(0)] == 0 ) then
                set s__CooldownDetails_Alloc___instanceCount=s__CooldownDetails_Alloc___instanceCount + 1
                set this=s__CooldownDetails_Alloc___instanceCount
            else
                set this=s__CooldownDetails_Alloc___recycle[(0)]
                set s__CooldownDetails_Alloc___recycle[(0)]=s__CooldownDetails_Alloc___recycle[s__CooldownDetails_Alloc___recycle[(0)]]
            endif

    
            return this
        endfunction
    
        function s__CooldownDetails_deallocate takes integer this returns nothing
            set s__CooldownDetails_Alloc___recycle[this]=s__CooldownDetails_Alloc___recycle[(0)]
            set s__CooldownDetails_Alloc___recycle[(0)]=this
        endfunction

        
        function s__CooldownDetails_create takes real actionPoint,real actionDuration,real actionCooldown returns integer
            local integer this= s__CooldownDetails_allocate()
            set s__CooldownDetails_actionPoint[this]=actionPoint
            set s__CooldownDetails_actionDuration[this]=actionDuration
            set s__CooldownDetails_actionCooldown[this]=actionCooldown
            return this
        endfunction

        function s__CooldownDetails_printDetails takes integer this returns nothing
            call BJDebugMsg("this=" + I2S(this) + ", AP=" + R2S(s__CooldownDetails_actionPoint[this]) + ", Dur=" + R2S(s__CooldownDetails_actionDuration[this]) + ", Cooldown=" + R2S(s__CooldownDetails_actionCooldown[this]))
        endfunction

        function s__CooldownDetails_update takes integer this,real actionPoint,real actionDuration,real actionCooldown returns nothing
            set s__CooldownDetails_actionPoint[this]=actionPoint
            set s__CooldownDetails_actionDuration[this]=actionDuration
            set s__CooldownDetails_actionCooldown[this]=actionCooldown
            //call BJDebugMsg("--- Updated cooldown details ---")
            //call printDetails()
        endfunction

        function s__CooldownDetails_destroy takes integer this returns nothing
            call s__CooldownDetails_deallocate(this)
        endfunction




        function s__HeroActionBase_isDoing takes integer this returns boolean
            return s__HeroActionBase_actionState[this] == ACTION_STATE_DOING
        endfunction
        function s__HeroActionBase_isBackswing takes integer this returns boolean
            return s__HeroActionBase_actionState[this] == ACTION_STATE_BACKSWING
        endfunction
        function s__HeroActionBase_isOnCooldown takes integer this returns boolean
            return s__HeroActionBase_actionState[this] != ACITON_STATE_READY
        endfunction
        function s__HeroActionBase_isReady takes integer this returns boolean
            return s__HeroActionBase_actionState[this] == ACITON_STATE_READY
        endfunction
        function s__HeroActionBase_isCastable takes integer this returns boolean
            return (s__HeroActionBase_actionState[(this)] == ACITON_STATE_READY) and (GetUnitState((s__HeroActionBase_u[this]), UNIT_STATE_MANA)) > s__HeroActionBase_energyCost[this] // INLINED!!
        endfunction
        function s__HeroActionBase__get_owner takes integer this returns player
            return GetOwningPlayer(s__HeroActionBase_u[this])
        endfunction

        function s__HeroActionBase_updateAbilityDetails takes integer this returns nothing
            call BJDebugMsg("!!! NO UPDATE FUNCTION IMPLEMENTED !!!")
        endfunction

//Implemented from module MetroidvaniaController__ActionFlow:
        function s__HeroActionBase_MetroidvaniaController__ActionFlow___releaseTimer takes nothing returns nothing
            call ReleaseTimer(GetExpiredTimer())
        endfunction
        function s__HeroActionBase_MetroidvaniaController__ActionFlow___updateUi takes nothing returns nothing
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((GetExpiredTimer())))) // INLINED!!
            local real remainingCooldown= TimerGetRemaining(s__HeroActionBase_cooldownTimer[this])
            if remainingCooldown > 0 then
                if GetLocalPlayer() == GetOwningPlayer(s__HeroActionBase_u[this]) then
                    call updateCooldown(s__HeroActionBase_uiButtonIndex[this] , s__CooldownDetails_actionCooldown[s__HeroActionBase_cooldownDetails[this]] , remainingCooldown)
                endif
            else
                call ReleaseTimer(GetExpiredTimer())
                set s__HeroActionBase_cooldownTimer[this]=null
            endif
        endfunction
        function s__HeroActionBase_MetroidvaniaController__ActionFlow___cooldownFinished takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            if (st__MetroidvaniaController__ActionInterface_onCooldownFinished[si__MetroidvaniaController__ActionInterface_type[this]]!=null) then
                call sc__MetroidvaniaController__ActionInterface_onCooldownFinished(this)
            endif
            call ReleaseTimer(t)
            set t=null
            set s__HeroActionBase_actionState[this]=ACITON_STATE_READY
            call sc___prototype9_evaluate(1,s__HeroActionBase_u[this] , this)
        endfunction
        function s__HeroActionBase_MetroidvaniaController__ActionFlow___atBackswing takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            if (st__MetroidvaniaController__ActionInterface_onBackswing[si__MetroidvaniaController__ActionInterface_type[this]]!=null) then
                call sc__MetroidvaniaController__ActionInterface_onBackswing(this)
            endif
            call TimerStart(t, s__CooldownDetails_actionCooldown[s__HeroActionBase_cooldownDetails[this]] - s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]], false, function s__HeroActionBase_MetroidvaniaController__ActionFlow___cooldownFinished)
            set t=null
            set s__HeroActionBase_actionState[this]=ACTION_STATE_COOLDOWN
            call sc___prototype9_evaluate(1,s__HeroActionBase_u[this] , this)
        endfunction
        function s__HeroActionBase_MetroidvaniaController__ActionFlow___atActionPoint takes nothing returns nothing
            local timer t= GetExpiredTimer()
            local integer this= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
            if (st__MetroidvaniaController__ActionInterface_onActionPoint[si__MetroidvaniaController__ActionInterface_type[this]]!=null) then
                call sc__MetroidvaniaController__ActionInterface_onActionPoint(this)
            endif
            call TimerStart(t, s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] - s__CooldownDetails_actionPoint[s__HeroActionBase_cooldownDetails[this]], false, function s__HeroActionBase_MetroidvaniaController__ActionFlow___atBackswing)
            set t=null
            if GetLocalPlayer() == GetOwningPlayer(s__HeroActionBase_u[this]) then
                call SelectUnit(s__HeroActionBase_u[this], true)
            endif
            set s__HeroActionBase_actionState[this]=ACTION_STATE_BACKSWING
            call sc___prototype9_evaluate(1,s__HeroActionBase_u[this] , this)
        endfunction
        function s__HeroActionBase_start takes integer this returns nothing
            call ConsumeMana(s__HeroActionBase_u[this] , s__HeroActionBase_energyCost[this])
            if (st__MetroidvaniaController__ActionInterface_onStart[si__MetroidvaniaController__ActionInterface_type[this]]!=null) then
                call sc__MetroidvaniaController__ActionInterface_onStart(this)
            endif
            set s__HeroActionBase_cooldownTimer[this]=NewTimerEx(this)
            call TimerStart(s__HeroActionBase_cooldownTimer[this], s__CooldownDetails_actionCooldown[s__HeroActionBase_cooldownDetails[this]], false, function s__HeroActionBase_MetroidvaniaController__ActionFlow___releaseTimer)
            call TimerStart(NewTimerEx(this), s__CooldownDetails_actionPoint[s__HeroActionBase_cooldownDetails[this]], false, function s__HeroActionBase_MetroidvaniaController__ActionFlow___atActionPoint)
            call TimerStart(NewTimerEx(this), 0.02, true, function s__HeroActionBase_MetroidvaniaController__ActionFlow___updateUi)
            set s__HeroActionBase_actionState[this]=ACTION_STATE_DOING
            if s__CooldownDetails_actionPoint[s__HeroActionBase_cooldownDetails[this]] == 0. then
                call sc___prototype9_evaluate(1,s__HeroActionBase_u[this] , this)
            elseif GetLocalPlayer() == GetOwningPlayer(s__HeroActionBase_u[this]) then
                call ClearSelection()
            endif
        endfunction

        function s__HeroActionBase_create takes unit u,integer uiIndex,string iconPath returns integer
            local integer this= s__HeroActionBase__allocate()
            set s__HeroActionBase_u[this]=u
            set s__HeroActionBase_cooldownDetails[this]=s__CooldownDetails_create(1.0 , 1.0 , 1.0)
            set s__HeroActionBase_isHolding[this]=false
            set s__HeroActionBase_actionState[this]=ACITON_STATE_READY
            set s__HeroActionBase_uiButtonIndex[this]=uiIndex
            call BlzFrameSetVisible(ui_frame[s__HeroActionBase_uiButtonIndex[this] + UI_ABIL_BTN_OFFSET], true)
            call BlzFrameSetVisible(ui_frame[s__HeroActionBase_uiButtonIndex[this] + UI_ABIL_ICON_OFFSET], true)
            call BlzFrameSetTexture(ui_frame[s__HeroActionBase_uiButtonIndex[this] + UI_ABIL_ICON_OFFSET], iconPath, 0, true)
            call BlzFrameSetValue(ui_frame[s__HeroActionBase_uiButtonIndex[this] + UI_ABIL_COOLDOWN_OFFSET], 0)
            return this
        endfunction

        function s__HeroActionBase_destroy takes integer this returns nothing
            if s__HeroActionBase_cooldownTimer[this] != null then
                call ReleaseTimer(s__HeroActionBase_cooldownTimer[this])
                set s__HeroActionBase_cooldownTimer[this]=null
            endif
            call s__CooldownDetails_deallocate((s__HeroActionBase_cooldownDetails[this])) // INLINED!!
            call sc__MetroidvaniaController__ActionInterface_deallocate(this)
        endfunction





        function s__MetroidvaniaController_keyToAction takes integer this,oskeytype key returns integer
            if key == MC_KEY_ATTACK then
                return s__MetroidvaniaController_attack[this]
            elseif key == MC_KEY_ATTACK_ALT then
                return s__MetroidvaniaController_attackAlt[this]
            elseif key == MC_KEY_UTIL_1 then
                return s__MetroidvaniaController_util1[this]
            elseif key == MC_KEY_UTIL_2 then
                return s__MetroidvaniaController_util2[this]
            elseif key == MC_KEY_DASH then
                return s__MetroidvaniaController_dash[this]
            elseif key == MC_KEY_INTERACT then
                return s__MetroidvaniaController_interact[this]
            elseif key == MC_KEY_MAP then
                return s__MetroidvaniaController_map[this]
            else
                return NO_ACTION
            endif
        endfunction

        function s__MetroidvaniaController_updateTargetCoords takes integer this,integer action returns nothing
            if s__MetroidvaniaController_target[this] != null and UnitAlive(s__MetroidvaniaController_target[this]) and not s__HeroActionBase_ignoreTarget[action] then
                set s__MetroidvaniaController_currentActionTargetX[this]=GetUnitX(s__MetroidvaniaController_target[this])
                set s__MetroidvaniaController_currentActionTargetY[this]=GetUnitY(s__MetroidvaniaController_target[this])
            else
                //call BJDebugMsg("updateTargetCoords: Playerid=" + I2S(GetPlayerId(GetOwningPlayer(.u))))
                set s__MetroidvaniaController_currentActionTargetX[this]=(s__LockCamExtension_mx((GetPlayerId(((GetOwningPlayer(s__MetroidvaniaController_u[this]))))))) // INLINED!!
                set s__MetroidvaniaController_currentActionTargetY[this]=(s__LockCamExtension_my((GetPlayerId(((GetOwningPlayer(s__MetroidvaniaController_u[this]))))))) // INLINED!!
            endif
        endfunction

        function s__MetroidvaniaController_tryToExecuteAction takes integer this,integer action returns nothing
            if not s__MetroidvaniaController_isDoingAction[this] and action > 0 and s__HeroActionBase_isCastable(action) then
                set s__MetroidvaniaController_currentAction[this]=action
                set s__MetroidvaniaController_isDoingAction[this]=true
                call s__MetroidvaniaController_updateTargetCoords(this,action)
                call s__HeroActionBase_start(action)
            endif
        endfunction

        function s__MetroidvaniaController_MetroidvaniaController__controllerCallback takes unit u,integer action returns nothing
            local integer this= (GetPlayerId(GetOwningPlayer(u)))
            //Should be at start of "backswing" at earliest, allow queueing actions at start of "backswing"
            set s__MetroidvaniaController_isDoingAction[this]=false
            if s__MetroidvaniaController_currentAction[this] == action then
                if s__HeroActionBase_isHolding[s__MetroidvaniaController_currentAction[this]] and s__HeroActionBase_isCastable(s__MetroidvaniaController_currentAction[this]) then
                    call s__MetroidvaniaController_updateTargetCoords(this,s__MetroidvaniaController_currentAction[this])
                    call s__HeroActionBase_start(s__MetroidvaniaController_currentAction[this])
                elseif s__MetroidvaniaController_queuedAction[this] != NO_ACTION and s__HeroActionBase_isCastable(s__MetroidvaniaController_queuedAction[this]) then
                    call s__MetroidvaniaController_updateTargetCoords(this,s__MetroidvaniaController_queuedAction[this])
                    set s__MetroidvaniaController_currentAction[this]=s__MetroidvaniaController_queuedAction[this]
                    call s__HeroActionBase_start(s__MetroidvaniaController_currentAction[this])
                endif
            endif
        endfunction

        function s__MetroidvaniaController_keyPressed takes nothing returns nothing
            local integer this= (GetPlayerId(GetTriggerPlayer()))
            local real tx
            local real ty
            local integer action
            if UnitAlive(s__MetroidvaniaController_u[this]) then
                if not s__MetroidvaniaController_isDoingAction[this] then
                    set s__MetroidvaniaController_currentAction[this]=s__MetroidvaniaController_keyToAction(this,BlzGetTriggerPlayerKey())
                    set s__MetroidvaniaController_queuedAction[this]=NO_ACTION
                    if s__MetroidvaniaController_currentAction[this] != NO_ACTION then
                        //call BJDebugMsg("Trying to cast: " + currentAction.abilityName())
                        set s__HeroActionBase_isHolding[s__MetroidvaniaController_currentAction[this]]=true
                        call s__MetroidvaniaController_tryToExecuteAction(this,s__MetroidvaniaController_currentAction[this])
                    else
                        //call BJDebugMsg("Action is NO_ACTION")
                    endif
                else
                    //call BJDebugMsg("Doing Action...")
                    set action=s__MetroidvaniaController_keyToAction(this,BlzGetTriggerPlayerKey())
                    if s__MetroidvaniaController_currentAction[this] == action then
                        set s__HeroActionBase_isHolding[s__MetroidvaniaController_currentAction[this]]=true
                    else
                        set s__MetroidvaniaController_queuedAction[this]=action
                    endif
                endif
            else
                set s__MetroidvaniaController_currentAction[this]=NO_ACTION
                set s__MetroidvaniaController_queuedAction[this]=NO_ACTION
            endif
        endfunction
    
        function s__MetroidvaniaController_keyReleased takes nothing returns nothing
            local integer this= (GetPlayerId(GetTriggerPlayer()))
            local integer action= s__MetroidvaniaController_keyToAction(this,BlzGetTriggerPlayerKey())
            if action != NO_ACTION then
                set s__HeroActionBase_isHolding[action]=false
                call sc__MetroidvaniaController__ActionInterface_onRelease(action)
            endif
        endfunction

        function s__MetroidvaniaController_selectTargetNearMouse takes nothing returns nothing
            local player p= GetTriggerPlayer()
            local integer this= (GetPlayerId(p))
            local group g= CreateGroup()
            local unit u
            local real mx= (s__LockCamExtension_mx((GetPlayerId(((p)))))) // INLINED!!
            local real my= (s__LockCamExtension_my((GetPlayerId(((p)))))) // INLINED!!
            local real dx
            local real dy
            local unit selectedUnit= null

            local real distanceSqr= 999999.9
            local real dSqr
            call GroupEnumUnitsInRange(g, mx, my, 80.0, null)
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                set dx=GetUnitX(u) - mx
                set dy=GetUnitY(u) - my
                set dSqr=dx * dx + dy * dy
                if s__MetroidvaniaController_u[this] != u and UnitAlive(u) and dSqr < distanceSqr then
                    set distanceSqr=dSqr
                    set selectedUnit=u
                endif
                call GroupRemoveUnit(g, u)
            endloop
            call DestroyGroup(g)

            set s__MetroidvaniaController_target[this]=selectedUnit

            if p == GetLocalPlayer() then
                if s__MetroidvaniaController_target[this] == null then
                    call clearUiTarget(this)
                    //call BJDebugMsg("no target")
                else
                    //call BJDebugMsg("Target: " + GetUnitName(target))
                    call setUiTarget(s__MetroidvaniaController_target[this])
                endif
            endif

            set selectedUnit=null
            set g=null
            set p=null
        endfunction

        function s__MetroidvaniaController_onClick takes nothing returns nothing
            if (s__UserMouse_mouseButtonStack[( (s__UserMouse__staticgetindex(GetTriggerPlayer())) - 1 ) * 3 + (GetHandleId(((MOUSE_BUTTON_TYPE_LEFT))))] > 0) then // INLINED!!
                call s__MetroidvaniaController_selectTargetNearMouse()
            endif
        endfunction

        function s__MetroidvaniaController_updateAbilityDetails takes integer this returns nothing
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_attack[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_attackAlt[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_util1[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_util2[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_dash[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_interact[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_map[this])
        endfunction

        function s__MetroidvaniaController_onInit takes nothing returns nothing
            local player p
            local integer i= 0
            local integer this
            set s__MetroidvaniaController_mc_main_down=CreateTrigger()
            set s__MetroidvaniaController_mc_main_up=CreateTrigger()
            call TriggerAddCondition(s__MetroidvaniaController_mc_main_down, Condition(function s__MetroidvaniaController_keyPressed))
            call TriggerAddCondition(s__MetroidvaniaController_mc_main_up, Condition(function s__MetroidvaniaController_keyReleased))
call s__UserMouse_registerCode((function s__MetroidvaniaController_onClick ) , ( EVENT_MOUSE_DOWN)) // INLINED!!
            loop
                exitwhen i > 4
                set p=Player(i)
                set this=(i)
                set s__MetroidvaniaController_isDoingAction[this]=false
                set s__MetroidvaniaController_isHolding[this]=false
                if GetPlayerController(p) == MAP_CONTROL_USER and GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING then
//BlzTriggerRegisterPlayerKeyEvent takes trigger whichTrigger, player whichPlayer, oskeytype key, integer metaKey, boolean keyDown returns event
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_ATTACK, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_ATTACK, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_ATTACK_ALT, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_ATTACK_ALT, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_UTIL_1, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_UTIL_1, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_UTIL_2, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_UTIL_2, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_DASH, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_DASH, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_INTERACT, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_INTERACT, 0, false)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_down, p, MC_KEY_MAP, 0, true)
                    call BlzTriggerRegisterPlayerKeyEvent(s__MetroidvaniaController_mc_main_up, p, MC_KEY_MAP, 0, false)
                endif
                set i=i + 1
            endloop
            set p=null
        endfunction

        function s__MetroidvaniaController_setAttack takes player p,integer attack returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_attack[this]=attack
            call s__MetroidvaniaController_updateAbilityDetails(this)
        endfunction
        function s__MetroidvaniaController_setAttackAlt takes player p,integer attackAlt returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_attackAlt[this]=attackAlt
            call s__MetroidvaniaController_updateAbilityDetails(this)
        endfunction
        function s__MetroidvaniaController_setUtil1 takes player p,integer util1 returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_util1[this]=util1
            call s__MetroidvaniaController_updateAbilityDetails(this)
        endfunction
        function s__MetroidvaniaController_setUtil2 takes player p,integer util2 returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_util2[this]=util2
            call s__MetroidvaniaController_updateAbilityDetails(this)
        endfunction
        function s__MetroidvaniaController_setDash takes player p,integer dash returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_dash[this]=dash
            call s__MetroidvaniaController_updateAbilityDetails(this)
        endfunction
        function s__MetroidvaniaController_setMap takes player p,integer map returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_map[this]=map
        endfunction
        function s__MetroidvaniaController_setInteract takes player p,integer interact returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_interact[this]=interact
        endfunction
        function s__MetroidvaniaController_setHero takes player p,unit hero returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_u[this]=hero
        endfunction
        function s__MetroidvaniaController_setTarget takes player p,unit target returns nothing
            local integer this= (GetPlayerId(p))
            set s__MetroidvaniaController_target[this]=target
        endfunction
        
        function s__MetroidvaniaController_getAttack takes integer this returns integer
            return s__MetroidvaniaController_attack[this]
        endfunction
        function s__MetroidvaniaController_getAttackAlt takes integer this returns integer
            return s__MetroidvaniaController_attackAlt[this]
        endfunction
        function s__MetroidvaniaController_getUtil1 takes integer this returns integer
            return s__MetroidvaniaController_util1[this]
        endfunction
        function s__MetroidvaniaController_getUtil2 takes integer this returns integer
            return s__MetroidvaniaController_util2[this]
        endfunction
        function s__MetroidvaniaController_getDash takes integer this returns integer
            return s__MetroidvaniaController_dash[this]
        endfunction
        function s__MetroidvaniaController_getMap takes integer this returns integer
            return s__MetroidvaniaController_map[this]
        endfunction
        function s__MetroidvaniaController_getInteract takes integer this returns integer
            return s__MetroidvaniaController_interact[this]
        endfunction
        function s__MetroidvaniaController_getTargetUnit takes integer this returns unit
            return s__MetroidvaniaController_target[this]
        endfunction
        function s__MetroidvaniaController_getHero takes integer this returns unit
            return s__MetroidvaniaController_u[this]
        endfunction

        function s__MetroidvaniaController_setTargetUnit takes integer this,unit newTarget returns nothing
            set s__MetroidvaniaController_target[this]=newTarget
        endfunction

        //call MetroidvaniaController.disableControl()
        function s__MetroidvaniaController_disableControl takes nothing returns nothing
            call ClearSelection()
        endfunction
        function s__MetroidvaniaController_resumeControl takes nothing returns nothing
            call SelectUnit(s__MetroidvaniaController_u[(GetPlayerId(GetLocalPlayer()))], true)
        endfunction

        function s__MetroidvaniaController_getTargetX takes player p returns real
            //call BJDebugMsg("getTargetX: Playerid=" + I2S(GetPlayerId(p)))
            return s__MetroidvaniaController_currentActionTargetX[(GetPlayerId(p))]
        endfunction
        function s__MetroidvaniaController_getTargetY takes player p returns real
            return s__MetroidvaniaController_currentActionTargetY[(GetPlayerId(p))]
        endfunction
        function s__MetroidvaniaController_getMetroidvaniaController takes player p returns integer
            return (GetPlayerId(p))
        endfunction
    function MetroidvaniaController__controllerCallback takes unit u,integer action returns nothing
        call s__MetroidvaniaController_MetroidvaniaController__controllerCallback(u , action)
    endfunction
    function GetHero takes player p returns unit
        return (s__MetroidvaniaController_u[((GetPlayerId((p))))]) // INLINED!!
    endfunction

//library MetroidvaniaController ends
//===========================================================================
// 
// Mecha Protectors 1.1.0
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Sat Feb 25 12:27:39 2023
//   Map Author: ThompZon
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************


function InitGlobals takes nothing returns nothing
    local integer i= 0
    set udg_Radians_QuarterPi=0
    set udg_Radians_QuarterTurn=0
    set udg_Radians_Turn=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DPause[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFXRate[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFXModel[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFXTimeLeft[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DSimple[i]=false
        set i=i + 1
    endloop

    set udg_Knockback2DCollision=0
    set udg_Knockback2DSimple=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DUnbiasedCollision[i]=false
        set i=i + 1
    endloop

    set udg_Knockback2DAmphibious=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DAmphibious[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DCollision[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DDestRadius[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DKillTrees[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DVelocity[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFriction[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DSinD2[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DCosD2[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DSinD1[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DCosD1[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DSinH[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DCosH[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DRadius[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFlying[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DSin[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DCos[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DLastY[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DLastX[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DHeightThreshold[i]=0
        set i=i + 1
    endloop

    set udg_Knockback2DHeight=0
    set udg_Knockback2DOverride=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DTimeLeft[i]=0
        set i=i + 1
    endloop

    set udg_Knockback2DTime=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DDistanceLeft[i]=0
        set i=i + 1
    endloop

    set udg_Knockback2DDistance=0
    set udg_Knockback2DAngle=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DAngle[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DBounce[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DOverride[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DFreeze[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DHeight[i]=0
        set i=i + 1
    endloop

    set udg_K2DTimer=CreateTimer()
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DNext[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_K2DPrev[i]=0
        set i=i + 1
    endloop

    set udg_K2DItemOffset=false
    set udg_K2DItemsFound=false
    set udg_K2DMaxDestRadius=0
    set udg_K2DMinY=0
    set udg_K2DMinX=0
    set udg_K2DMaxY=0
    set udg_K2DMaxX=0
    set udg_K2DY=0
    set udg_K2DX=0
    set udg_Knockback2DFXRate=0
    set udg_Knockback2DDefaultFXRate=0
    set udg_Knockback2DLoopFX=""
    set udg_Knockback2DDefaultFX=""
    set udg_Knockback2DGravity=0
    set udg_Knockback2DDefaultGravity=0
    set udg_Knockback2DTreeOrDebris=""
    set udg_Knockback2DDestRadius=0
    set udg_Knockback2DDefaultDestRadius=0
    set udg_Knockback2DKillTrees=false
    set udg_Knockback2DDefaultKillTrees=false
    set udg_Knockback2DPause=false
    set udg_Knockback2DDefaultPause=false
    set udg_Knockback2DBounces=false
    set udg_Knockback2DDefaultBounce=false
    set udg_Knockback2DFriction=0
    set udg_Knockback2DDefaultFriction=0
    set udg_Knockback2DRobustPathing=0
    set udg_K2DTimeout=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitBeingKnockedBack[i]=false
        set i=i + 1
    endloop

    set udg_Knockback2DUnbiasedCollision=false
    set udg_LoopInt=0
    set udg_CP_PointIsWalkable=false
    set udg_CP_HiddenItemsIndex=0
    set udg_NextDamageIsAttack=false
    set udg_NextDamageIsMelee=false
    set udg_NextDamageIsRanged=false
    set udg_NextDamageWeaponT=0
    set udg_DamageFilterAttackT=0
    set udg_DamageFilterDamageT=0
    set udg_DamageFilterSourceT=0
    set udg_DamageFilterTargetT=0
    set udg_DamageFilterType=0
    set udg_DamageFilterSourceB=0
    set udg_DamageFilterTargetB=0
    set udg_DamageFilterMinAmount=0
    set udg_UDex=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UnitIndexLock[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UDexPrev[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UDexNext[i]=0
        set i=i + 1
    endloop

    set udg_UnitIndexEvent=0
    set udg_UDexRecycle=0
    set udg_UnitIndexerEnabled=false
    set udg_UDexWasted=0
    set udg_UDexGen=0
    set udg_DAMAGE_FACTOR_ELUNES=0
    set udg_DAMAGE_FACTOR_ETHEREAL=0
    set udg_DAMAGE_FACTOR_BRACERS=0
    set udg_NextDamageType=0
    set udg_NextDamageOverride=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_LastDmgPrevType[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_LastDmgWasSpell[i]=false
        set i=i + 1
    endloop

    set udg_LastDamageHP=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_LastDmgPrevAmount[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_LastDmgValue[i]=0
        set i=i + 1
    endloop

    set udg_DamageTypeExplosive=0
    set udg_DamageTypeCriticalStrike=0
    set udg_DamageTypeHeal=0
    set udg_DamageTypeBlocked=0
    set udg_DamageTypeReduced=0
    set udg_DmgEvRecursionN=0
    set udg_DmgEvRunning=false
    set udg_DmgEvStarted=false
    set udg_IsDamageSpell=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_HideDamageFrom[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UnitDamageRegistered[i]=false
        set i=i + 1
    endloop

    set udg_DamageEventsWasted=0
    set udg_DmgEvTimer=CreateTimer()
    set udg_AfterDamageEvent=0
    set udg_DamageEvent=0
    set udg_DamageModifierEvent=0
    set udg_DamageEventType=0
    set udg_DamageEventPrevAmt=0
    set udg_DamageEventOverride=false
    set udg_DamageEventAmount=0
    set udg_DamageEventArmorPierced=0
    set udg_LethalDamageEvent=0
    set udg_LethalDamageHP=0
    set udg_AOEDamageEvent=0
    set udg_DamageEventAOE=0
    set udg_DamageEventAOEGroup=CreateGroup()
    set udg_DamageEventLevel=0
    set udg_DamageScalingUser=0
    set udg_DamageScalingWC3=0
    set udg_DamageTypeCode=0
    set udg_DamageTypePure=0
    set udg_DamageTypePureExplosive=0
    set udg_IsDamageAttack=false
    set udg_IsDamageCode=false
    set udg_IsDamageMelee=false
    set udg_IsDamageRanged=false
    set udg_DamageEventArmorT=0
    set udg_ARMOR_TYPE_NONE=0
    set udg_ARMOR_TYPE_FLESH=0
    set udg_ARMOR_TYPE_METAL=0
    set udg_ARMOR_TYPE_WOOD=0
    set udg_ARMOR_TYPE_ETHEREAL=0
    set udg_ARMOR_TYPE_STONE=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_ArmorTypeDebugStr[i]=""
        set i=i + 1
    endloop

    set udg_DamageEventAttackT=0
    set udg_ATTACK_TYPE_SPELLS=0
    set udg_ATTACK_TYPE_NORMAL=0
    set udg_ATTACK_TYPE_PIERCE=0
    set udg_ATTACK_TYPE_SIEGE=0
    set udg_ATTACK_TYPE_MAGIC=0
    set udg_ATTACK_TYPE_CHAOS=0
    set udg_ATTACK_TYPE_HERO=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_AttackTypeDebugStr[i]=""
        set i=i + 1
    endloop

    set udg_DamageEventDamageT=0
    set udg_DAMAGE_TYPE_UNKNOWN=0
    set udg_DAMAGE_TYPE_NORMAL=0
    set udg_DAMAGE_TYPE_ENHANCED=0
    set udg_DAMAGE_TYPE_FIRE=0
    set udg_DAMAGE_TYPE_COLD=0
    set udg_DAMAGE_TYPE_LIGHTNING=0
    set udg_DAMAGE_TYPE_POISON=0
    set udg_DAMAGE_TYPE_DISEASE=0
    set udg_DAMAGE_TYPE_DIVINE=0
    set udg_DAMAGE_TYPE_MAGIC=0
    set udg_DAMAGE_TYPE_SONIC=0
    set udg_DAMAGE_TYPE_ACID=0
    set udg_DAMAGE_TYPE_FORCE=0
    set udg_DAMAGE_TYPE_DEATH=0
    set udg_DAMAGE_TYPE_MIND=0
    set udg_DAMAGE_TYPE_PLANT=0
    set udg_DAMAGE_TYPE_DEFENSIVE=0
    set udg_DAMAGE_TYPE_DEMOLITION=0
    set udg_DAMAGE_TYPE_SLOW_POISON=0
    set udg_DAMAGE_TYPE_SPIRIT_LINK=0
    set udg_DAMAGE_TYPE_SHADOW_STRIKE=0
    set udg_DAMAGE_TYPE_UNIVERSAL=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_DamageTypeDebugStr[i]=""
        set i=i + 1
    endloop

    set udg_DamageEventDefenseT=0
    set udg_DEFENSE_TYPE_LIGHT=0
    set udg_DEFENSE_TYPE_MEDIUM=0
    set udg_DEFENSE_TYPE_HEAVY=0
    set udg_DEFENSE_TYPE_FORTIFIED=0
    set udg_DEFENSE_TYPE_NORMAL=0
    set udg_DEFENSE_TYPE_HERO=0
    set udg_DEFENSE_TYPE_DIVINE=0
    set udg_DEFENSE_TYPE_UNARMORED=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_DefenseTypeDebugStr[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_WeaponTypeDebugStr[i]=""
        set i=i + 1
    endloop

    set udg_WEAPON_TYPE_NONE=0
    set udg_WEAPON_TYPE_ML_CHOP=0
    set udg_WEAPON_TYPE_MM_CHOP=0
    set udg_WEAPON_TYPE_MH_CHOP=0
    set udg_WEAPON_TYPE_ML_SLICE=0
    set udg_WEAPON_TYPE_MM_SLICE=0
    set udg_WEAPON_TYPE_MH_SLICE=0
    set udg_WEAPON_TYPE_MM_BASH=0
    set udg_WEAPON_TYPE_MH_BASH=0
    set udg_WEAPON_TYPE_MM_STAB=0
    set udg_WEAPON_TYPE_MH_STAB=0
    set udg_WEAPON_TYPE_WL_SLICE=0
    set udg_WEAPON_TYPE_WM_SLICE=0
    set udg_WEAPON_TYPE_WH_SLICE=0
    set udg_WEAPON_TYPE_WL_BASH=0
    set udg_WEAPON_TYPE_WM_BASH=0
    set udg_WEAPON_TYPE_WH_BASH=0
    set udg_WEAPON_TYPE_WL_STAB=0
    set udg_WEAPON_TYPE_WM_STAB=0
    set udg_WEAPON_TYPE_CL_SLICE=0
    set udg_WEAPON_TYPE_CM_SLICE=0
    set udg_WEAPON_TYPE_CH_SLICE=0
    set udg_WEAPON_TYPE_AM_CHOP=0
    set udg_WEAPON_TYPE_RH_BASH=0
    set udg_DamageEventWeaponT=0
    set udg_heroes_alive=CreateGroup()
    set udg_heroes_dead=CreateGroup()
    set udg_CargoEvent=0
    set udg_DeathEvent=0
    set udg_WorldMaxX=0
    set udg_WorldMaxY=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_CargoTransportGroup[i]=CreateGroup()
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitNew[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitTransforming[i]=false
        set i=i + 1
    endloop

    set udg_UnitTypeEvent=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_CheckDeathList[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitReincarnating[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitBeingUnloaded[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitAlive[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_CheckDeathInList[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitRemoved[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_IsUnitPreplaced[i]=false
        set i=i + 1
    endloop

    set udg_CheckDeathTimer=CreateTimer()
    set udg_UDexLastRecycled=0
    set udg_UDexMax=0
    set udg_t_bool1=false
    set udg_heroes_all=CreateGroup()
    set udg_is_testing=false
    set udg_t_group1=CreateGroup()
    set udg_human_players=CreateForce()
    set udg_dashHasPoint=false
    set udg_dashTimer=CreateTimer()
    set udg_t_string1=""
    set udg_cinematic=0
    set udg_t_real1=0
    set udg_t_int1=0
    set udg_t_int2=0
    set udg_spawnedEnemies=CreateGroup()
    set udg_spawnedEnemiesPower=0
    set udg_t_real2=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_spawnedPowerArr[i]=0
        set i=i + 1
    endloop

    set udg_boss_BM_status=0
    set udg_onHeroDeathEvent=0
    set udg_boss_hero_deaths=0
    set udg_spawnedEnemiesHeat=0
    set udg_t_int3=0
    set udg_g_int1=0
    set udg_g_int2=0
    set udg_bossAICounter=0
    set udg_bossAIEnabled=false
    set udg_bossOngoing=false
    set udg_boss_MC_status=0
    set udg_conveyorNorthGroup=CreateGroup()
    set udg_conveyorEastGroup=CreateGroup()
    set udg_conveyorWestGroup=CreateGroup()
    set udg_conveyorSouthGroup=CreateGroup()
    set udg_bossTimer1=CreateTimer()
    set udg_bossBool1=false
    set udg_bossInt1=0
    set udg_bossTimer2=CreateTimer()
endfunction

//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//***************************************************************************
//*  general_functions





function damageGroup takes group g,unit source,real damage,damagetype dmgType returns nothing
    local unit u
    loop
        set u=FirstOfGroup(g)
        exitwhen u == null
call s__Damage_apply((source ) , ( u ) , (( damage )*1.0) , false , false , null , ( dmgType) , null) // INLINED!!
        call GroupRemoveUnit(g, u)
    endloop
    call DestroyGroup(g)
endfunction
//source, x, y, damage, radius, damage-type
//call damageAoENoFF(udg_t_unit1, GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit()), udg_t_real1, 200., DAMAGE_TYPE_DEMOLITION)
//call damageAoENoFF(GetHero(GetTriggerPlayer()), GetUnitX(GetTriggerUnit()), GetUnitY(GetTriggerUnit()), udg_t_real1, 200., DAMAGE_TYPE_DEMOLITION)
function damageAoENoFFWithResult takes unit source,real x,real y,real damage,real radius,damagetype dmgType,group resultGroup returns nothing
    local group targetsWithinRadius= CreateGroup()
    local player owner= GetOwningPlayer(source)
    local unit u
    call GroupEnumUnitsInRange(targetsWithinRadius, x, y, radius + 96., null)
    loop
        set u=FirstOfGroup(targetsWithinRadius)
        exitwhen u == null
        if IsUnitTargetableNoFF(u , owner) and IsUnitInRangeXY(u, x, y, radius) then
            //call UnitDamageTarget(source, u, damage, false, false, ATTACK_TYPE_NORMAL, dmgType, null)
call s__Damage_apply((source ) , ( u ) , (( damage )*1.0) , false , false , null , ( dmgType) , null) // INLINED!!
            if resultGroup != null then
                call GroupAddUnit(resultGroup, u)
            endif
        endif
        call GroupRemoveUnit(targetsWithinRadius, u)
    endloop
    call DestroyGroup(targetsWithinRadius)
    set owner=null
    set targetsWithinRadius=null
endfunction
function damageAoENoFF takes unit source,real x,real y,real damage,real radius,damagetype dmgType returns nothing
    call damageAoENoFFWithResult(source , x , y , damage , radius , dmgType , null)
endfunction
function damageAoEWithResult takes unit source,real x,real y,real damage,real radius,damagetype dmgType,group resultGroup returns nothing
    local group targetsWithinRadius= CreateGroup()
    local player owner= GetOwningPlayer(source)
    local unit u
    call GroupEnumUnitsInRange(targetsWithinRadius, x, y, radius + 96., null)
    loop
        set u=FirstOfGroup(targetsWithinRadius)
        exitwhen u == null
        if UnitAlive(u) and IsUnitInRangeXY(u, x, y, radius) then
            //call UnitDamageTarget(source, u, damage, false, false, ATTACK_TYPE_NORMAL, dmgType, null)
call s__Damage_apply((source ) , ( u ) , (( damage )*1.0) , false , false , null , ( dmgType) , null) // INLINED!!
            if resultGroup != null then
                call GroupAddUnit(resultGroup, u)
            endif
        endif
        call GroupRemoveUnit(targetsWithinRadius, u)
    endloop
    call DestroyGroup(targetsWithinRadius)
    set owner=null
    set targetsWithinRadius=null
endfunction
function damageAoE takes unit source,real x,real y,real damage,real radius,damagetype dmgType returns nothing
    call damageAoEWithResult(source , x , y , damage , radius , dmgType , null)
endfunction

//BlzGetAbilityStringField takes ability whichAbility, abilitystringfield whichField returns string

//BlzSetAbilityRealLevelField takes ability whichAbility, abilityreallevelfield whichField, integer level, real value returns boolean
function OrderAbilWithSpeed takes unit u,integer abilityCode,real actionDuration,real animationSpeed,real tx,real ty returns nothing
    local ability ab= BlzGetUnitAbility(u, abilityCode)
    local string orderStr= BlzGetAbilityStringLevelField(ab, ABILITY_SLF_BASE_ORDER_ID_NCL6, 0)
    call BlzSetAbilityRealLevelField(ab, ABILITY_RLF_FOLLOW_THROUGH_TIME, 0, actionDuration)
    call SetUnitTimeScale(u, animationSpeed)
    call IssuePointOrder(u, orderStr, tx, ty)
    set ab=null
endfunction

//set udg_t_string1 = SubString("012345678", 0, 5) -> 01234
function hitDest takes destructable d,integer level returns boolean
    local string destName= GetDestructableName(d)
    local integer destLevel
    if strStartsWith(destName , "Dest") then
        set destLevel=S2I(SubString(destName, 4, 5))
        if level >= destLevel then
            call KillDestructable(d)
            
            return true
        endif
    endif
    return false
endfunction
function destroyEnumDest1 takes nothing returns nothing
    call hitDest(GetEnumDestructable() , 1)
endfunction
function destroyDest1 takes real x,real y,real radius returns nothing
    call SetRect(enumRect, x - radius, y - radius, x + radius, y + radius)
    call EnumDestructablesInRect(enumRect, null, function destroyEnumDest1)
endfunction
function destroyEnumDest2 takes nothing returns nothing
    call hitDest(GetEnumDestructable() , 2)
endfunction
function destroyDest2 takes real x,real y,real radius returns nothing
    call SetRect(enumRect, x - radius, y - radius, x + radius, y + radius)
    call EnumDestructablesInRect(enumRect, null, function destroyEnumDest2)
endfunction


//***************************************************************************
//*
//*  Sounds
//*
//***************************************************************************

function InitSounds takes nothing returns nothing
    set gg_snd_AbilityBombDetonate=CreateSound("Abilities\\Spells\\NightElf\\Blink\\BlinkArrival1.wav", false, true, true, 10, 10, "SpellsEAX")
    call SetSoundParamsFromLabel(gg_snd_AbilityBombDetonate, "BlinkTarget")
    call SetSoundDuration(gg_snd_AbilityBombDetonate, 1465)
    call SetSoundPitch(gg_snd_AbilityBombDetonate, 0.8)
    set gg_snd_MCL_Lightning1=CreateSound("Abilities\\Spells\\Human\\Feedback\\Feedback.wav", false, true, true, 10, 10, "SpellsEAX")
    call SetSoundParamsFromLabel(gg_snd_MCL_Lightning1, "Feedback")
    call SetSoundDuration(gg_snd_MCL_Lightning1, 1221)
    call SetSoundVolume(gg_snd_MCL_Lightning1, 75)
    call SetSoundPitch(gg_snd_MCL_Lightning1, 0.8)
    call SetSoundDistances(gg_snd_MCL_Lightning1, 600.0, 1800.0)
    call SetSoundDistanceCutoff(gg_snd_MCL_Lightning1, 1500.0)
endfunction

//***************************************************************************
//*
//*  Destructable Objects
//*
//***************************************************************************

function CreateAllDestructables takes nothing returns nothing
    local destructable d
    local trigger t
    local real life
    set gg_dest_B00Y_0263=CreateDestructable('B00Y', 800.0, - 1568.0, 270.000, 1.000, 0)
    set life=GetDestructableLife(gg_dest_B00Y_0263)
    call SetDestructableLife(gg_dest_B00Y_0263, 0.20 * life)
    set gg_dest_B015_0523=CreateDestructable('B015', 352.0, - 288.0, 270.000, 1.000, 0)
    set gg_dest_B015_0358=CreateDestructable('B015', 928.0, - 864.0, 0.000, 1.000, 0)
    set gg_dest_B015_0524=CreateDestructable('B015', 1888.0, - 288.0, 270.000, 1.000, 0)
    set gg_dest_B016_0393=CreateDeadDestructable('B016', 512.0, - 1600.0, 29.000, 1.000, 0)
    set gg_dest_B01B_0357=CreateDeadDestructable('B01B', 1088.0, - 992.0, 270.000, 1.000, 0)
    set gg_dest_B01B_0355=CreateDeadDestructable('B01B', 960.0, - 992.0, 90.000, 1.000, 0)
    set gg_dest_B01B_2886=CreateDestructable('B01B', 9664.0, 9376.0, 270.000, 1.000, 0)
    set life=GetDestructableLife(gg_dest_B01B_2886)
    call SetDestructableLife(gg_dest_B01B_2886, 0.33 * life)
    set gg_dest_B01B_3097=CreateDestructable('B01B', 8896.0, 8032.0, 270.000, 1.000, 0)
    set life=GetDestructableLife(gg_dest_B01B_3097)
    call SetDestructableLife(gg_dest_B01B_3097, 0.33 * life)
    set gg_dest_B01B_3096=CreateDestructable('B01B', 8768.0, 8032.0, 90.000, 1.000, 0)
    set life=GetDestructableLife(gg_dest_B01B_3096)
    call SetDestructableLife(gg_dest_B01B_3096, 0.33 * life)
    set gg_dest_B01B_2877=CreateDestructable('B01B', 10080.0, 8640.0, 0.000, 1.000, 0)
    set gg_dest_B01B_2875=CreateDestructable('B01B', 10080.0, 8512.0, 180.000, 1.000, 0)
    set gg_dest_B01B_3404=CreateDestructable('B01B', 9536.0, 9376.0, 90.000, 1.000, 0)
    set life=GetDestructableLife(gg_dest_B01B_3404)
    call SetDestructableLife(gg_dest_B01B_3404, 0.33 * life)
    set gg_dest_B020_3503=CreateDestructable('B020', 8832.0, 9376.0, 270.000, 1.000, 0)
    set gg_dest_B025_3152=CreateDestructable('B025', 9984.0, 7264.0, 180.000, 1.000, 0)
    set gg_dest_B025_1826=CreateDestructable('B025', 9984.0, 7584.0, 180.000, 1.000, 0)
endfunction

//***************************************************************************
//*
//*  Items
//*
//***************************************************************************

function CreateAllItems takes nothing returns nothing
    local integer itemID

    call CreateItem('I000', 9425.8, - 1983.5)
    call CreateItem('I001', 1322.4, - 1916.7)
    call CreateItem('I001', 8403.7, 7449.4)
    call CreateItem('I001', 9425.3, - 2083.6)
    call CreateItem('I001', 9425.6, - 1888.7)
    call CreateItem('I001', - 578.6, 967.2)
    call CreateItem('I001', 8054.5, - 1709.3)
    call CreateItem('I001', 8475.8, 7454.2)
    call CreateItem('I001', 9271.8, 7239.0)
    call CreateItem('I001', 10103.9, 9093.1)
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p= Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'hpea', - 10295.4, 10725.1, 149.755)
    set u=CreateUnit(p, 'hpea', - 10787.3, 10710.0, 139.357)
endfunction

//===========================================================================
function CreateUnitsForPlayer8 takes nothing returns nothing
    local player p= Player(8)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'n001', - 216.7, - 1299.4, 0.935)
    set u=CreateUnit(p, 'n001', - 462.9, - 1172.5, 0.935)
    set u=CreateUnit(p, 'n001', - 646.5, - 1354.6, 0.935)
    set u=CreateUnit(p, 'n001', - 179.0, - 1211.7, 0.935)
    set u=CreateUnit(p, 'n003', 3189.0, - 2760.2, 257.945)
    set u=CreateUnit(p, 'n001', 2718.6, - 2604.2, 265.807)
    set u=CreateUnit(p, 'n003', 2803.2, - 4409.4, 124.880)
    set u=CreateUnit(p, 'n001', - 233.7, - 1197.0, 0.935)
    set u=CreateUnit(p, 'n001', - 482.9, - 1327.9, 0.935)
    set u=CreateUnit(p, 'n001', - 309.4, - 1189.4, 0.935)
    set u=CreateUnit(p, 'n001', - 296.5, - 1268.6, 0.935)
    set u=CreateUnit(p, 'n001', - 180.6, - 1158.7, 0.935)
    set u=CreateUnit(p, 'n001', - 655.9, - 1071.5, 0.935)
    set u=CreateUnit(p, 'n001', - 323.4, - 1350.9, 0.935)
    set u=CreateUnit(p, 'n001', - 521.2, - 1098.0, 0.935)
    set u=CreateUnit(p, 'n001', - 569.6, - 1308.7, 0.935)
    set u=CreateUnit(p, 'n001', - 524.2, - 1212.9, 0.935)
    set u=CreateUnit(p, 'n001', - 655.1, - 1171.9, 0.935)
    set u=CreateUnit(p, 'n001', - 679.5, - 1282.0, 0.935)
    set u=CreateUnit(p, 'n001', - 443.6, - 1067.9, 0.935)
    set u=CreateUnit(p, 'n001', - 249.1, - 1371.0, 0.935)
    set u=CreateUnit(p, 'n003', 2562.7, - 1126.0, 107.570)
    set u=CreateUnit(p, 'n001', - 612.3, - 1251.4, 0.935)
    set u=CreateUnit(p, 'n001', 1452.1, - 4057.6, 265.810)
    set u=CreateUnit(p, 'n001', 1989.2, - 2806.9, 265.807)
    set u=CreateUnit(p, 'n003', 3601.1, - 4410.3, 89.790)
    set u=CreateUnit(p, 'n003', 2528.2, 671.5, 230.756)
    set u=CreateUnit(p, 'n003', 2901.5, 689.2, 191.434)
    set u=CreateUnit(p, 'n003', 3150.4, 430.3, 249.099)
    set u=CreateUnit(p, 'n003', 3661.4, - 1121.1, 107.570)
endfunction

//===========================================================================
function CreateUnitsForPlayer9 takes nothing returns nothing
    local player p= Player(9)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h001_0029=CreateUnit(p, 'h001', - 295.3, - 811.7, 44.842)
    set gg_unit_h001_0030=CreateUnit(p, 'h001', - 377.8, - 812.1, 35.948)
    set gg_unit_h001_0031=CreateUnit(p, 'h001', - 202.2, - 813.9, 38.530)
    set gg_unit_h001_0032=CreateUnit(p, 'h001', - 455.7, - 735.4, 24.761)
endfunction

//===========================================================================
function CreateUnitsForPlayer10 takes nothing returns nothing
    local player p= Player(10)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'n005', 5832.3, - 3843.5, 99.759)
    set u=CreateUnit(p, 'n005', 5329.6, - 2669.6, 21.635)
    set u=CreateUnit(p, 'n005', 5979.1, - 2129.5, 225.633)
    set u=CreateUnit(p, 'n005', 7592.8, - 3269.2, 161.218)
    set u=CreateUnit(p, 'n006', 4794.0, - 2697.5, 98.550)
    set u=CreateUnit(p, 'n006', 4341.1, - 2801.7, 98.550)
    set u=CreateUnit(p, 'n005', 5645.8, - 1499.4, 225.633)
    set u=CreateUnit(p, 'n006', 5099.5, - 1519.8, 98.550)
    set u=CreateUnit(p, 'n006', 6340.7, - 999.2, 98.550)
    set u=CreateUnit(p, 'n006', 7073.9, - 3668.2, 98.550)
    set u=CreateUnit(p, 'n006', 6653.8, - 3911.8, 98.550)
endfunction

//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'ncop', 6144.0, 960.0, 270.000)
    set u=CreateUnit(p, 'ncop', 8384.0, 7040.0, 270.000)
    set u=CreateUnit(p, 'ncop', 8832.0, 10816.0, 270.000)
endfunction

//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'n000', 4696.1, - 1380.9, 87.278)
    set u=CreateUnit(p, 'n000', 2468.0, 369.6, 87.278)
    set u=CreateUnit(p, 'n000', - 699.8, - 1054.5, 87.278)
    set u=CreateUnit(p, 'n000', 345.5, 61.0, 68.831)
    set u=CreateUnit(p, 'n000', 275.1, 67.6, 270.177)
    set u=CreateUnit(p, 'n000', 347.5, 212.2, 193.540)
    set u=CreateUnit(p, 'n000', 1315.9, - 2138.6, 87.278)
    set u=CreateUnit(p, 'n000', 3070.6, - 3427.3, 252.058)
    set u=CreateUnit(p, 'n000', 1649.1, - 4117.5, 252.058)
    set u=CreateUnit(p, 'n000', 1831.9, - 3365.5, 252.058)
    set u=CreateUnit(p, 'n000', 8570.2, 8788.2, 87.278)
    set u=CreateUnit(p, 'n000', 7905.2, 9952.9, 87.278)
    set u=CreateUnit(p, 'n000', 7935.8, 9861.0, 87.278)
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0()
    call CreateUnitsForPlayer8()
    call CreateUnitsForPlayer9()
    call CreateUnitsForPlayer10()
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings()
    call CreatePlayerBuildings()
    call CreateNeutralPassive()
    call CreatePlayerUnits()
endfunction

//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************

function CreateRegions takes nothing returns nothing
    local weathereffect we

    set gg_rct_InitialSpawn2=Rect(448.0, - 1280.0, 576.0, - 1152.0)
    set gg_rct_InitialSpawn1=Rect(448.0, - 1664.0, 576.0, - 1536.0)
    set gg_rct_InitialSpawn3=Rect(448.0, - 2048.0, 576.0, - 1920.0)
    set gg_rct_InitialSpawn4=Rect(448.0, - 1344.0, 576.0, - 1216.0)
    set gg_rct_InitialSpawn5=Rect(448.0, - 1984.0, 576.0, - 1856.0)
    set gg_rct_Intro_Zombie_Pos=Rect(- 352.0, - 384.0, - 288.0, - 320.0)
    set gg_rct_Intro_Zombie_Pos_2=Rect(- 160.0, - 608.0, - 64.0, - 512.0)
    set gg_rct_Intro_Zombie_Pos_Copy=Rect(- 288.0, - 480.0, - 192.0, - 384.0)
    set gg_rct_Intro_Zombie_Pos_Copy_2=Rect(0.0, - 352.0, 96.0, - 256.0)
    set gg_rct_Intro_Zombie_Pos_Copy_3=Rect(928.0, - 608.0, 992.0, - 544.0)
    set gg_rct_Intro_Zombie_Pos_Copy_4=Rect(992.0, - 544.0, 1056.0, - 480.0)
    set gg_rct_Intro_ZombiesGroup1=Rect(- 384.0, - 1408.0, - 128.0, - 1120.0)
    set gg_rct_Intro_Zombie_Pos_Copy_6=Rect(992.0, - 416.0, 1056.0, - 352.0)
    set gg_rct_Intro_Zombie_Pos_Copy_7=Rect(928.0, - 352.0, 992.0, - 288.0)
    set gg_rct_Intro_Zombie_Pos_Inside_Doors_1=Rect(896.0, - 1120.0, 992.0, - 1024.0)
    set gg_rct_Intro_Zombie_Pos_Copy_9=Rect(832.0, - 1088.0, 896.0, - 1024.0)
    set gg_rct_Intro_Zombie_Pos_Copy_11=Rect(- 224.0, - 544.0, - 128.0, - 448.0)
    set gg_rct_Intro_ZombiesGroup2=Rect(- 736.0, - 1408.0, - 384.0, - 1024.0)
    set gg_rct_Intro_Area=Rect(- 896.0, - 1504.0, 1472.0, - 64.0)
    set gg_rct_Into_Remaining_Zombies=Rect(896.0, - 928.0, 1152.0, - 256.0)
    set gg_rct_IceCaveBlock1_1=Rect(5600.0, - 2848.0, 5728.0, - 2720.0)
    set gg_rct_IceCaveBlock1_2=Rect(5504.0, - 2944.0, 5632.0, - 2816.0)
    set gg_rct_IceCaveBlock2_1=Rect(4672.0, - 2560.0, 4800.0, - 2432.0)
    set gg_rct_IceCaveBlock2_12=Rect(4800.0, - 2624.0, 4928.0, - 2496.0)
    set gg_rct_IceCaveBlockCave_1=Rect(4480.0, - 2752.0, 4608.0, - 2624.0)
    set gg_rct_IceCaveBlockCave_2=Rect(4160.0, - 3040.0, 4288.0, - 2912.0)
    set gg_rct_IceCaveBlock3_1=Rect(6272.0, - 3104.0, 6400.0, - 2976.0)
    set gg_rct_IceCaveBlock3_2=Rect(6080.0, - 3072.0, 6208.0, - 2944.0)
    set gg_rct_IceCaveBlock4=Rect(6368.0, - 2208.0, 6496.0, - 2080.0)
    set gg_rct_IceCaveBlock5_1=Rect(5824.0, - 2080.0, 5952.0, - 1952.0)
    set gg_rct_IceCaveBlock5_2=Rect(5792.0, - 2176.0, 5920.0, - 2048.0)
    set gg_rct_IceCaveBlock6_1=Rect(5120.0, - 2240.0, 5248.0, - 2112.0)
    set gg_rct_IceCaveBlock6_2=Rect(5056.0, - 2368.0, 5184.0, - 2240.0)
    set gg_rct_IceCaveBlock7_1=Rect(4800.0, - 3072.0, 4928.0, - 2944.0)
    set gg_rct_IceCaveBlock7_2=Rect(4896.0, - 3136.0, 5024.0, - 3008.0)
    set gg_rct_IceCaveBlock8_1=Rect(5504.0, - 3776.0, 5632.0, - 3648.0)
    set gg_rct_IceCaveBlock8_2=Rect(5568.0, - 3680.0, 5696.0, - 3552.0)
    set gg_rct_IceCaveBlockSecret_1=Rect(6208.0, - 1952.0, 6336.0, - 1824.0)
    set gg_rct_IceCaveBlockSecret_2=Rect(7232.0, - 3168.0, 7360.0, - 3040.0)
    set gg_rct_IceCaveBlock9_1=Rect(6208.0, - 3712.0, 6336.0, - 3584.0)
    set gg_rct_IceCaveBlock9_2=Rect(6336.0, - 3680.0, 6464.0, - 3552.0)
    set gg_rct_IceCaveBlock10=Rect(7168.0, - 4000.0, 7296.0, - 3872.0)
    set gg_rct_IceCaveBlock11=Rect(7104.0, - 3680.0, 7232.0, - 3552.0)
    set gg_rct_IceCaveBlock12=Rect(7008.0, - 3264.0, 7136.0, - 3136.0)
    set gg_rct_IceCaveBlock13=Rect(6592.0, - 3264.0, 6720.0, - 3136.0)
    set gg_rct_IceCaveBlock15_1=Rect(6720.0, - 3072.0, 6848.0, - 2944.0)
    set gg_rct_IceCaveBlock15_2=Rect(6848.0, - 3040.0, 6976.0, - 2912.0)
    set gg_rct_IceCaveBlock4_Alt=Rect(6560.0, - 2624.0, 6688.0, - 2496.0)
    set gg_rct_IceCaveBlock14=Rect(5536.0, - 3424.0, 5664.0, - 3296.0)
    set gg_rct_IceCaveBlock16_1=Rect(4352.0, - 3264.0, 4480.0, - 3136.0)
    set gg_rct_IceCaveBlock16_2=Rect(4448.0, - 3168.0, 4576.0, - 3040.0)
    set gg_rct_IceCaveBlock17_1=Rect(7296.0, - 3648.0, 7424.0, - 3520.0)
    set gg_rct_IceCaveBlock17_2=Rect(7424.0, - 3712.0, 7552.0, - 3584.0)
    set gg_rct_IceCaveBlock17_3=Rect(7520.0, - 3776.0, 7648.0, - 3648.0)
    set gg_rct_IceCaveBlockSecret_1_reward=Rect(6464.0, - 1664.0, 6528.0, - 1600.0)
    set gg_rct_IceCaveBlockSecret_2_reward=Rect(7392.0, - 2976.0, 7456.0, - 2912.0)
    set gg_rct_IceCaveBlockDebris_1=Rect(3840.0, - 3456.0, 3968.0, - 3328.0)
    set gg_rct_IceCaveBlockDebris_2=Rect(4544.0, - 2112.0, 4672.0, - 1984.0)
    set gg_rct_IceCaveBlockDebris_3=Rect(4416.0, - 2176.0, 4544.0, - 2048.0)
    set gg_rct_IceCaveBlockDebris_4=Rect(5632.0, - 1760.0, 5760.0, - 1632.0)
    set gg_rct_IceCaveBlockDebris_5=Rect(5536.0, - 1888.0, 5664.0, - 1760.0)
    set gg_rct_ExitingSpawnArea=Rect(800.0, - 1760.0, 1088.0, - 1376.0)
    set gg_rct_OpenDoorHint=Rect(1376.0, - 2176.0, 1760.0, - 1952.0)
    set gg_rct_IceCaves=Rect(3840.0, - 4160.0, 7552.0, - 1408.0)
    set gg_rct_ZombieSpawningArea=Rect(- 864.0, - 4608.0, 3712.0, 256.0)
    set gg_rct_ZombiePatrolP1=Rect(1408.0, - 3968.0, 1536.0, - 3840.0)
    set gg_rct_ZombiePatrolP2=Rect(4736.0, - 1600.0, 4864.0, - 1472.0)
    set gg_rct_ZombiePatrolP3=Rect(- 320.0, - 1376.0, - 192.0, - 1248.0)
    set gg_rct_ZombiePatrolP4=Rect(2560.0, 480.0, 2688.0, 608.0)
    set gg_rct_SA_Battery1=Rect(4416.0, - 4448.0, 4480.0, - 4384.0)
    set gg_rct_SA_Battery2=Rect(2880.0, - 2624.0, 2944.0, - 2560.0)
    set gg_rct_SA_Battery3=Rect(1152.0, - 4480.0, 1216.0, - 4416.0)
    set gg_rct_SA_Battery4=Rect(- 832.0, - 1120.0, - 768.0, - 1056.0)
    set gg_rct_SA_Battery5=Rect(1120.0, - 3232.0, 1184.0, - 3168.0)
    set gg_rct_IceCaveBlock14_2=Rect(5440.0, - 3424.0, 5568.0, - 3296.0)
    set gg_rct_Brood_Mother_Spawn=Rect(8320.0, - 2048.0, 8448.0, - 1920.0)
    set gg_rct_Brood_Mother_Arena=Rect(7040.0, - 2688.0, 8608.0, - 1344.0)
    set gg_rct_Brood_Mother_Entrence_Block1=Rect(7040.0, - 2624.0, 7168.0, - 2496.0)
    set gg_rct_Brood_Mother_Entrence_Block2=Rect(6976.0, - 2720.0, 7104.0, - 2592.0)
    set gg_rct_Brood_Mother_Reward_Block=Rect(8480.0, - 2176.0, 8768.0, - 1760.0)
    set gg_rct_Brood_Mother_Reward=Rect(9280.0, - 2176.0, 9728.0, - 1792.0)
    set gg_rct_Brood_Mother_North_Doors=Rect(7552.0, - 1376.0, 7808.0, - 1248.0)
    set gg_rct_Brood_Mother_StartBattle=Rect(7552.0, - 2688.0, 7936.0, - 1408.0)
    set gg_rct_Brood_Mother_TP_Others=Rect(7200.0, - 2528.0, 7424.0, - 2304.0)
    set gg_rct_IceCavesPatrol1=Rect(6784.0, - 2816.0, 6912.0, - 2688.0)
    set gg_rct_IceCavesPatrol2=Rect(4096.0, - 1792.0, 4224.0, - 1664.0)
    set gg_rct_IceCavesPatrol3=Rect(5248.0, - 2816.0, 5376.0, - 2688.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc1=Rect(7328.0, - 1536.0, 7392.0, - 1472.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc2=Rect(7360.0, - 2656.0, 7456.0, - 2560.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc3=Rect(8032.0, - 2624.0, 8096.0, - 2560.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc4=Rect(8192.0, - 1696.0, 8256.0, - 1632.0)
    set gg_rct_Brood_Mother_Entrence_NorthSpawn=Rect(8320.0, - 512.0, 8448.0, - 384.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc5=Rect(8384.0, - 2176.0, 8448.0, - 2112.0)
    set gg_rct_Brood_Mother_Entrence_EggLoc6=Rect(7104.0, - 1920.0, 7168.0, - 1856.0)
    set gg_rct_IceCaveBlockSecret_3_reward=Rect(6240.0, - 2880.0, 6304.0, - 2816.0)
    set gg_rct_IceCaveBlockSecret_4_reward=Rect(5216.0, - 4000.0, 5280.0, - 3936.0)
    set gg_rct_IceCaveBlockSecret_4=Rect(4928.0, - 3808.0, 5056.0, - 3680.0)
    set gg_rct_IceCaveBlockSecret_5_reward=Rect(7392.0, - 4288.0, 7456.0, - 4224.0)
    set gg_rct_IceCaveBlockSecret_5=Rect(7104.0, - 4256.0, 7232.0, - 4128.0)
    set gg_rct_IceCaveBlockDebris_1_2=Rect(3936.0, - 3552.0, 4064.0, - 3424.0)
    set gg_rct_IceCaveBlock18_1=Rect(5248.0, - 2944.0, 5376.0, - 2816.0)
    set gg_rct_IceCaveBlock18_2=Rect(5120.0, - 2880.0, 5248.0, - 2752.0)
    set gg_rct_IceCaveBlock18_3=Rect(5024.0, - 2784.0, 5152.0, - 2656.0)
    set gg_rct_IceCaveBlock4_Alt_2=Rect(5824.0, - 2752.0, 5952.0, - 2624.0)
    set gg_rct_IceCaveBlockSecret_6_reward=Rect(5824.0, - 2496.0, 5888.0, - 2432.0)
    set gg_rct_IceCaveBlockSecret_7_reward=Rect(6528.0, - 3712.0, 6592.0, - 3648.0)
    set gg_rct_IceCaveBlockSecret_8_reward=Rect(4288.0, - 2816.0, 4352.0, - 2752.0)
    set gg_rct_IceCaveBlockSecret_9_reward=Rect(6592.0, - 3360.0, 6656.0, - 3296.0)
    set gg_rct_IceCaveBlockSecret_11_reward=Rect(4544.0, - 3232.0, 4608.0, - 3168.0)
    set gg_rct_IceCaveBlockSecret_12_reward=Rect(4992.0, - 2304.0, 5056.0, - 2240.0)
    set gg_rct_IceCaveBlockSecret_13_reward=Rect(5760.0, - 2048.0, 5824.0, - 1984.0)
    set gg_rct_IceCaveBlockSecret_14_reward=Rect(7296.0, - 3808.0, 7360.0, - 3744.0)
    set gg_rct_IceCaveBlockSecret_15_reward=Rect(7520.0, - 3584.0, 7584.0, - 3520.0)
    set gg_rct_IceCaveBlockSecret_16_reward=Rect(6400.0, - 2432.0, 6464.0, - 2368.0)
    set gg_rct_IceCaveBlockSecret_17_reward=Rect(6944.0, - 3328.0, 7008.0, - 3264.0)
    set gg_rct_IceCaveBlock19_1=Rect(5280.0, - 3616.0, 5408.0, - 3488.0)
    set gg_rct_IceCaveBlock19_2=Rect(5312.0, - 3488.0, 5440.0, - 3360.0)
    set gg_rct_IceCaveBlockSecret_19_reward=Rect(5248.0, - 3488.0, 5312.0, - 3424.0)
    set gg_rct_IceCaveBlockSecret_20_reward=Rect(4096.0, - 3136.0, 4160.0, - 3072.0)
    set gg_rct_IceCaveBlockSecret_21_reward=Rect(4448.0, - 2336.0, 4512.0, - 2272.0)
    set gg_rct_IceCaveBlockSecret_10_reward=Rect(5056.0, - 2944.0, 5120.0, - 2880.0)
    set gg_rct_IceCaveBlockSecret_22_reward=Rect(5440.0, - 3296.0, 5536.0, - 3232.0)
    set gg_rct_IceCaveBlock20_1=Rect(5184.0, - 2592.0, 5312.0, - 2464.0)
    set gg_rct_IceCaveBlock20_2=Rect(5312.0, - 2592.0, 5440.0, - 2464.0)
    set gg_rct_IceCaveBlock21_1=Rect(4768.0, - 2880.0, 4896.0, - 2752.0)
    set gg_rct_IceCaveBlock21_2=Rect(4864.0, - 2784.0, 4992.0, - 2656.0)
    set gg_rct_IceCaveBlockSecret_23_reward=Rect(5408.0, - 2880.0, 5472.0, - 2816.0)
    set gg_rct_ExplodeStuffHint=Rect(6816.0, - 1152.0, 7392.0, - 896.0)
    set gg_rct_Victory_Area=Rect(8640.0, 10592.0, 9024.0, 10912.0)
    set gg_rct_FinalBoss_TP=Rect(8288.0, 6944.0, 8480.0, 7136.0)
    set gg_rct_FinalBoss_Spawn=Rect(8736.0, 9888.0, 8928.0, 10080.0)
    set gg_rct_FinalBoss_ConveyorZap1_1=Rect(10496.0, 8832.0, 10624.0, 8960.0)
    set gg_rct_FinalBoss_ConveyorZap2_1=Rect(10496.0, 9280.0, 10624.0, 9408.0)
    set gg_rct_FinalBoss_GeneratorArea=Rect(9216.0, 7168.0, 9984.0, 8064.0)
    set gg_rct_FinalBoss_Conveyor_Enterence=Rect(10432.0, 8640.0, 10688.0, 8832.0)
    set gg_rct_FinalBoss_Main_Arena=Rect(7680.0, 8064.0, 9984.0, 9120.0)
    set gg_rct_FinalBoss_CloseToEnter=Rect(8704.0, 7840.0, 8960.0, 7968.0)
    set gg_rct_FinalBoss_Enterence=Rect(8704.0, 8128.0, 8960.0, 8256.0)
    set gg_rct_FinalBoss_WalkStart=Rect(8704.0, 9216.0, 8960.0, 9312.0)
    set gg_rct_FinalBoss_Full_Arena=Rect(6432.0, 7104.0, 11104.0, 10272.0)
    set gg_rct_FinalBoss_Conveyor_Lower_Spawn=Rect(11136.0, 8672.0, 11264.0, 8736.0)
    set gg_rct_FinalBoss_Conveyor_Upper_Spawn=Rect(10720.0, 7936.0, 10784.0, 8064.0)
    set gg_rct_FinalBoss_Conveyor_Lower_End=Rect(11264.0, 7936.0, 11328.0, 8064.0)
    set gg_rct_FinalBoss_Conveyor_Upper_End=Rect(10112.0, 10112.0, 10240.0, 10176.0)
    set gg_rct_FinalBoss_Conveyor_Lower_Downwards_1=Rect(11136.0, 8512.0, 11264.0, 8704.0)
    set gg_rct_FinalBoss_Conveyor_Lower_Downwards_2=Rect(11392.0, 8000.0, 11520.0, 8576.0)
    set gg_rct_FinalBoss_Conveyor_Lower_Right_1=Rect(11136.0, 8448.0, 11488.0, 8576.0)
    set gg_rct_FinalBoss_Conveyor_Lower_Left_1=Rect(11264.0, 7936.0, 11520.0, 8064.0)
    set gg_rct_FinalBoss_Conveyor_Upper_Left_1=Rect(10560.0, 7936.0, 10784.0, 8064.0)
    set gg_rct_FinalBoss_Conveyor_Upper_Left_2=Rect(10176.0, 9472.0, 10624.0, 9600.0)
    set gg_rct_FinalBoss_Conveyor_Upper_Upwards_1=Rect(10496.0, 7936.0, 10624.0, 9536.0)
    set gg_rct_FinalBoss_Conveyor_Upper_Upwards_2=Rect(10112.0, 9472.0, 10240.0, 10080.0)
    set gg_rct_FinalBoss_GreenCrystal_L=Rect(8000.0, 9920.0, 8128.0, 10048.0)
    set gg_rct_FinalBoss_GreenCrystal_R=Rect(9536.0, 9920.0, 9664.0, 10048.0)
    set gg_rct_FinalBoss_Transmitter_L=Rect(8192.0, 8576.0, 8320.0, 8704.0)
    set gg_rct_FinalBoss_Transmitter_R=Rect(9344.0, 8576.0, 9472.0, 8704.0)
    set gg_rct_FinalBoss_SpawnPoint=Rect(9216.0, 7168.0, 9344.0, 7296.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy=Rect(9856.0, 7360.0, 9984.0, 7488.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_2=Rect(9856.0, 8064.0, 9984.0, 8192.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_3=Rect(9984.0, 9024.0, 10112.0, 9152.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_4=Rect(7680.0, 8064.0, 7808.0, 8192.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_5=Rect(7680.0, 9216.0, 7808.0, 9344.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_6=Rect(9920.0, 9952.0, 10048.0, 10080.0)
    set gg_rct_FinalBoss_SpawnPoint__Copy_7=Rect(10496.0, 7680.0, 10624.0, 7808.0)
    set gg_rct_FinalBoss_Conveyor_Corridor=Rect(10368.0, 8832.0, 10656.0, 9472.0)
    set gg_rct_Ehhm_TP=Rect(6048.0, 864.0, 6240.0, 1024.0)
    set gg_rct_FinalBoss_Vents=Rect(9440.0, 7168.0, 9984.0, 7648.0)
    set gg_rct_Intro_Zombie_Pos_Inside_Doors_2=Rect(992.0, - 1312.0, 1056.0, - 1248.0)
    set gg_rct_FinalBoss_Door=Rect(8768.0, 9344.0, 8896.0, 9408.0)
    set gg_rct_StartRoom_UtilityRoom=Rect(1280.0, - 2176.0, 1728.0, - 1792.0)
endfunction

//***************************************************************************
//*
//*  Cameras
//*
//***************************************************************************

function CreateCameras takes nothing returns nothing

    set gg_cam_IntroCamera1=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_ROTATION, 205.2, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_ANGLE_OF_ATTACK, 337.4, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_TARGET_DISTANCE, 634.4, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera1, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera1, - 86.2, - 548.8, 0.0)

    set gg_cam_IntroCamera2=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_ROTATION, 192.8, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_ANGLE_OF_ATTACK, 340.8, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_TARGET_DISTANCE, 576.7, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera2, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera2, 857.4, - 579.4, 0.0)

    set gg_cam_IntroCamera3=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_ROTATION, 235.7, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_ANGLE_OF_ATTACK, 310.1, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_TARGET_DISTANCE, 476.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera3, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera3, 904.9, - 530.3, 0.0)

    set gg_cam_IntroCamera4=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_ROTATION, 225.1, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_ANGLE_OF_ATTACK, 336.2, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_TARGET_DISTANCE, 325.5, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera4, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera4, 815.0, - 1242.7, 0.0)

    set gg_cam_IntroCamera5=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_ROTATION, 116.8, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_ANGLE_OF_ATTACK, 336.7, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_TARGET_DISTANCE, 358.1, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera5, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera5, 820.2, - 1292.8, 0.0)

    set gg_cam_IntroCamera6=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_ROTATION, 178.9, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_ANGLE_OF_ATTACK, 307.3, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_TARGET_DISTANCE, 844.4, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_FARZ, 9743.6, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_IntroCamera6, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_IntroCamera6, 723.3, - 1540.2, 0.0)

    set gg_cam_Victory1=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_ROTATION, 21.6, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_ANGLE_OF_ATTACK, 310.7, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_TARGET_DISTANCE, 769.7, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_FARZ, 8857.8, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory1, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_Victory1, 8825.5, 10815.2, 0.0)

    set gg_cam_Victory2=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_ROTATION, 129.6, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_ANGLE_OF_ATTACK, 310.9, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_TARGET_DISTANCE, 636.1, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_FARZ, 8857.8, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_Victory2, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_Victory2, 8828.1, 10812.3, 0.0)

    set gg_cam_FinalBoss_Spawn1=CreateCameraSetup()
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_ZOFFSET, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_ROTATION, 49.6, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_ANGLE_OF_ATTACK, 315.1, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_TARGET_DISTANCE, 833.2, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_ROLL, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_FIELD_OF_VIEW, 70.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_FARZ, 10000.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_NEARZ, 16.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_LOCAL_PITCH, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_LOCAL_YAW, 0.0, 0.0)
    call CameraSetupSetField(gg_cam_FinalBoss_Spawn1, CAMERA_FIELD_LOCAL_ROLL, 0.0, 0.0)
    call CameraSetupSetDestPosition(gg_cam_FinalBoss_Spawn1, 8837.9, 9856.8, 0.0)

endfunction

//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: Table
//===========================================================================
//===========================================================================
// Trigger: SpellEffectEvent
//===========================================================================
//============================================================================
// SpellEffectEvent
// - Version 1.1.0.0
//
// API
// ---
//     RegisterSpellEffectEvent(integer abil, code onCast)
//
// Requires
// --------
//     RegisterPlayerUnitEvent: hiveworkshop.com/forums/showthread.php?t=203338
//
// Optional
// --------
//     Table: hiveworkshop.com/forums/showthread.php?t=188084
//

//===========================================================================
// Trigger: RegisterPlayerUnitEvent
//===========================================================================
//TESH.scrollpos=28
//TESH.alwaysfold=0


//===========================================================================
// Trigger: TimerUtils
//===========================================================================
//TESH.scrollpos=21
//TESH.alwaysfold=0

//===========================================================================
// Trigger: Dummy Recycler
//===========================================================================


//===========================================================================
// Trigger: WorldBounds
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0

//===========================================================================
// Trigger: Alloc
//===========================================================================
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ Alloc ~~ By Sevion ~~ Version 1.09 ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Alloc?
//         - Alloc implements an intuitive allocation method for array structs
//
//    =Pros=
//         - Efficient.
//         - Simple.
//         - Less overhead than regular structs.
//
//    =Cons=
//         - Must use array structs (hardly a con).
//         - Must manually call OnDestroy.
//         - Must use Delegates for inheritance.
//         - No default values for variables (use onInit instead).
//         - No array members (use another Alloc struct as a linked list or type declaration).
//
//    Methods:
//         - struct.allocate()
//         - struct.deallocate()
//
//           These methods are used just as they should be used in regular structs.
//
//    Modules:
//         - Alloc
//           Implements the most basic form of Alloc. Includes only create and destroy
//           methods.
//
//  Details:
//         - Less overhead than regular structs
//
//         - Use array structs when using Alloc. Put the implement at the top of the struct.
//
//         - Alloc operates almost exactly the same as default structs in debug mode with the exception of onDestroy.
//
//  How to import:
//         - Create a trigger named Alloc.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Nestharus for the method of allocation and suggestions on further merging.
//         - Bribe for suggestions like the static if and method names.
//         - PurgeandFire111 for some suggestions like the merging of Alloc and AllocX as well as OnDestroy stuff.
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//===========================================================================
// Trigger: LineSegmentEnumeration
//===========================================================================

//===========================================================================
// Trigger: MouseUtils
//===========================================================================
//===========================================================================
// Trigger: UnitEvent
//===========================================================================
//===========================================================================
function UnitEventDestroyGroup takes integer i returns nothing
    if udg_CargoTransportGroup[i] != null then
        call DestroyGroup(udg_CargoTransportGroup[i])
        set udg_CargoTransportGroup[i]=null
    endif
endfunction
function UnitEventCheckAfter takes nothing returns nothing
    local integer i= 0
    loop
        set i=udg_CheckDeathList[i]
        exitwhen i == 0
        set udg_UDex=i
        if udg_IsUnitNew[i] then
            //The unit was just created.
            set udg_IsUnitNew[i]=false
            set udg_UnitIndexEvent=1.50 //New event requested by SpellBound to detect when unit fully enters scope.
            set udg_UnitIndexEvent=0.00
        elseif udg_IsUnitTransforming[i] then
           //Added 21 July 2017 to fix the issue re-adding this ability in the same instant
           set udg_UnitTypeEvent=0.00
           set udg_UnitTypeEvent=1.00
           set udg_UnitTypeOf[i]=GetUnitTypeId(udg_UDexUnits[i]) //Set this afterward to give the user extra reference
           set udg_IsUnitTransforming[i]=false
           call UnitAddAbility(udg_UDexUnits[i], udg_DetectTransformAbility)
        elseif udg_IsUnitAlive[i] then
            //The unit has started reincarnating.
            set udg_IsUnitReincarnating[i]=true
            set udg_IsUnitAlive[i]=false
            set udg_DeathEvent=0.50
            set udg_DeathEvent=0.00
        endif
        set udg_CheckDeathInList[i]=false
    endloop
    //Empty the list
    set udg_CheckDeathList[0]=0
endfunction
function UnitEventCheckAfterProxy takes integer i returns nothing
    if udg_CheckDeathList[0] == 0 then
        call TimerStart(udg_CheckDeathTimer, 0.00, false, function UnitEventCheckAfter)
    endif
    if not udg_CheckDeathInList[i] then
        set udg_CheckDeathList[i]=udg_CheckDeathList[0]
        set udg_CheckDeathList[0]=i
        set udg_CheckDeathInList[i]=true
    endif
endfunction

function UnitEventOnUnload takes nothing returns nothing
    local integer i= udg_UDex
    call GroupRemoveUnit(udg_CargoTransportGroup[GetUnitUserData(udg_CargoTransportUnit[i])], udg_UDexUnits[i])
    set udg_IsUnitBeingUnloaded[i]=true
    set udg_CargoEvent=0.00
    set udg_CargoEvent=2.00
    set udg_CargoEvent=0.00
    set udg_IsUnitBeingUnloaded[i]=false
    if not IsUnitLoaded(udg_UDexUnits[i]) or IsUnitType(udg_CargoTransportUnit[i], UNIT_TYPE_DEAD) or GetUnitTypeId(udg_CargoTransportUnit[i]) == 0 then
        set udg_CargoTransportUnit[i]=null
    endif
endfunction

function UnitEventOnDeath takes nothing returns boolean
    local integer pdex= udg_UDex
    set udg_UDex=GetUnitUserData(GetTriggerUnit())
    if udg_UDex != 0 then
        set udg_KillerOfUnit[udg_UDex]=GetKillingUnit() //Added 29 May 2017 for GIMLI_2 
        set udg_IsUnitAlive[udg_UDex]=false
        set udg_DeathEvent=0.00
        set udg_DeathEvent=1.00
        set udg_DeathEvent=0.00
        set udg_KillerOfUnit[udg_UDex]=null
        if udg_CargoTransportUnit[udg_UDex] != null then
            call UnitEventOnUnload()
        endif
    endif
    set udg_UDex=pdex
    return false
endfunction
  
function UnitEventOnOrder takes nothing returns boolean
    local integer pdex= udg_UDex
    local unit u= GetFilterUnit()
    local integer i= GetUnitUserData(u)
    if i > 0 then
        set udg_UDex=i
        if GetUnitAbilityLevel(u, udg_DetectRemoveAbility) == 0 then
            if not udg_IsUnitRemoved[i] then
                set udg_IsUnitRemoved[i]=true
                set udg_IsUnitAlive[i]=false
                set udg_SummonerOfUnit[i]=null
                
                //For backwards-compatibility:
                set udg_DeathEvent=0.00
                set udg_DeathEvent=3.00
                set udg_DeathEvent=0.00
                
                //Fire deindex event for UDex:
                set udg_UnitIndexEvent=0.00
                set udg_UnitIndexEvent=2.00
                set udg_UnitIndexEvent=0.00
                
                set udg_UDexNext[udg_UDexPrev[i]]=udg_UDexNext[i]
                set udg_UDexPrev[udg_UDexNext[i]]=udg_UDexPrev[i]
                
                // Recycle the index for later use
                set udg_UDexUnits[i]=null
                set udg_UDexPrev[i]=udg_UDexLastRecycled
                set udg_UDexLastRecycled=i
                call UnitEventDestroyGroup(i)
            endif
        elseif not udg_IsUnitAlive[i] then
            if not IsUnitType(u, UNIT_TYPE_DEAD) then
                set udg_IsUnitAlive[i]=true
                set udg_DeathEvent=0.00
                set udg_DeathEvent=2.00
                set udg_DeathEvent=0.00
                set udg_IsUnitReincarnating[i]=false
            endif
        elseif IsUnitType(u, UNIT_TYPE_DEAD) then
            if udg_IsUnitNew[i] then
                //This unit was created as a corpse.
                set udg_IsUnitAlive[i]=false
                set udg_DeathEvent=0.00
                set udg_DeathEvent=1.00
                set udg_DeathEvent=0.00
            elseif udg_CargoTransportUnit[i] == null or not IsUnitType(u, UNIT_TYPE_HERO) then
                //The unit may have just started reincarnating.
                call UnitEventCheckAfterProxy(i)
            endif
        elseif GetUnitAbilityLevel(u, udg_DetectTransformAbility) == 0 and not udg_IsUnitTransforming[i] then
            set udg_IsUnitTransforming[i]=true
            call UnitEventCheckAfterProxy(i) //This block has been updated on 21 July 2017
        endif
        if udg_CargoTransportUnit[i] != null and not udg_IsUnitBeingUnloaded[i] and not IsUnitLoaded(u) or IsUnitType(u, UNIT_TYPE_DEAD) then
            call UnitEventOnUnload()
        endif
        set udg_UDex=pdex
    endif
    set u=null
    return false
endfunction
function UnitEventOnSummon takes nothing returns boolean
    local integer pdex= udg_UDex
    set udg_UDex=GetUnitUserData(GetTriggerUnit())
    if udg_IsUnitNew[udg_UDex] then
        set udg_SummonerOfUnit[udg_UDex]=GetSummoningUnit()
        set udg_UnitIndexEvent=0.00
        set udg_UnitIndexEvent=0.50
        set udg_UnitIndexEvent=0.00
    endif
    set udg_UDex=pdex
    return false
endfunction
function UnitEventOnLoad takes nothing returns boolean
    local integer pdex= udg_UDex
    local integer i= GetUnitUserData(GetTriggerUnit())
    local integer index
    if i != 0 then
        set udg_UDex=i
        if udg_CargoTransportUnit[i] != null then
            call UnitEventOnUnload()
        endif
        //Loaded corpses do not issue an order when unloaded, therefore must
        //use the enter-region event method taken from Jesus4Lyf's Transport.
        if not udg_IsUnitAlive[i] then
            call SetUnitX(udg_UDexUnits[i], udg_WorldMaxX)
            call SetUnitY(udg_UDexUnits[i], udg_WorldMaxY)
        endif
        
        set udg_CargoTransportUnit[i]=GetTransportUnit()
        set index=GetUnitUserData(udg_CargoTransportUnit[i])
        if udg_CargoTransportGroup[index] == null then
            set udg_CargoTransportGroup[index]=CreateGroup()
        endif
        call GroupAddUnit(udg_CargoTransportGroup[index], udg_UDexUnits[i])
        set udg_CargoEvent=0.00
        set udg_CargoEvent=1.00
        set udg_CargoEvent=0.00
        set udg_UDex=pdex
    endif
    return false
endfunction
function UnitEventEnter takes nothing returns boolean
    local integer pdex= udg_UDex
    local integer i= udg_UDexLastRecycled
    local unit u= GetFilterUnit()
    if udg_UnitIndexerEnabled and GetUnitAbilityLevel(u, udg_DetectRemoveAbility) == 0 then
        //Generate a unique integer index for this unit
        if i == 0 then
            set i=udg_UDexMax + 1
            set udg_UDexMax=i
        else
            set udg_UDexLastRecycled=udg_UDexPrev[i]
        endif
        //Link index to unit, unit to index
        set udg_UDexUnits[i]=u
        call SetUnitUserData(u, i)
        
        //For backwards-compatibility, add the unit to a linked list
        set udg_UDexNext[i]=udg_UDexNext[0]
        set udg_UDexPrev[udg_UDexNext[0]]=i
        set udg_UDexNext[0]=i
        set udg_UDexPrev[i]=0

        set udg_CheckDeathInList[i]=false

        call UnitAddAbility(u, udg_DetectRemoveAbility)
        call UnitMakeAbilityPermanent(u, true, udg_DetectRemoveAbility)
        call UnitAddAbility(u, udg_DetectTransformAbility)
        set udg_UnitTypeOf[i]=GetUnitTypeId(u)
        set udg_IsUnitNew[i]=true
        set udg_IsUnitAlive[i]=true
        set udg_IsUnitRemoved[i]=false
        set udg_IsUnitReincarnating[i]=false
        set udg_IsUnitPreplaced[i]=udg_IsUnitPreplaced[0] //Added 29 May 2017 for Spellbound
        call UnitEventCheckAfterProxy(i)
        
        //Fire index event for UDex
        set udg_UDex=i
        set udg_UnitIndexEvent=0.00
        set udg_UnitIndexEvent=1.00
        set udg_UnitIndexEvent=0.00
    else
        set udg_UDex=GetUnitUserData(u)
        if udg_CargoTransportUnit[udg_UDex] != null and not IsUnitLoaded(u) then
            //The unit was dead, but has re-entered the map.
            call UnitEventOnUnload()
        endif
    endif
    set udg_UDex=pdex
    set u=null
    return false
endfunction
//===========================================================================
function UnitEventInit takes nothing returns nothing
    local integer i= bj_MAX_PLAYER_SLOTS
    local player p
    local trigger t= CreateTrigger()
    local trigger load= CreateTrigger()
    local trigger death= CreateTrigger()
    local trigger summon= CreateTrigger()
    local rect r= GetWorldBounds()
    local region re= CreateRegion()
    local boolexpr enterB= Filter(function UnitEventEnter)
    local boolexpr orderB= Filter(function UnitEventOnOrder)
    set udg_WorldMaxX=GetRectMaxX(r)
    set udg_WorldMaxY=GetRectMaxY(r)
    call RegionAddRect(re, r)
    call RemoveRect(r)
    call UnitEventDestroyGroup(0)
    call UnitEventDestroyGroup(1)
    
    set udg_CheckDeathList[0]=0
    set udg_UnitIndexerEnabled=true
    call TriggerRegisterEnterRegion(CreateTrigger(), re, enterB)
    call TriggerAddCondition(load, Filter(function UnitEventOnLoad))
    call TriggerAddCondition(death, Filter(function UnitEventOnDeath))
    call TriggerAddCondition(summon, Filter(function UnitEventOnSummon))
    loop
        set i=i - 1
        set p=Player(i)
        call SetPlayerAbilityAvailable(p, udg_DetectRemoveAbility, false)
        call SetPlayerAbilityAvailable(p, udg_DetectTransformAbility, false)
        call TriggerRegisterPlayerUnitEvent(summon, p, EVENT_PLAYER_UNIT_SUMMON, null)
        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_ISSUED_ORDER, orderB)
        call TriggerRegisterPlayerUnitEvent(death, p, EVENT_PLAYER_UNIT_DEATH, null)
        call TriggerRegisterPlayerUnitEvent(load, p, EVENT_PLAYER_UNIT_LOADED, null)
        call GroupEnumUnitsOfPlayer(bj_lastCreatedGroup, p, enterB)
        exitwhen i == 0
    endloop
    set summon=null
    set death=null
    set load=null
    set re=null
    set enterB=null
    set orderB=null
    set p=null
    set r=null
    set t=null
endfunction
function InitTrig_Unit_Event takes nothing returns nothing
endfunction

//===========================================================================
// Trigger: UnitEventConfig
//===========================================================================
function Trig_UnitEventConfig_Actions takes nothing returns nothing
    set udg_DetectRemoveAbility='A001'
    set udg_DetectTransformAbility='A000'
    set udg_UnitIndexEvent=- 1.00
    set udg_IsUnitPreplaced[0]=true
    call ExecuteFunc("UnitEventInit")
    set udg_UnitIndexEvent=3.00
    set udg_IsUnitPreplaced[0]=udg_IsUnitTransforming[0]
endfunction

//===========================================================================
function InitTrig_UnitEventConfig takes nothing returns nothing
    set gg_trg_UnitEventConfig=CreateTrigger()
    call TriggerAddAction(gg_trg_UnitEventConfig, function Trig_UnitEventConfig_Actions)
endfunction

//===========================================================================
// Trigger: NewBonusUtils
//
// https://www.hiveworkshop.com/threads/new-bonus-vjass-lua.324058/
//===========================================================================
//===========================================================================
// Trigger: Knockback 2D Config
//
// Knockback 2D version 4.2.3.1
// Flying units now display special effect art attached to their "origin". Simplified the pathing check for flying units to only check for air unit pathability.
// For the full list of changes, please review the Knockback 2D Spell resource on HiveWorkshop.com
//===========================================================================
function Trig_Knockback_2D_Config_Actions takes nothing returns nothing
    //  
    // Configure things below
    //  
    // Set the timeout to be used throughout the system
    //  
    set udg_K2DTimeout=( 1.00 / 60.00 )
    //  
    // Robust Pathing at 0 is only safe for collision sizes 16 and lower, but requires only one SetItemPosition check per timeout.
    // -------- 1 checks collision vertically and horizontally to momentum. Uses an extra 4 SetItemPosition checks pet timeout.
    // -------- 2 checks collision diagonally with momentum. Uses a total of 9 SetItemPosition checks per timeout.
    // In any case, if the unit only has size 16 or lower collision, only one SetItemPosition check will be used for it.
    // If RobustPathing is set to 2 and the unit has 36 or less collision, it will only use the normal check of 5 SetItemPosition calls
    // The only reason to use robustness above 1 is for visual continuity - it features potentially-less glitchy movement.
    //  
    set udg_Knockback2DRobustPathing=2
    //  
    // Keep the friction between 0.00 and 1.00, At 0.00, friction keeps the unit at the same speed for the knockback
    // 1.00 friction will be an evenly-distributed deceleration which sees the unit slow to a complete stop
    // Friction outside of these bounds gives the knockback a boomerang-effect, so you are welcome to experiment.
    //  
    set udg_Knockback2DDefaultFriction=1.00
    set udg_Knockback2DFriction=udg_Knockback2DDefaultFriction
    //  
    // Determine the default bouncing behavior of units. You can set this before knocking a unit back.
    //  
    set udg_Knockback2DDefaultBounce=true
    set udg_Knockback2DBounces=udg_Knockback2DDefaultBounce
    //  
    // Determine the default mechanics of whether a unit should be unable to move while knocked back
    //  
    set udg_Knockback2DDefaultPause=false
    set udg_Knockback2DPause=udg_Knockback2DDefaultPause
    //  
    // Determine if surrounding trees should be killed by default or not
    //  
    set udg_Knockback2DDefaultKillTrees=false
    set udg_Knockback2DKillTrees=udg_Knockback2DDefaultKillTrees
    //  
    // If so, how wide should the radius be? 128.00 should be the minimum if you use pathing robustness greater than 0.
    // The minimum should be 64 if you use a robustness of 0.
    //  
    set udg_Knockback2DDefaultDestRadius=0.00
    set udg_Knockback2DDestRadius=udg_Knockback2DDefaultDestRadius
    //  
    // The "attack" option below will destroy any valid debris, from trees to barrels to creep homes.
    // If you just want to destroy trees, change the string to: harvest
    //  
    set udg_Knockback2DTreeOrDebris="attack"
    //  
    // 0.50 gravity will have equal ascend and decline rate, 1.00 is instant descend, 0.67 is twice as fast, 0.75 is three times as fast.
    //  
    set udg_Knockback2DDefaultGravity=0.71
    set udg_Knockback2DGravity=udg_Knockback2DDefaultGravity
    //  
    // Change the following to the default type of looping FX you want to have if you use Knockback Effects
    //  
    set udg_Knockback2DDefaultFX="Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
    set udg_Knockback2DLoopFX=udg_Knockback2DDefaultFX
    //  
    // How frequently should the effects appear per unit? This can also be customized per-knockback
    //  
    set udg_Knockback2DDefaultFXRate=0.20
    set udg_Knockback2DFXRate=udg_Knockback2DDefaultFXRate
    //  
    // Create an item to help verify pathing throughout the game
    //  
    set udg_CenterPoint=Location(udg_K2DX, udg_K2DY)
    call CreateItemLoc('rag1', udg_CenterPoint)
    set udg_K2DItem=GetLastCreatedItem()
    //  
    // Create a harvest-capable unit to check if debris can be killed
    //  
    set udg_UnitIndexerEnabled=false
    call CreateNUnitsAtLoc(1, 'ugho', Player(PLAYER_NEUTRAL_PASSIVE), udg_CenterPoint, 0.00)
    set udg_K2DDebrisKiller=GetLastCreatedUnit()
    //  
    // End Configuration
    //  
    set udg_UnitIndexerEnabled=true
    call RemoveLocation(udg_CenterPoint)
    call Preload(udg_Knockback2DDefaultFX)
    call SetItemVisibleBJ(false, udg_K2DItem)
    call ShowUnitHide(udg_K2DDebrisKiller)
    call PauseUnitBJ(true, udg_K2DDebrisKiller)
    call UnitAddAbility(udg_K2DDebrisKiller, 'Aloc')
    set udg_Radians_Turn=Deg2Rad(360.00)
    set udg_Radians_QuarterTurn=Deg2Rad(90.00)
    set udg_Radians_QuarterPi=Deg2Rad(45.00)
    set udg_K2DRegion=GetEntireMapRect()
    set udg_K2DMaxX=GetRectMaxX(udg_K2DRegion)
    set udg_K2DMaxY=GetRectMaxY(udg_K2DRegion)
    set udg_K2DMinX=GetRectMinX(udg_K2DRegion)
    set udg_K2DMinY=GetRectMinY(udg_K2DRegion)
    set udg_K2DMaxDestRadius=( udg_Knockback2DDefaultDestRadius * 2.00 )
    //This looks suspisous... call SetRect(udg_K2DRegion, 0.00, 0.00, udg_K2DMaxDestRadius, udg_K2DMaxDestRadius)
    set udg_K2DItemsFound=false
    set udg_K2DItemOffset=false
endfunction

//===========================================================================
function InitTrig_Knockback_2D_Config takes nothing returns nothing
    set gg_trg_Knockback_2D_Config=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_Knockback_2D_Config, "udg_UnitIndexEvent", EQUAL, 3.00)
    call TriggerAddAction(gg_trg_Knockback_2D_Config, function Trig_Knockback_2D_Config_Actions)
endfunction

//===========================================================================
// Trigger: Knockback 2D Destroy
//===========================================================================
function Trig_Knockback_2D_Destroy_Conditions takes nothing returns boolean
    if ( not ( udg_IsUnitBeingKnockedBack[udg_UDex] == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Destroy_Func010C takes nothing returns boolean
    if ( not ( udg_K2DNext[0] == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Destroy_Func011C takes nothing returns boolean
    if ( not ( udg_K2DHeight[udg_UDex] != 0.00 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Destroy_Func012C takes nothing returns boolean
    if ( not ( udg_K2DFreeze[udg_UDex] != true ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(udg_K2DImpact[udg_UDex]) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Destroy_Actions takes nothing returns nothing
    //  
    // This trigger destroys any knockback; you can execute it yourself by first setting UDex to the custom value
    //  
    set udg_IsUnitBeingKnockedBack[udg_UDex]=false
    set udg_K2DNext[udg_K2DPrev[udg_UDex]]=udg_K2DNext[udg_UDex]
    set udg_K2DPrev[udg_K2DNext[udg_UDex]]=udg_K2DPrev[udg_UDex]
    set udg_K2DPrev[udg_UDex]=0
    if ( Trig_Knockback_2D_Destroy_Func010C() ) then
        call PauseTimerBJ(true, udg_K2DTimer)
    else
    endif
    if ( Trig_Knockback_2D_Destroy_Func011C() ) then
        call SetUnitFlyHeightBJ(udg_Knockback2DUnit, GetUnitDefaultFlyHeight(udg_Knockback2DUnit), 0.00)
    else
    endif
    if ( Trig_Knockback_2D_Destroy_Func012C() ) then
        call ConditionalTriggerExecute(udg_K2DImpact[udg_UDex])
    else
    endif
    set udg_K2DOverride[udg_UDex]=false
    set udg_K2DSource[udg_UDex]=null
endfunction

//===========================================================================
function InitTrig_Knockback_2D_Destroy takes nothing returns nothing
    set gg_trg_Knockback_2D_Destroy=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_Knockback_2D_Destroy, "udg_UnitIndexEvent", EQUAL, 2.00)
    call TriggerAddCondition(gg_trg_Knockback_2D_Destroy, Condition(function Trig_Knockback_2D_Destroy_Conditions))
    call TriggerAddAction(gg_trg_Knockback_2D_Destroy, function Trig_Knockback_2D_Destroy_Actions)
endfunction

//===========================================================================
// Trigger: Knockback 2D
//
// You can run this trigger, checking conditions if you want to play it safe.
//===========================================================================
function Trig_Knockback_2D_Conditions takes nothing returns boolean
    if ( not ( GetUnitDefaultMoveSpeed(udg_Knockback2DUnit) != 0.00 ) ) then
        return false
    endif
    if ( not ( udg_K2DOverride[GetUnitUserData(udg_Knockback2DUnit)] == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func003Func001C takes nothing returns boolean
    if ( not ( udg_Knockback2DOverride == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func003C takes nothing returns boolean
    if ( not ( udg_IsUnitBeingKnockedBack[udg_UDex] == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func004C takes nothing returns boolean
    if ( not ( udg_K2DNext[0] == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func009C takes nothing returns boolean
    if ( not ( udg_Knockback2DHeight != 0.00 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func012C takes nothing returns boolean
    if ( not ( udg_Knockback2DPause == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func016Func004Func019C takes nothing returns boolean
    if ( not ( udg_Knockback2DRobustPathing == 2 ) ) then
        return false
    endif
    if ( not ( udg_K2DRadius[udg_UDex] > 16 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func016Func004C takes nothing returns boolean
    if ( not ( udg_Knockback2DRobustPathing > 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func016C takes nothing returns boolean
    if ( not ( IsUnitType(udg_Knockback2DUnit, UNIT_TYPE_FLYING) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func023Func003C takes nothing returns boolean
    if ( not ( ( udg_Knockback2DDestRadius * 2.00 ) > udg_K2DMaxDestRadius ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Func023C takes nothing returns boolean
    if ( not ( udg_Knockback2DKillTrees == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Knockback_2D_Actions takes nothing returns nothing
    local integer pdex= udg_UDex
    set udg_UDex=GetUnitUserData(udg_Knockback2DUnit)
    if ( Trig_Knockback_2D_Func003C() ) then
        if ( Trig_Knockback_2D_Func003Func001C() ) then
            set udg_K2DAngle[udg_UDex]=Rad2Deg(udg_K2DAngle[udg_UDex])
            set udg_Knockback2DAngle=( ( udg_Knockback2DAngle + udg_K2DAngle[udg_UDex] ) * 0.50 )
            set udg_Knockback2DDistance=( ( udg_K2DDistanceLeft[udg_UDex] + udg_Knockback2DDistance ) * 0.50 )
            set udg_Knockback2DTime=( ( udg_K2DTimeLeft[udg_UDex] + udg_Knockback2DTime ) * 0.50 )
        else
        endif
        call TriggerExecute(gg_trg_Knockback_2D_Destroy)
    else
    endif
    if ( Trig_Knockback_2D_Func004C() ) then
        call ExecuteFunc("StartKnockback2DTimer")
    else
    endif
    set udg_IsUnitBeingKnockedBack[udg_UDex]=true
    set udg_K2DPrev[udg_K2DNext[0]]=udg_UDex
    set udg_K2DNext[udg_UDex]=udg_K2DNext[0]
    set udg_K2DNext[0]=udg_UDex
    if ( Trig_Knockback_2D_Func009C() ) then
        set udg_K2DHeight[udg_UDex]=udg_Knockback2DHeight
        if UnitAddAbility(udg_Knockback2DUnit, 'Amrf') then
            call UnitRemoveAbility(udg_Knockback2DUnit, 'Amrf')
        endif
        call SetUnitFlyHeightBJ(udg_Knockback2DUnit, ( GetUnitDefaultFlyHeight(udg_Knockback2DUnit) + udg_Knockback2DHeight ), ( ( udg_Knockback2DHeight - GetUnitDefaultFlyHeight(udg_Knockback2DUnit) ) / ( udg_Knockback2DGravity * udg_Knockback2DTime ) ))
        set udg_K2DHeightThreshold[udg_UDex]=( ( 1 - udg_Knockback2DGravity ) * udg_Knockback2DTime )
        set udg_Knockback2DHeight=0.00
    else
        set udg_K2DHeight[udg_UDex]=0.00
    endif
    set udg_K2DX=GetUnitX(udg_Knockback2DUnit)
    set udg_K2DY=GetUnitY(udg_Knockback2DUnit)
    if ( Trig_Knockback_2D_Func012C() ) then
        set udg_K2DLastX[udg_UDex]=udg_K2DX
        set udg_K2DLastY[udg_UDex]=udg_K2DY
    else
    endif
    set udg_K2DAngle[udg_UDex]=Deg2Rad(udg_Knockback2DAngle)
    set udg_K2DCos[udg_UDex]=CosBJ(udg_Knockback2DAngle)
    set udg_K2DSin[udg_UDex]=SinBJ(udg_Knockback2DAngle)
    if ( Trig_Knockback_2D_Func016C() ) then
        set udg_K2DFlying[udg_UDex]=true
    else
        set udg_K2DFlying[udg_UDex]=false
        if ( Trig_Knockback_2D_Func016Func004C() ) then
            //  
            // Handle the pathing checker based on the unit's collision size
            //  
            if not IsUnitInRangeXY(udg_Knockback2DUnit, udg_K2DX + 17, udg_K2DY, 0) then
            set udg_K2DRadius[udg_UDex]=0
            else
            if not IsUnitInRangeXY(udg_Knockback2DUnit, udg_K2DX + 25, udg_K2DY, 0) then
            set udg_K2DRadius[udg_UDex]=8
            elseif not IsUnitInRangeXY(udg_Knockback2DUnit, udg_K2DX + 33, udg_K2DY, 0) then
            set udg_K2DRadius[udg_UDex]=16
            elseif not IsUnitInRangeXY(udg_Knockback2DUnit, udg_K2DX + 49, udg_K2DY, 0) then
            set udg_K2DRadius[udg_UDex]=32
            else
            set udg_K2DRadius[udg_UDex]=48
            endif
            set udg_Knockback2DAngle=ModuloReal(( udg_Knockback2DAngle + 90.00 ), 360.00)
            set udg_K2DCosH[udg_UDex]=CosBJ(udg_Knockback2DAngle)
            set udg_K2DSinH[udg_UDex]=SinBJ(udg_Knockback2DAngle)
            if ( Trig_Knockback_2D_Func016Func004Func019C() ) then
                set udg_Knockback2DAngle=ModuloReal(( udg_Knockback2DAngle + 45.00 ), 360.00)
                set udg_K2DCosD1[udg_UDex]=CosBJ(udg_Knockback2DAngle)
                set udg_K2DSinD1[udg_UDex]=SinBJ(udg_Knockback2DAngle)
                set udg_Knockback2DAngle=ModuloReal(( udg_Knockback2DAngle + 90.00 ), 360.00)
                set udg_K2DCosD2[udg_UDex]=CosBJ(udg_Knockback2DAngle)
                set udg_K2DSinD2[udg_UDex]=SinBJ(udg_Knockback2DAngle)
            else
            endif
            endif
        else
        endif
    endif
    set udg_K2DDistanceLeft[udg_UDex]=udg_Knockback2DDistance
    set udg_Knockback2DDistance=( ( ( 1.00 + udg_Knockback2DFriction ) * udg_Knockback2DDistance ) / udg_Knockback2DTime )
    set udg_K2DFriction[udg_UDex]=( ( udg_Knockback2DDistance / udg_Knockback2DTime ) * ( ( 1.00 - ( 1 - udg_Knockback2DFriction ) ) * ( udg_K2DTimeout * udg_K2DTimeout ) ) )
    set udg_K2DVelocity[udg_UDex]=( udg_Knockback2DDistance * udg_K2DTimeout )
    //  
    set udg_K2DKillTrees[udg_UDex]=udg_Knockback2DKillTrees
    if ( Trig_Knockback_2D_Func023C() ) then
        // Square the radius so we don't have to use SquareRoot when comparing distance.
        set udg_K2DDestRadius[udg_UDex]=( udg_Knockback2DDestRadius * udg_Knockback2DDestRadius )
        if ( Trig_Knockback_2D_Func023Func003C() ) then
            // Update the size of the enumerating rect to compensate for the desired extra radius.
            set udg_K2DMaxDestRadius=( udg_Knockback2DDestRadius * 2.00 )
            call SetRect(udg_K2DRegion, 0.00, 0.00, udg_K2DMaxDestRadius, udg_K2DMaxDestRadius)
        else
        endif
        set udg_Knockback2DDestRadius=udg_Knockback2DDefaultDestRadius
    else
    endif
    //  
    set udg_K2DAmphibious[udg_UDex]=udg_Knockback2DAmphibious
    set udg_K2DBounce[udg_UDex]=udg_Knockback2DBounces
    set udg_K2DCollision[udg_UDex]=udg_Knockback2DCollision
    set udg_K2DFreeze[udg_UDex]=false
    set udg_K2DFXModel[udg_UDex]=udg_Knockback2DLoopFX
    set udg_K2DFXRate[udg_UDex]=udg_Knockback2DFXRate
    set udg_K2DFXTimeLeft[udg_UDex]=udg_Knockback2DFXRate
    set udg_K2DImpact[udg_UDex]=udg_Knockback2DOnImpact
    set udg_K2DOverride[udg_UDex]=udg_Knockback2DOverride
    set udg_K2DPause[udg_UDex]=udg_Knockback2DPause
    set udg_K2DSimple[udg_UDex]=udg_Knockback2DSimple
    set udg_K2DSource[udg_UDex]=udg_Knockback2DSource
    set udg_K2DTimeLeft[udg_UDex]=udg_Knockback2DTime
    set udg_K2DUnbiasedCollision[udg_UDex]=udg_Knockback2DUnbiasedCollision
    set udg_Knockback2DAmphibious=false
    set udg_Knockback2DBounces=udg_Knockback2DDefaultBounce
    set udg_Knockback2DCollision=0.00
    set udg_Knockback2DFriction=udg_Knockback2DDefaultFriction
    set udg_Knockback2DFXRate=udg_Knockback2DDefaultFXRate
    set udg_Knockback2DGravity=udg_Knockback2DDefaultGravity
    set udg_Knockback2DKillTrees=udg_Knockback2DDefaultKillTrees
    set udg_Knockback2DLoopFX=udg_Knockback2DDefaultFX
    set udg_Knockback2DOnImpact=null
    set udg_Knockback2DOverride=false
    set udg_Knockback2DPause=udg_Knockback2DDefaultPause
    set udg_Knockback2DSimple=false
    set udg_Knockback2DSource=null
    set udg_Knockback2DUnbiasedCollision=false
    set udg_UDex=pdex
endfunction

//===========================================================================
function InitTrig_Knockback_2D takes nothing returns nothing
    set gg_trg_Knockback_2D=CreateTrigger()
    call TriggerAddCondition(gg_trg_Knockback_2D, Condition(function Trig_Knockback_2D_Conditions))
    call TriggerAddAction(gg_trg_Knockback_2D, function Trig_Knockback_2D_Actions)
endfunction

//===========================================================================
// Trigger: Knockback 2D System
//===========================================================================
//TESH.scrollpos=205
//TESH.alwaysfold=0
function K2DItemCheckXY takes real x,real y returns boolean
    call SetItemPosition(udg_K2DItem, x, y)
    return GetWidgetX(udg_K2DItem) == x and GetWidgetY(udg_K2DItem) == y
endfunction

function K2DItemCheckAxis takes real x,real y returns boolean
    local real x2= x * udg_K2DRadius[udg_UDex]
    local real y2= y * udg_K2DRadius[udg_UDex]
    set x=udg_K2DX + x2
    set y=udg_K2DY + y2
    if K2DItemCheckXY(x , y) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) then
        set x=udg_K2DX - x2
        set y=udg_K2DY - y2
        return K2DItemCheckXY(x , y) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)
    endif
    return false
endfunction

function K2DItemCheck takes nothing returns boolean
    local boolean result= K2DItemCheckXY(udg_K2DX , udg_K2DY)
    
    //Only perform additional pathing checks if the unit has a larger collision.
    if result and udg_Knockback2DRobustPathing > 0 and udg_K2DRadius[udg_UDex] > 0 then

        //Check horizontal axis of unit to make sure nothing is going to collide
        set result=K2DItemCheckAxis(udg_K2DCosH[udg_UDex] , udg_K2DSinH[udg_UDex])
        
        //Check vertical axis of unit to ensure nothing will collide
        set result=result and K2DItemCheckAxis(udg_K2DCos[udg_UDex] , udg_K2DSin[udg_UDex])
        
        if result and udg_Knockback2DRobustPathing == 2 and udg_K2DRadius[udg_UDex] > 16 then

            //Check diagonal axis of unit if more thorough pathing is desired
            set result=K2DItemCheckAxis(udg_K2DCosD1[udg_UDex] , udg_K2DSinD1[udg_UDex])
            set result=result and K2DItemCheckAxis(udg_K2DCosD2[udg_UDex] , udg_K2DSinD2[udg_UDex])
        endif
    endif
    
    //Reset item so it won't interfere with the map
    call SetItemPosition(udg_K2DItem, udg_K2DMaxX, udg_K2DMaxY)
    call SetItemVisible(udg_K2DItem, false)
    
    return result
endfunction

function K2DItemFilter takes nothing returns boolean
    //Check for visible items, temporarily hide them and add them to the filter.
    if IsItemVisible(GetFilterItem()) then
        call SetItemVisible(GetFilterItem(), false)
        return true
    endif
    return false
endfunction
function K2DItemCode takes nothing returns nothing
    //Perform the item-pathing check only once, then unhide those filtered items
    if not udg_K2DItemsFound then
        set udg_K2DItemsFound=true
        set udg_K2DItemOffset=K2DItemCheck()
    endif
    call SetItemVisible(GetEnumItem(), true)
endfunction

function K2DKillDest takes nothing returns nothing
    local real x
    local real y
    //Handle destruction of debris
    set bj_destRandomCurrentPick=GetEnumDestructable()
    if GetWidgetLife(bj_destRandomCurrentPick) > 0.405 and IssueTargetOrder(udg_K2DDebrisKiller, udg_Knockback2DTreeOrDebris, bj_destRandomCurrentPick) then
        set x=GetWidgetX(bj_destRandomCurrentPick) - udg_K2DX
        set y=GetWidgetY(bj_destRandomCurrentPick) - udg_K2DY
        if x * x + y * y <= udg_K2DDestRadius[udg_UDex] then
            call KillDestructable(bj_destRandomCurrentPick)
        endif
    endif
endfunction

function K2DEnumDests takes nothing returns nothing
    call MoveRectTo(udg_K2DRegion, udg_K2DX, udg_K2DY)
    if udg_K2DKillTrees[udg_UDex] then
        call SetUnitX(udg_K2DDebrisKiller, udg_K2DX)
        call SetUnitY(udg_K2DDebrisKiller, udg_K2DY)
        call EnumDestructablesInRect(udg_K2DRegion, null, function K2DKillDest)
    endif
endfunction

function Knockback2DCheckXY takes real x,real y returns boolean
    set udg_K2DX=x + udg_K2DVelocity[udg_UDex] * udg_K2DCos[udg_UDex]
    set udg_K2DY=y + udg_K2DVelocity[udg_UDex] * udg_K2DSin[udg_UDex]
    if udg_K2DSimple[udg_UDex] then
        //A "pull" effect or a missile system does not require complex pathing.
        if udg_K2DX <= udg_K2DMaxX and udg_K2DX >= udg_K2DMinX and udg_K2DY <= udg_K2DMaxY and udg_K2DY >= udg_K2DMinY then
            call K2DEnumDests()
            return true
        endif
        return false
    elseif udg_K2DFlying[udg_UDex] then
        return not IsTerrainPathable(udg_K2DX, udg_K2DY, PATHING_TYPE_FLYABILITY)
    elseif not IsTerrainPathable(udg_K2DX, udg_K2DY, PATHING_TYPE_WALKABILITY) then
        call K2DEnumDests()
        set udg_K2DItemOffset=false
        call EnumItemsInRect(udg_K2DRegion, Filter(function K2DItemFilter), function K2DItemCode)
        if udg_K2DItemsFound then
            //If items were found, the check was already performed.
            set udg_K2DItemsFound=false
        else
            //Otherwise, perform the check right now.
            set udg_K2DItemOffset=K2DItemCheck()
        endif
        return udg_K2DItemOffset
    endif
    return udg_K2DAmphibious[udg_UDex] and not IsTerrainPathable(udg_K2DX, udg_K2DY, PATHING_TYPE_FLOATABILITY)
endfunction

function Knockback2DApplyAngle takes real angle returns nothing
    set angle=ModuloReal(angle, udg_Radians_Turn)
    set udg_K2DCos[udg_UDex]=Cos(angle)
    set udg_K2DSin[udg_UDex]=Sin(angle)
    set udg_K2DAngle[udg_UDex]=angle
    if udg_Knockback2DRobustPathing > 0 then
        set angle=ModuloReal(angle + udg_Radians_QuarterTurn, udg_Radians_Turn)
        set udg_K2DCosH[udg_UDex]=Cos(angle)
        set udg_K2DSinH[udg_UDex]=Sin(angle)
        if udg_Knockback2DRobustPathing == 2 and udg_K2DRadius[udg_UDex] > 16 then
            set angle=ModuloReal(angle + udg_Radians_QuarterPi, udg_Radians_Turn)
            set udg_K2DCosD1[udg_UDex]=Cos(angle)
            set udg_K2DSinD1[udg_UDex]=Sin(angle)
            set angle=ModuloReal(angle + udg_Radians_QuarterTurn, udg_Radians_Turn)
            set udg_K2DCosD2[udg_UDex]=Cos(angle)
            set udg_K2DSinD2[udg_UDex]=Sin(angle)
        endif
    endif
endfunction

function Knockback2DLooper takes nothing returns nothing
    local integer i= 0
    local unit u
    local real x
    local real y
    
    call PauseUnit(udg_K2DDebrisKiller, false)
    
    loop
        set i=udg_K2DNext[i]
        exitwhen i == 0
        set udg_UDex=i
        set udg_K2DTimeLeft[i]=udg_K2DTimeLeft[i] - udg_K2DTimeout
        set udg_K2DDistanceLeft[i]=udg_K2DDistanceLeft[i] - udg_K2DVelocity[i]
        set u=udg_UDexUnits[i]
        
        if udg_K2DTimeLeft[i] > 0.00 then
            if udg_K2DTimeLeft[i] < udg_K2DHeightThreshold[i] and udg_K2DHeightThreshold[i] != 0.00 then
                call SetUnitFlyHeight(u, GetUnitDefaultFlyHeight(u), GetUnitFlyHeight(u) - GetUnitDefaultFlyHeight(u) / udg_K2DHeightThreshold[i])
                set udg_K2DHeightThreshold[i]=0.00
            endif
            if udg_K2DPause[i] then
                set x=udg_K2DLastX[i]
                set y=udg_K2DLastY[i]
            else
                set x=GetUnitX(u)
                set y=GetUnitY(u)
            endif
            
            if not Knockback2DCheckXY(x , y) then
                if not udg_K2DFreeze[i] and IsTriggerEnabled(udg_K2DImpact[i]) and TriggerEvaluate(udg_K2DImpact[i]) then
                    call TriggerExecute(udg_K2DImpact[i])
                endif
                if udg_K2DBounce[i] then
                    call Knockback2DApplyAngle(udg_Radians_Turn - udg_K2DAngle[i])
                    if not Knockback2DCheckXY(x , y) then
                        call Knockback2DApplyAngle(udg_K2DAngle[i] + bj_PI)
                        if not Knockback2DCheckXY(x , y) then
                            call Knockback2DApplyAngle(udg_Radians_Turn - udg_K2DAngle[i])
                            set udg_K2DX=x
                            set udg_K2DY=y
                        endif
                    endif
                else
                    set udg_K2DX=x
                    set udg_K2DY=y
                    set udg_K2DFreeze[i]=true
                endif
            endif
            call SetUnitX(u, udg_K2DX)
            call SetUnitY(u, udg_K2DY)
            set udg_K2DLastX[i]=udg_K2DX
            set udg_K2DLastY[i]=udg_K2DY
            if udg_K2DFXModel[i] != "" then
                set udg_K2DFXTimeLeft[i]=udg_K2DFXTimeLeft[i] - udg_K2DTimeout
                if udg_K2DFXTimeLeft[i] <= 0.00 then
                    set udg_K2DFXTimeLeft[i]=udg_K2DFXRate[i]
                    if udg_K2DFlying[i] then
                        call DestroyEffect(AddSpecialEffectTarget(udg_K2DFXModel[i], u, "origin"))
                    else
                        call DestroyEffect(AddSpecialEffect(udg_K2DFXModel[i], udg_K2DX, udg_K2DY))
                    endif
                endif
            endif
            if udg_K2DCollision[i] >= 0.00 then
                set udg_Knockback2DSource=u
                call GroupEnumUnitsInRange(bj_lastCreatedGroup, udg_K2DX, udg_K2DY, 200.00, null)
                call GroupRemoveUnit(bj_lastCreatedGroup, u)
                loop
                    set udg_Knockback2DUnit=FirstOfGroup(bj_lastCreatedGroup)
                    exitwhen udg_Knockback2DUnit == null
                    call GroupRemoveUnit(bj_lastCreatedGroup, udg_Knockback2DUnit)
                    
                    if IsUnitInRange(udg_Knockback2DUnit, u, udg_K2DCollision[i]) and udg_K2DFlying[i] == IsUnitType(udg_Knockback2DUnit, UNIT_TYPE_FLYING) and ( not IsUnitType(udg_Knockback2DUnit, UNIT_TYPE_STRUCTURE) ) and not IsUnitType(udg_Knockback2DUnit, UNIT_TYPE_DEAD) and ( udg_K2DUnbiasedCollision[i] or IsUnitAlly(udg_Knockback2DUnit, GetOwningPlayer(u)) ) and TriggerEvaluate(gg_trg_Knockback_2D) then
                        set udg_Knockback2DAngle=bj_RADTODEG * Atan2(GetUnitY(udg_Knockback2DUnit) - udg_K2DY, GetUnitX(udg_Knockback2DUnit) - udg_K2DX)
                        set udg_Knockback2DDistance=udg_K2DDistanceLeft[i]
                        set udg_Knockback2DBounces=udg_K2DBounce[i]
                        set udg_Knockback2DCollision=udg_K2DCollision[i]
                        if udg_K2DHeight[i] != 0.00 then
                            set udg_Knockback2DHeight=GetUnitFlyHeight(u) - GetUnitDefaultFlyHeight(u)
                        endif
                        set udg_Knockback2DLoopFX=udg_K2DFXModel[i]
                        set udg_Knockback2DTime=udg_K2DTimeLeft[i]
                        set udg_Knockback2DUnbiasedCollision=udg_K2DUnbiasedCollision[i]
                        call TriggerExecute(gg_trg_Knockback_2D)
                        set udg_Knockback2DSource=u //in case of a recursive knockback
                    endif
                endloop
            endif
            set udg_K2DVelocity[i]=udg_K2DVelocity[i] - udg_K2DFriction[i]
        else
            call TriggerExecute(gg_trg_Knockback_2D_Destroy)
        endif
    endloop
    set u=null
    
    //Disable dummy after the loop finishes so it doesn't interfere with the map
    call PauseUnit(udg_K2DDebrisKiller, true)
endfunction

//===========================================================================
function StartKnockback2DTimer takes nothing returns nothing
    call TimerStart(udg_K2DTimer, udg_K2DTimeout, true, function Knockback2DLooper)
endfunction
function InitTrig_Knockback_2D_System takes nothing returns nothing
endfunction
//===========================================================================
// Trigger: CooldownReduction
//
// https://www.hiveworkshop.com/threads/cooldown-reduction-vjass-lua.324279/
// https://www.hiveworkshop.com/members/chopinski.217995/#resources
//===========================================================================

//===========================================================================
// Trigger: CooldownReductionUtils
//
// https://www.hiveworkshop.com/threads/cooldown-reduction-vjass-lua.324279/
//===========================================================================
//===========================================================================
// Trigger: Relativistic Missiles
//
// https://www.hiveworkshop.com/threads/relativistic-missiles-vjass-lua-gui.325964/
// https://www.hiveworkshop.com/members/chopinski.217995/#resources
//===========================================================================
//===========================================================================
// Trigger: MissileEffect
//===========================================================================

//===========================================================================
// Trigger: MissileUtils
//===========================================================================

//===========================================================================
// Trigger: Check Walkability Setup
//===========================================================================
function Trig_Check_Walkability_Setup_Actions takes nothing returns nothing
    set udg_CP_Rect=Rect(0, 0, 128.00, 128.00)
    set udg_CP_Item=CreateItem('wtlg', 0, 0)
    call SetItemVisibleBJ(false, udg_CP_Item)
    // Variables For Copy and Paste
    set udg_CP_HiddenItemsIndex=0
    set udg_CP_HiddenItems[0]=null
    set udg_CP_Point=GetSpellTargetLoc()
    set udg_CP_PointIsWalkable=false
endfunction

//===========================================================================
function InitTrig_Check_Walkability_Setup takes nothing returns nothing
    set gg_trg_Check_Walkability_Setup=CreateTrigger()
    call TriggerAddAction(gg_trg_Check_Walkability_Setup, function Trig_Check_Walkability_Setup_Actions)
endfunction

//===========================================================================
// Trigger: Check Walkability
//===========================================================================
function Trig_Check_Walkability_Func006A takes nothing returns nothing
    if IsItemVisible(GetEnumItem()) then
    set udg_CP_HiddenItems[udg_CP_HiddenItemsIndex]=GetEnumItem()
    call SetItemVisible(udg_CP_HiddenItems[udg_CP_HiddenItemsIndex], false)
    set udg_CP_HiddenItemsIndex=( udg_CP_HiddenItemsIndex + 1 )
    endif
endfunction

function Trig_Check_Walkability_Actions takes nothing returns nothing
    local real x= GetLocationX(udg_CP_Point)
    local real y= GetLocationY(udg_CP_Point)
    local real x2= 0
    local real y2= 0
    call MoveRectTo(udg_CP_Rect, x, y)
    call EnumItemsInRectBJ(udg_CP_Rect, function Trig_Check_Walkability_Func006A)
    call SetItemPosition(udg_CP_Item, x, y)
    set x2=GetItemX(udg_CP_Item)
    set y2=GetItemY(udg_CP_Item)
    call SetItemVisible(udg_CP_Item, false)
    loop
    exitwhen udg_CP_HiddenItemsIndex <= 0
    set udg_CP_HiddenItemsIndex=udg_CP_HiddenItemsIndex - 1
    call SetItemVisible(udg_CP_HiddenItems[udg_CP_HiddenItemsIndex], true)
    set udg_CP_HiddenItems[udg_CP_HiddenItemsIndex]=null
    endloop
    set udg_CP_PointIsWalkable=( ( x2 - x ) * ( x2 - x ) + ( y2 - y ) * ( y2 - y ) <= 100 ) and ( not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) )
endfunction

//===========================================================================
function InitTrig_Check_Walkability takes nothing returns nothing
    set gg_trg_Check_Walkability=CreateTrigger()
    call TriggerAddAction(gg_trg_Check_Walkability, function Trig_Check_Walkability_Actions)
endfunction

//===========================================================================
// Trigger: Damage Engine Config
//===========================================================================
function Trig_Damage_Engine_Config_Actions takes nothing returns nothing
    // -
    // You can add extra classifications here if you want to differentiate between your triggered damage
    // Use DamageTypeExplosive (or any negative value damage type) if you want a unit killed by that damage to explode
    // -
    // The pre-defined type Code might be set by Damage Engine if Unit - Damage Target is detected and the user didn't define a type of their own.
    // "Pure" is especially important because it overrides both the Damage Engine as well as WarCraft 3 damage modification.
    // I therefore gave the user "Explosive Pure" in case one wants to combine the functionality of the two.
    // -
    set udg_DamageTypePureExplosive=- 2
    set udg_DamageTypeExplosive=- 1
    set udg_DamageTypeCode=1
    set udg_DamageTypePure=2
    // -
    set udg_DamageTypeHeal=3
    set udg_DamageTypeBlocked=4
    set udg_DamageTypeReduced=5
    // -
    set udg_DamageTypeCriticalStrike=6
    // -
    // Added 25 July 2017 to allow detection of things like Bash or Pulverize or AOE spread
    // -
    set udg_DamageEventAOE=1
    set udg_DamageEventLevel=1
    // -
    // In-game World Editor doesn't allow Attack Type and Damage Type comparisons. Therefore I need to code them as integers into GUI
    // -
    set udg_ATTACK_TYPE_SPELLS=0
    set udg_ATTACK_TYPE_NORMAL=1
    set udg_ATTACK_TYPE_PIERCE=2
    set udg_ATTACK_TYPE_SIEGE=3
    set udg_ATTACK_TYPE_MAGIC=4
    set udg_ATTACK_TYPE_CHAOS=5
    set udg_ATTACK_TYPE_HERO=6
    // -
    set udg_DAMAGE_TYPE_UNKNOWN=0
    set udg_DAMAGE_TYPE_NORMAL=4
    set udg_DAMAGE_TYPE_ENHANCED=5
    set udg_DAMAGE_TYPE_FIRE=8
    set udg_DAMAGE_TYPE_COLD=9
    set udg_DAMAGE_TYPE_LIGHTNING=10
    set udg_DAMAGE_TYPE_POISON=11
    set udg_DAMAGE_TYPE_DISEASE=12
    set udg_DAMAGE_TYPE_DIVINE=13
    set udg_DAMAGE_TYPE_MAGIC=14
    set udg_DAMAGE_TYPE_SONIC=15
    set udg_DAMAGE_TYPE_ACID=16
    set udg_DAMAGE_TYPE_FORCE=17
    set udg_DAMAGE_TYPE_DEATH=18
    set udg_DAMAGE_TYPE_MIND=19
    set udg_DAMAGE_TYPE_PLANT=20
    set udg_DAMAGE_TYPE_DEFENSIVE=21
    set udg_DAMAGE_TYPE_DEMOLITION=22
    set udg_DAMAGE_TYPE_SLOW_POISON=23
    set udg_DAMAGE_TYPE_SPIRIT_LINK=24
    set udg_DAMAGE_TYPE_SHADOW_STRIKE=25
    set udg_DAMAGE_TYPE_UNIVERSAL=26
    // -
    // The below variables don't affect damage amount, but do affect the sound played
    // They also give important information about the type of attack used.
    // They can differentiate between ranged and melee for units who are both
    // -
    set udg_WEAPON_TYPE_NONE=0
    // Metal Light/Medium/Heavy
    set udg_WEAPON_TYPE_ML_CHOP=1
    set udg_WEAPON_TYPE_MM_CHOP=2
    set udg_WEAPON_TYPE_MH_CHOP=3
    set udg_WEAPON_TYPE_ML_SLICE=4
    set udg_WEAPON_TYPE_MM_SLICE=5
    set udg_WEAPON_TYPE_MH_SLICE=6
    set udg_WEAPON_TYPE_MM_BASH=7
    set udg_WEAPON_TYPE_MH_BASH=8
    set udg_WEAPON_TYPE_MM_STAB=9
    set udg_WEAPON_TYPE_MH_STAB=10
    // Wood Light/Medium/Heavy
    set udg_WEAPON_TYPE_WL_SLICE=11
    set udg_WEAPON_TYPE_WM_SLICE=12
    set udg_WEAPON_TYPE_WH_SLICE=13
    set udg_WEAPON_TYPE_WL_BASH=14
    set udg_WEAPON_TYPE_WM_BASH=15
    set udg_WEAPON_TYPE_WH_BASH=16
    set udg_WEAPON_TYPE_WL_STAB=17
    set udg_WEAPON_TYPE_WM_STAB=18
    // Claw Light/Medium/Heavy
    set udg_WEAPON_TYPE_CL_SLICE=19
    set udg_WEAPON_TYPE_CM_SLICE=20
    set udg_WEAPON_TYPE_CH_SLICE=21
    // Axe Medium
    set udg_WEAPON_TYPE_AM_CHOP=22
    // Rock Heavy
    set udg_WEAPON_TYPE_RH_BASH=23
    // -
    // Since GUI still doesn't provide Defense Type and Armor Types, I needed to include the below
    // -
    set udg_ARMOR_TYPE_NONE=0
    set udg_ARMOR_TYPE_FLESH=1
    set udg_ARMOR_TYPE_METAL=2
    set udg_ARMOR_TYPE_WOOD=3
    set udg_ARMOR_TYPE_ETHEREAL=4
    set udg_ARMOR_TYPE_STONE=5
    // -
    set udg_DEFENSE_TYPE_LIGHT=0
    set udg_DEFENSE_TYPE_MEDIUM=1
    set udg_DEFENSE_TYPE_HEAVY=2
    set udg_DEFENSE_TYPE_FORTIFIED=3
    set udg_DEFENSE_TYPE_NORMAL=4
    set udg_DEFENSE_TYPE_HERO=5
    set udg_DEFENSE_TYPE_DIVINE=6
    set udg_DEFENSE_TYPE_UNARMORED=7
    // -
    call DamageEngine_DebugStr()
endfunction

//===========================================================================
function InitTrig_Damage_Engine_Config takes nothing returns nothing
    set gg_trg_Damage_Engine_Config=CreateTrigger()
    call TriggerAddAction(gg_trg_Damage_Engine_Config, function Trig_Damage_Engine_Config_Actions)
endfunction

//===========================================================================
// Trigger: Damage Engine
//
// https://www.hiveworkshop.com/threads/damage-engine-5-7-1-2.201016/
// https://github.com/BribeFromTheHive/DamageEngine
// https://github.com/BribeFromTheHive/DamageEngine/blob/master/script.j
//===========================================================================

//===========================================================================
//
//  Damage Engine 5.7.1.2 - update requires replacing the JASS script.
//

//===========================================================================
//===========================================================================
// Trigger: DelayedDestroyer
//===========================================================================
//===========================================================================
// Trigger: UI
//===========================================================================
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicBottomBorder",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicDialogueText",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicPanel",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicPanelControlFrame",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicPortrait",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicPortraitBackground",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicPortraitCover",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicScenePanel",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicSpeakerText",0), false)
//call BlzFrameSetVisible(BlzGetFrameByName("CinematicTopBorder",0), false)
//call BlzFrameSetVisible(BlzGetOriginFrame(ORIGIN_FRAME_PORTRAIT, 0), false)

//===========================================================================
// Trigger: MouseUtilsLockCamExtension
//===========================================================================

//===========================================================================
// Trigger: DestructablesUpdate
//===========================================================================

// ------------ Public functions --------------
function OpenDoor takes destructable d returns nothing
    local integer id= GetHandleId(d)
    call KillDestructable(d)
    //set DestructableUpdater.table[id] = BlzBitOr(DestructableUpdater.table[id], BlzBitOr(DEAD_FLAG, ANIMATING_FLAG))
    call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( BlzBitOr(DEAD_FLAG, ANIMATING_FLAG))) // INLINED!!
    call TimerStart(NewTimerEx(id), 1.0, false, function s__DestructableUpdater_resetAnimatingFlag)
endfunction

function CloseDoor takes destructable d returns nothing
    local integer id= GetHandleId(d)
    call DestructableRestoreLife(d, GetDestructableMaxLife(d), true)
    //set DestructableUpdater.table[id] = BlzBitOr(BlzBitAnd(DestructableUpdater.table[id], BlzBitXor(DEAD_FLAG, -1)), ANIMATING_FLAG)
    call SaveInteger(Table__ht, (s__DestructableUpdater_table), (id), ( ANIMATING_FLAG)) // INLINED!!
    call TimerStart(NewTimerEx(id), 1.0, false, function s__DestructableUpdater_resetAnimatingFlag)
endfunction

//===========================================================================
// Trigger: HeroController
//===========================================================================

//===========================================================================
// Trigger: KnockbackTZ
//===========================================================================

//===========================================================================
// Trigger: ExtendableBonusSystem
//===========================================================================

//===========================================================================
// Trigger: ExtendableBonusesGeneral
//===========================================================================

//===========================================================================
// Trigger: ExtendableBonusesMetroidvania
//===========================================================================
//===========================================================================
// Trigger: PickupCore
//===========================================================================
function Trig_PickupCore_Conditions takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I001' ) ) then
        return false
    endif
    return true
endfunction

function Trig_PickupCore_Actions takes nothing returns nothing
    call s__HeroStatsCore_addCoresForAll(1)
    call updateStatsPanel(GetLocalPlayer()) // INLINED!!
    set udg_t_loc1=GetItemLoc(GetManipulatedItem())
    call CreateTextTagLocBJ("TRIGSTR_226", udg_t_loc1, 0, 10, 100, 100, 100, 0)
    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), GetRandomReal(32.00, 48.00), GetRandomReal(75.00, 105.00))
    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 2.00)
    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 1.50)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_PickupCore takes nothing returns nothing
    set gg_trg_PickupCore=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_PickupCore, EVENT_PLAYER_UNIT_PICKUP_ITEM)
    call TriggerAddCondition(gg_trg_PickupCore, Condition(function Trig_PickupCore_Conditions))
    call TriggerAddAction(gg_trg_PickupCore, function Trig_PickupCore_Actions)
endfunction

//===========================================================================
// Trigger: RespawnHelpers
//===========================================================================
//===========================================================================
// Trigger: ReincarnateStart
//===========================================================================
function Trig_ReincarnateStart_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(udg_UDexUnits[udg_UDex]) == 'h000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_ReincarnateStart_Actions takes nothing returns nothing
    set udg_t_unit1=udg_UDexUnits[udg_UDex]
    call GroupRemoveUnitSimple(udg_t_unit1, udg_heroes_alive)
    call GroupAddUnitSimple(udg_t_unit1, udg_heroes_dead)
    call heroRespawnLater(udg_t_unit1)
    set udg_onHeroDeathEvent=1.00
    set udg_onHeroDeathEvent=0.00
endfunction

//===========================================================================
function InitTrig_ReincarnateStart takes nothing returns nothing
    set gg_trg_ReincarnateStart=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_ReincarnateStart, "udg_DeathEvent", EQUAL, 0.50)
    call TriggerAddCondition(gg_trg_ReincarnateStart, Condition(function Trig_ReincarnateStart_Conditions))
    call TriggerAddAction(gg_trg_ReincarnateStart, function Trig_ReincarnateStart_Actions)
endfunction

//===========================================================================
// Trigger: BombDetonate
//===========================================================================
function Trig_BombDetonate_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h002' ) ) then
        return false
    endif
    return true
endfunction

function Trig_BombDetonate_Func006A takes nothing returns nothing
    call s__NewBonusUtils__NewBonusUtils_linkTimed((GetEnumUnit() ) , ( si__BonusMovementSpeed ) , (( - 0.4 * GetUnitMoveSpeed(GetEnumUnit()) )*1.0) , (( 1.5)*1.0) , true) // INLINED!!
endfunction

function Trig_BombDetonate_Actions takes nothing returns nothing
    set udg_t_unit1=(s__MetroidvaniaController_u[((GetPlayerId(((GetTriggerPlayer())))))]) // INLINED!!
    set udg_t_group1=CreateGroup()
    set udg_t_real1=sc__HeroBasicBombAction_getDamage(udg_t_unit1)
    call damageAoENoFFWithResult(udg_t_unit1 , GetUnitX(GetTriggerUnit()) , GetUnitY(GetTriggerUnit()) , udg_t_real1 , 200. , DAMAGE_TYPE_DEMOLITION , udg_t_group1)
    call destroyDest1(GetUnitX(GetTriggerUnit()) , GetUnitY(GetTriggerUnit()) , 225.)
    call ForGroupBJ(udg_t_group1, function Trig_BombDetonate_Func006A)
    call DestroyGroup(udg_t_group1)
    set udg_t_loc1=GetUnitLoc(GetTriggerUnit())
    call AddSpecialEffectLocBJ(udg_t_loc1, "Units\\NightElf\\Wisp\\WispExplode.mdl")
    call BlzPlaySpecialEffect(GetLastCreatedEffectBJ(), ANIM_TYPE_BIRTH)
    call BlzSetSpecialEffectColor(GetLastCreatedEffectBJ(), 100, 100, 255)
    call s__EffectDestroyer_destroyLater(bj_lastCreatedEffect , ((1.0)*1.0)) // INLINED!!
    call PlaySoundAtPointBJ(gg_snd_AbilityBombDetonate, 100, udg_t_loc1, 50.00)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_BombDetonate takes nothing returns nothing
    set gg_trg_BombDetonate=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_BombDetonate, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_BombDetonate, Condition(function Trig_BombDetonate_Conditions))
    call TriggerAddAction(gg_trg_BombDetonate, function Trig_BombDetonate_Actions)
endfunction

//===========================================================================
// Trigger: BombPickup
//===========================================================================
function Trig_BombPickup_Conditions takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_BombPickup_Func001A takes nothing returns nothing
    call s__MetroidvaniaController_setUtil1(GetOwningPlayer(GetEnumUnit()) , sc__HeroBasicBombAction_create(GetEnumUnit()))
    call CreateTextTagLocBJ("TRIGSTR_328", udg_t_loc1, 0, 10, 100, 100, 100, 0)
    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), GetRandomReal(32.00, 48.00), GetRandomReal(75.00, 105.00))
    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 2.00)
    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 1.50)
endfunction

function Trig_BombPickup_Actions takes nothing returns nothing
    call ForGroupBJ(udg_heroes_all, function Trig_BombPickup_Func001A)
endfunction

//===========================================================================
function InitTrig_BombPickup takes nothing returns nothing
    set gg_trg_BombPickup=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_BombPickup, EVENT_PLAYER_UNIT_PICKUP_ITEM)
    call TriggerAddCondition(gg_trg_BombPickup, Condition(function Trig_BombPickup_Conditions))
    call TriggerAddAction(gg_trg_BombPickup, function Trig_BombPickup_Actions)
endfunction

//===========================================================================
// Trigger: HeroAbilities
//===========================================================================

    function s__HeroAttackBasic_onFinish takes integer this returns boolean
        return true
    endfunction

    
    function s__HeroAttackBasic_onHit takes integer this,unit hit returns boolean
        if BlzIsUnitSelectable(hit) and ( not IsUnitAlly(hit, s__Missiles_owner[this]) or GetPlayerId(GetOwningPlayer(hit)) == PLAYER_NEUTRAL_PASSIVE ) then
            //set udg_NextDamageType = udg_DamageTypeCode
            //call UnitDamageTarget(source, hit, damage, true, true, ATTACK_TYPE_HERO, DAMAGE_TYPE_NORMAL, null)
call s__Damage_apply((s__Missiles_source[this] ) , ( hit ) , (( s__Missiles_damage[this] )*1.0) , true , ( true ) , ( ATTACK_TYPE_HERO ) , DAMAGE_TYPE_NORMAL , ( WEAPON_TYPE_WHOKNOWS)) // INLINED!!
            return true
        endif
        return false
    endfunction

    function s__HeroAttackBasic_onDestructable takes integer this,destructable dest returns boolean
        if hitDest(dest , 0) or GetDestructableOccluderHeight(dest) > 50.0 and GetDestructableLife(dest) > 0. then
            return true
        else
            return false
        endif
    endfunction
    function s__HeroAttackBasic_onTerrain takes integer this returns boolean
        return true
    endfunction
    function s__HeroAttackBasic_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
    endfunction

    function s__HeroAttackBasic_fireFrom takes unit u,real x,real y,real tx,real ty,real dmg,real spread,real distance,real speed returns nothing
        //local real     z = 100.
        local real angle= Atan2(ty - y, tx - x) + GetRandomReal(- spread, spread)
        local real tx2= x + distance * Cos(angle)
        local real ty2= y + distance * Sin(angle)
        local integer startCliff= GetTerrainCliffLevel(x, y)
        local integer endCliff= GetTerrainCliffLevel(tx2, ty2)
        local integer this= s__HeroAttackBasic__allocate(x + 24. * Cos(angle) , y + 24. * Sin(angle) , 100. , tx2 , ty2 , 64. + 128. * ( startCliff - endCliff ))

        set s__Missiles_source[this]=u
        call s__Missiles__set_model(this,"Units\\Hero\\BeamMissile.mdx")
        call s__Missiles__set_speed(this,speed)
        set s__Missiles_collision[this]=26.
        set s__Missiles_damage[this]=dmg
        set s__Missiles_owner[this]=GetOwningPlayer(u)

        call s__Missiles_launch(this)
    endfunction


    function s__HeroAttackBasic_fire takes unit u,real tx,real ty,real dmg,real spread,real distance,real speed returns nothing
        call s__HeroAttackBasic_fireFrom(u , GetUnitX(u) , GetUnitY(u) , tx , ty , dmg , spread , distance , speed)
    endfunction

    function s__HeroAttackBasic_fireAsHeroActionFire takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer index= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
        local unit u= udg_UDexUnits[index]
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((GetOwningPlayer(u))))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((GetOwningPlayer(u))))]) // INLINED!!
        local real dmg= GetDamage(u)

        call s__HeroAttackBasic_fire(u , tx , ty , dmg , 0.02 , 1800. , 1400.)
        call ReleaseTimer(t)
        set u=null
        set t=null
    endfunction

    function s__HeroAttackBasicAction_dmgPercent takes integer this returns real
        return 1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) * 0.01 // INLINED!!
    endfunction
    function s__HeroAttackBasicAction_damageCalculation takes integer this returns real
        return (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) * GetDamage(s__HeroActionBase_u[this]) // INLINED!!
    endfunction

    function s__HeroAttackBasicAction_animationSpeed takes integer this returns real
        return 1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemSpeed))) // INLINED!!
    endfunction
    function s__HeroAttackBasicAction_updateAbilityDetails takes integer this returns nothing
        local real duration= 0.8 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] )) // INLINED!!
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.33 * duration , duration , duration * 1.25)
        set s__HeroActionBase_energyCost[this]=3.5
    endfunction
    function s__HeroAttackBasicAction_onStart takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_ATTACK_BASIC , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , (1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemSpeed)))) , tx , ty) // INLINED!!
        set p=null
    endfunction
    function s__HeroAttackBasicAction_onActionPoint takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real dmg= s__HeroAttackBasicAction_damageCalculation(this)
        call s__HeroAttackBasic_fire(s__HeroActionBase_u[this] , tx , ty , dmg , 0.02 , 1800. , 1400.)
        set p=null
    endfunction
    function s__HeroAttackBasicAction_create takes unit u returns integer
        local integer this= s__HeroAttackBasicAction__allocate(u , UI_ATTACK , "Icons\\v2\\PlasmaBolt.blp")
        return this
    endfunction
    function s__HeroAttackBasicAction_abilityText takes integer this returns string
        local string s= "Fires a plama bolt towards targeted unit or mouse pointer. |nDamage: " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) , STAT_INDEX_FIREPOWER) + ".|n" // INLINED!!
        set s=s + CNOTE + Si2Name(STAT_INDEX_FIREPOWER) + "-percent is increased by 1% per " + Si2Name(STAT_INDEX_SYSTEM_POWER)
        return s
    endfunction
    function s__HeroAttackBasicAction_abilityName takes integer this returns string
        return "[Q] Plasma Bolt"
    endfunction

    //method onBackswing takes nothing returns nothing
    //    call BJDebugMsg("backswing finished")
    //endmethod
    //method onCooldownFinished takes nothing returns nothing
    //    call BJDebugMsg("cooldown finished")
    //endmethod

    function s__HeroAttackRapidAction_dmgPercent takes integer this returns real
        return 1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) * 0.01 // INLINED!!
    endfunction
    function s__HeroAttackRapidAction_damageCalculation takes integer this returns real
        return (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) * GetDamage(s__HeroActionBase_u[this]) // INLINED!!
    endfunction

    function s__HeroAttackRapidAction_animationSpeed takes integer this returns real
        return 1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemSpeed))) // INLINED!!
    endfunction
    function s__HeroAttackRapidAction_updateAbilityDetails takes integer this returns nothing
        local real duration= 0.8 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] )) // INLINED!!
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.33 * duration , duration , duration * 1.25)
        set s__HeroActionBase_energyCost[this]=3.5
    endfunction
    function s__HeroAttackRapidAction_onStart takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_ATTACK_BASIC , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , (1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemSpeed)))) , tx , ty) // INLINED!!
        set p=null
    endfunction
    function s__HeroAttackRapidAction_onActionPoint takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real dmg= s__HeroAttackRapidAction_damageCalculation(this)
        call s__HeroAttackBasic_fire(s__HeroActionBase_u[this] , tx , ty , dmg , 0.02 , 1800. , 1400.)
        set p=null
    endfunction
    function s__HeroAttackRapidAction_create takes unit u returns integer
        local integer this= s__HeroAttackRapidAction__allocate(u , UI_ATTACK , "Icons\\v2\\PlasmaBolt.blp")
        return this
    endfunction
    function s__HeroAttackRapidAction_abilityText takes integer this returns string
        local string s= "Fires a plama bolt towards targeted unit or mouse pointer. |nDamage: " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) , STAT_INDEX_FIREPOWER) + ".|n" // INLINED!!
        set s=s + CNOTE + Si2Name(STAT_INDEX_FIREPOWER) + "-percent is increased by 1% per " + Si2Name(STAT_INDEX_SYSTEM_POWER)
        return s
    endfunction
    function s__HeroAttackRapidAction_abilityName takes integer this returns string
        return "[Q] Plasma Bolt"
    endfunction

    //method onBackswing takes nothing returns nothing
    //    call BJDebugMsg("backswing finished")
    //endmethod
    //method onCooldownFinished takes nothing returns nothing
    //    call BJDebugMsg("cooldown finished")
    //endmethod



    function s__HeroBasicBombAction_updateAbilityDetails takes integer this returns nothing
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.0 , 0.1 , 5.0 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] ))) // INLINED!!
        set s__HeroActionBase_energyCost[this]=12.0
    endfunction
    function s__HeroBasicBombAction_onStart takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real x= GetUnitX(s__HeroActionBase_u[this])
        local real y= GetUnitY(s__HeroActionBase_u[this])
        local real angle= Atan2(ty - y, tx - x)
        local real ux= x + 64. * Cos(angle)
        local real uy= y + 64. * Sin(angle)
        local unit bomb
        call updateWalkablePoint(ux , uy)
        set bomb=CreateUnit(p, BOMB_UNIT_TYPE, GetLocationX(walkablePoint), GetLocationY(walkablePoint), 0.0)
        call UnitApplyTimedLife(bomb, TIMED_LIFE, 2.0)
        //call UnitAddAbility(bomb,'Amrf')
        //call UnitRemoveAbility(bomb,'Amrf')
        //call SetUnitFlyHeight(bomb, 128., 99999.) 
        set bomb=null
        set p=null
    endfunction
    function s__HeroBasicBombAction_create takes unit u returns integer
        local integer this= s__HeroBasicBombAction__allocate(u , UI_UTIL1 , "Icons\\v2\\EnergyBomb.blp")
        return this
    endfunction
    function s__HeroBasicBombAction_destroyDestructable takes nothing returns nothing

    endfunction
    function s__HeroBasicBombAction_destroyDebrisInArea takes real x,real y returns nothing
        local real ux= x
        local real uy= y
        call SetRect(enumRect, ux - WALL_CHECK_RANGE, uy - WALL_CHECK_RANGE, ux + WALL_CHECK_RANGE, uy + WALL_CHECK_RANGE)
        call EnumDestructablesInRect(enumRect, null, function s__HeroBasicBombAction_destroyDestructable)
    endfunction
    function s__HeroBasicBombAction_getDamage takes unit u returns real
        return s__HeroBasicBombAction_baseDmg + s__HeroBasicBombAction_percentDmg * GetDamage(u) + s__HeroBasicBombAction_percentPower * (s__ExtendableBonus_Get((u ) , ( si__BonusSystemPower))) // INLINED!!
    endfunction
    
    function s__HeroBasicBombAction_abilityText takes integer this returns string
        local real dmg= s__HeroBasicBombAction_getDamage(s__HeroActionBase_u[this])
        local string s= "Places a bomb at your current location, exploding after 2 seconds, dealing damage and slowing in a 200 unit radius.|nDamage: " + (I2S(R2I(((dmg)*1.0) + 0.1))) + " (" + (I2S(R2I(((s__HeroBasicBombAction_baseDmg)*1.0) + 0.1))) + " + " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , s__HeroBasicBombAction_percentDmg , STAT_INDEX_FIREPOWER) // INLINED!!
        set s=s + " + " + ScalingText((s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) , s__HeroBasicBombAction_percentPower , STAT_INDEX_SYSTEM_POWER) + ").|nSlows: 40% for 1.5 seconds.|nThe bomb is able to destroy some webs, rocks and debries." // INLINED!!
        return s
    endfunction
    function s__HeroBasicBombAction_abilityName takes integer this returns string
        return "[E] Energy Bomb"
    endfunction

    function s__HeroBasicDash_percent takes integer this returns real
        return 1.1 + 0.005 * (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) // INLINED!!
    endfunction
    function s__HeroBasicDash_dashedDistance takes integer this returns real
        return (1.1 + 0.005 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower)))) * (GetUnitMoveSpeed((s__HeroActionBase_u[this]))) // INLINED!!
    endfunction
    function s__HeroBasicDash_updateAbilityDetails takes integer this returns nothing
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.320 , 0.360 , 2.5 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] ))) // INLINED!!
        set s__HeroActionBase_energyCost[this]=RMaxBJ(11.0 - R2I((s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) + 0.01) / 10, 3.) // INLINED!!
    endfunction
    function s__HeroBasicDash_dashSpeed takes integer this returns real
        return s__HeroBasicDash_dashedDistance(this) / s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]]
    endfunction
    function s__HeroBasicDash_onStart takes integer this returns nothing
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real ux= GetUnitX(s__HeroActionBase_u[this])
        local real uy= GetUnitY(s__HeroActionBase_u[this])
        local real angle= Atan2(ty - uy, tx - ux)
        //0.800 animation-time, we want total time to be somewhat shorter than that, lets go for 0.480s
        //Let the speed just increase the distance, not the animation-time
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_SPELL_SLAM , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , 1.25 , tx , ty)

        //set udg_Knockback2DTime = cooldownDetails.actionDuration
        //set udg_Knockback2DDistance = dashedDistance()
        //set udg_Knockback2DCollision = 8.00
        //set udg_Knockback2DAngle = Atan2(ty - uy, tx - ux) * bj_RADTODEG
        //set udg_Knockback2DUnit = u
        //set udg_Knockback2DLoopFX = ""
        //call ConditionalTriggerExecute( gg_trg_Knockback_2D )
        call s__KnockbackTZ_doKnockback(s__HeroActionBase_u[this] , angle , s__HeroBasicDash_dashSpeed(this) , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , 0. , 1. , 8.)

        if GetRandomInt(0, 1) == 1 then
            call playSound3d(ux , uy , SOUND_DASH1)
        else
            call playSound3d(ux , uy , SOUND_DASH2)
        endif

        set p=null
    endfunction
    function s__HeroBasicDash_create takes unit u returns integer
        local integer this= s__HeroBasicDash__allocate(u , UI_DASH , "Icons\\v2\\Dash.blp")
        set s__HeroActionBase_ignoreTarget[this]=true
        return this
    endfunction
    //method onActionPoint takes nothing returns nothing
    //endmethod
    //method onBackswing takes nothing returns nothing
    //    call BJDebugMsg("backswing finished")
    //endmethod
    //method onCooldownFinished takes nothing returns nothing
    //    call BJDebugMsg("cooldown finished")
    //endmethod
    function s__HeroBasicDash_abilityText takes integer this returns string
        local string s= "Dashes towards mouse pointer over 0.36 seconds. Dashed distance: " + ScalingText((GetUnitMoveSpeed((s__HeroActionBase_u[this]))) , (1.1 + 0.005 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower)))) , STAT_INDEX_MOBILITY) + ".|n" + CNOTE + Si2Name(STAT_INDEX_MOBILITY) + "-percent is increased by 0.5% per " // INLINED!!
        set s=s + Si2Name(STAT_INDEX_SYSTEM_POWER) + ", and " + Si2Color(STAT_INDEX_ENERGY) + "Energy-cost" + CNOTE + " reduced by 1 per 10 " + Si2Name(STAT_INDEX_SYSTEM_POWER) + " (minimum 3 Energy)"
        return s
    endfunction
    function s__HeroBasicDash_abilityName takes integer this returns string
        return "[D] Dash"
    endfunction


    function s__HeroShockBlast_boom takes integer this returns nothing
        local group g= CreateGroup()
        if s__HeroShockBlast_isEmpowered[this] then
            call damageAoENoFFWithResult((s__Missiles_source[this] ) , (( s__Missiles_x[this] )*1.0) , (( s__Missiles_y[this] )*1.0) , (( s__Missiles_damage[this] * 1.5 )*1.0) , (( 250. )*1.0) , ( DAMAGE_TYPE_LIGHTNING) , null) // INLINED!!
            call destroyDest2(s__Missiles_x[this] , s__Missiles_y[this] , 275.)
        else
            call damageAoENoFFWithResult((s__Missiles_source[this] ) , (( s__Missiles_x[this] )*1.0) , (( s__Missiles_y[this] )*1.0) , (( s__Missiles_damage[this] )*1.0) , (( 125. )*1.0) , ( DAMAGE_TYPE_LIGHTNING) , null) // INLINED!!
            call destroyDest1(s__Missiles_x[this] , s__Missiles_y[this] , 150.)
        endif
        call DestroyGroup(g)
        set g=null
    endfunction

    function s__HeroShockBlast_onFinish takes integer this returns boolean
        return true
    endfunction

    
    function s__HeroShockBlast_onHit takes integer this,unit hit returns boolean
        if BlzIsUnitSelectable(hit) and ( not IsUnitAlly(hit, s__Missiles_owner[this]) or GetPlayerId(GetOwningPlayer(hit)) == PLAYER_NEUTRAL_PASSIVE ) then
            //set udg_NextDamageType = udg_DamageTypeCode
            //call UnitDamageTarget(source, hit, damage, true, true, ATTACK_TYPE_HERO, DAMAGE_TYPE_NORMAL, null)
            call s__HeroShockBlast_boom(this)
            return true
        endif
        return false
    endfunction

    function s__HeroShockBlast_onDestructable takes integer this,destructable dest returns boolean
        if hitDest(dest , 1) or GetDestructableOccluderHeight(dest) > 50.0 and GetDestructableLife(dest) > 0. then
            
            return true
        else
            return false
        endif
    endfunction
    function s__HeroShockBlast_onTerrain takes integer this returns boolean
        return true
    endfunction
    function s__HeroShockBlast_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
    endfunction

    function s__HeroShockBlast_fireFrom takes unit u,real x,real y,real tx,real ty,real dmg,real spread,real distance,real speed returns nothing
        //local real     z = 100.
        local real angle= Atan2(ty - y, tx - x) + GetRandomReal(- spread, spread)
        local real tx2= x + distance * Cos(angle)
        local real ty2= y + distance * Sin(angle)
        local integer startCliff= GetTerrainCliffLevel(x, y)
        local integer endCliff= GetTerrainCliffLevel(tx2, ty2)
        local integer this= s__HeroShockBlast__allocate(x + 24. * Cos(angle) , y + 24. * Sin(angle) , 100. , tx2 , ty2 , 64. + 128. * ( startCliff - endCliff ))

        set s__Missiles_source[this]=u
        call s__Missiles__set_model(this,"Units\\Hero\\BeamMissile.mdx")
        call s__Missiles__set_speed(this,speed)
        set s__Missiles_collision[this]=26.
        set s__Missiles_damage[this]=dmg
        set s__Missiles_owner[this]=GetOwningPlayer(u)

        call s__Missiles_launch(this)
    endfunction


    function s__HeroShockBlast_fire takes unit u,real tx,real ty,real dmg,real spread,real distance,real speed returns nothing
        call s__HeroShockBlast_fireFrom(u , GetUnitX(u) , GetUnitY(u) , tx , ty , dmg , spread , distance , speed)
    endfunction

    function s__HeroShockBlast_fireAsHeroActionFire takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local integer index= (LoadInteger(TimerUtils__ht, 0, GetHandleId((t)))) // INLINED!!
        local unit u= udg_UDexUnits[index]
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((GetOwningPlayer(u))))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((GetOwningPlayer(u))))]) // INLINED!!
        local real dmg= GetDamage(u)

        call s__HeroShockBlast_fire(u , tx , ty , dmg , 0.02 , 1800. , 1400.)
        call ReleaseTimer(t)
        set u=null
        set t=null
    endfunction

//===========================================================================
// Trigger: Interaction
//===========================================================================

    function s__InteractAction_updateAbilityDetails takes integer this returns nothing
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.1 , 0.2 , 1.0)
    endfunction

    function s__InteractAction_onStart takes integer this returns nothing
        //TODO: Play a sound
    endfunction

    function s__InteractAction_processTerminalTogglable takes nothing returns nothing
        local destructable d= GetEnumDestructable()
        local string name= GetDestructableName(d)
        if strEndsWith(name , INTERACTION_TERMINAL_TOGGLABLE) then
            if GetDestructableLife(d) > 0 then
                call OpenDoor(d)
            else
                call CloseDoor(d)
            endif
        endif
    endfunction
    function s__InteractAction_toggleNearbyTerminalTogglable takes destructable dest returns nothing
        local real x= GetDestructableX(dest)
        local real y= GetDestructableY(dest)
        call SetRect(enumRect, x - INTERACT_TERMINAL_RANGE, y - INTERACT_TERMINAL_RANGE, x + INTERACT_TERMINAL_RANGE, y + INTERACT_TERMINAL_RANGE)
        call EnumDestructablesInRect(enumRect, null, function s__InteractAction_processTerminalTogglable)
    endfunction
    function s__InteractAction_processDestructable takes nothing returns nothing
        local destructable d= GetEnumDestructable()
        local string name= GetDestructableName(d)
        local integer len= StringLength(name)
        if SubString(name, len - 5, len) == INTERACTION_TOGGLEABLE then
            if GetDestructableLife(d) > 0 then
                call OpenDoor(d)
            else
                call CloseDoor(d)
            endif
        elseif strEndsWith(name , INTERACTION_TERMINAL) and GetDestructableLife(d) > 0. then
            call s__InteractAction_toggleNearbyTerminalTogglable(d)
        endif
        set d=null
    endfunction
    function s__InteractAction_onActionPoint takes integer this returns nothing
        local real x= GetUnitX(s__HeroActionBase_u[this])
        local real y= GetUnitY(s__HeroActionBase_u[this])
        call SetRect(enumRect, x - INTERACT_RANGE, y - INTERACT_RANGE, x + INTERACT_RANGE, y + INTERACT_RANGE)
        call EnumDestructablesInRect(enumRect, null, function s__InteractAction_processDestructable)
    endfunction
    function s__InteractAction_create takes unit u returns integer
        local integer this= s__InteractAction__allocate(u , UI_INTERACT , ICON_INTERACT)
        return this
    endfunction

    function s__InteractAction_abilityText takes integer this returns string
        return "Open or closes nearby smaller doors and interact with computers connected with cables."
    endfunction
    function s__InteractAction_abilityName takes integer this returns string
        return "[F] Interact"
    endfunction

//===========================================================================
// Trigger: EnemySpawnStartingArea
//===========================================================================
function Trig_EnemySpawnStartingArea_Func001Func008C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.60 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnStartingArea_Func001Func017Func001C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.60 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnStartingArea_Func001Func017C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.80 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnStartingArea_Func001C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.66 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnStartingArea_Func002C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.40 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnStartingArea_Actions takes nothing returns nothing
    if ( Trig_EnemySpawnStartingArea_Func001C() ) then
        call CreateNUnitsAtLoc(1, 'n001', Player(8), udg_t_loc1, GetRandomDirectionDeg())
        set udg_spawnedEnemiesHeat=( udg_spawnedEnemiesHeat + 8 )
        set udg_t_int2=( udg_t_int2 + 1 )
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=1
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        if ( Trig_EnemySpawnStartingArea_Func001Func017C() ) then
            if ( Trig_EnemySpawnStartingArea_Func001Func017Func001C() ) then
                // Patrol to player
                set udg_t_loc2=GetUnitLoc(GetEnumUnit())
                call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc2)
                call RemoveLocation(udg_t_loc2)
            else
                // Patrol to "point of interest"
                call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_enemyPatrolPoints[GetRandomInt(0, 3)])
            endif
        else
        endif
    else
        call CreateNUnitsAtLoc(1, 'n003', Player(8), udg_t_loc1, GetRandomDirectionDeg())
        set udg_spawnedEnemiesHeat=( udg_spawnedEnemiesHeat + 8 )
        set udg_t_int2=( udg_t_int2 + 1 )
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=1
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        if ( Trig_EnemySpawnStartingArea_Func001Func008C() ) then
            // Patrol to player
            set udg_t_loc2=GetUnitLoc(GetEnumUnit())
            call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc2)
            call RemoveLocation(udg_t_loc2)
        else
            // Patrol to "point of interest"
            call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_enemyPatrolPoints[GetRandomInt(0, 3)])
        endif
    endif
    if ( Trig_EnemySpawnStartingArea_Func002C() ) then
        call CreateNUnitsAtLoc(1, 'n001', Player(8), udg_t_loc1, GetRandomDirectionDeg())
        set udg_spawnedEnemiesHeat=( udg_spawnedEnemiesHeat + 8 )
        set udg_t_int2=( udg_t_int2 + 1 )
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=1
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        // Patrol to player
        set udg_t_loc2=GetUnitLoc(GetEnumUnit())
        call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc2)
        call RemoveLocation(udg_t_loc2)
    else
    endif
endfunction

//===========================================================================
function InitTrig_EnemySpawnStartingArea takes nothing returns nothing
    set gg_trg_EnemySpawnStartingArea=CreateTrigger()
    call TriggerAddAction(gg_trg_EnemySpawnStartingArea, function Trig_EnemySpawnStartingArea_Actions)
endfunction

//===========================================================================
// Trigger: EnemySpawnIceCavesArea
//===========================================================================
function Trig_EnemySpawnIceCavesArea_Func001Func008C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.50 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnIceCavesArea_Func001Func017Func001C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.60 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnIceCavesArea_Func001Func017C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.80 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnIceCavesArea_Func001C takes nothing returns boolean
    if ( not ( GetRandomReal(0, 1) <= 0.66 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawnIceCavesArea_Actions takes nothing returns nothing
    if ( Trig_EnemySpawnIceCavesArea_Func001C() ) then
        call CreateNUnitsAtLoc(1, 'n005', Player(10), udg_t_loc1, GetRandomDirectionDeg())
        set udg_spawnedEnemiesHeat=( udg_spawnedEnemiesHeat + 10 )
        set udg_t_int2=( udg_t_int2 + 1 )
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=4
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        if ( Trig_EnemySpawnIceCavesArea_Func001Func017C() ) then
            if ( Trig_EnemySpawnIceCavesArea_Func001Func017Func001C() ) then
                // Patrol to player
                set udg_t_loc2=GetUnitLoc(GetEnumUnit())
                call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc2)
                call RemoveLocation(udg_t_loc2)
            else
                // Patrol to "point of interest"
                call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_enemyPatrolPoints[GetRandomInt(10, 12)])
            endif
        else
        endif
    else
        set udg_spawnedEnemiesHeat=( udg_spawnedEnemiesHeat + 6 )
        call CreateNUnitsAtLoc(1, 'n006', Player(10), udg_t_loc1, GetRandomDirectionDeg())
        set udg_t_int2=( udg_t_int2 + 1 )
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=1
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        if ( Trig_EnemySpawnIceCavesArea_Func001Func008C() ) then
            // Patrol to player
            set udg_t_loc2=GetUnitLoc(GetEnumUnit())
            call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc2)
            call RemoveLocation(udg_t_loc2)
        else
            // Patrol to "point of interest"
            call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_enemyPatrolPoints[GetRandomInt(10, 12)])
        endif
    endif
endfunction

//===========================================================================
function InitTrig_EnemySpawnIceCavesArea takes nothing returns nothing
    set gg_trg_EnemySpawnIceCavesArea=CreateTrigger()
    call TriggerAddAction(gg_trg_EnemySpawnIceCavesArea, function Trig_EnemySpawnIceCavesArea_Actions)
endfunction

//===========================================================================
// Trigger: EnemySpawningMain
//
// t_int2 = enemies spawned this spawn-pass
// t_int1 = "open 32x32"-spaces near potential spawn-point, later "enemy power"
//===========================================================================
function Trig_EnemySpawningMain_Func002Func001Func002Func001Func004Func003Func001C takes nothing returns boolean
    if ( not ( RectContainsLoc(gg_rct_IceCaves, udg_t_loc1) == true ) ) then
        return false
    endif
    if ( not ( RectContainsLoc(gg_rct_Brood_Mother_Arena, udg_t_loc1) == false ) ) then
        return false
    endif
    if ( not ( CountUnitsInGroup(udg_t_group1) <= 3 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawningMain_Func002Func001Func002Func001Func004Func003C takes nothing returns boolean
    if ( not ( RectContainsLoc(gg_rct_ZombieSpawningArea, udg_t_loc1) == true ) ) then
        return false
    endif
    if ( not ( CountUnitsInGroup(udg_t_group1) <= 3 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawningMain_Func002Func001Func002Func001Func004C takes nothing returns boolean
    if ( not ( udg_t_int1 >= 6 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawningMain_Func002Func001Func002Func001C takes nothing returns boolean
    if ( not ( udg_t_int2 <= 4 ) ) then
        return false
    endif
    if ( not ( udg_spawnedEnemiesPower <= 30 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawningMain_Func002Func001A takes nothing returns nothing
    set udg_t_int2=0
    set bj_forLoopAIndex=0
    set bj_forLoopAIndexEnd=10
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        if ( Trig_EnemySpawningMain_Func002Func001Func002Func001C() ) then
            set udg_t_real1=GetUnitX(GetEnumUnit()) + GetRandomReal(1300., 2500)
            set udg_t_real2=GetUnitY(GetEnumUnit()) + GetRandomReal(1200., 2500)
            set udg_t_int1=walkablePointsIn(udg_t_real1 , udg_t_real2 , 3)
            if ( Trig_EnemySpawningMain_Func002Func001Func002Func001Func004C() ) then
                set udg_t_loc1=Location(udg_t_real1, udg_t_real2)
                set udg_t_group1=GetUnitsInRangeOfLocAll(300.00, udg_t_loc1)
                if ( Trig_EnemySpawningMain_Func002Func001Func002Func001Func004Func003C() ) then
                    call TriggerExecute(gg_trg_EnemySpawnStartingArea)
                else
                    if ( Trig_EnemySpawningMain_Func002Func001Func002Func001Func004Func003Func001C() ) then
                        call TriggerExecute(gg_trg_EnemySpawnIceCavesArea)
                    else
                    endif
                endif
                call DestroyGroup(udg_t_group1)
                call RemoveLocation(udg_t_loc1)
            else
            endif
        else
        endif
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
endfunction

function Trig_EnemySpawningMain_Func002C takes nothing returns boolean
    if ( not ( udg_spawnedEnemiesPower <= 45 ) ) then
        return false
    endif
    if ( not ( udg_spawnedEnemiesHeat <= 100 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemySpawningMain_Actions takes nothing returns nothing
    set udg_spawnedEnemiesHeat=IMaxBJ(0, ( udg_spawnedEnemiesHeat - 1 ))
    if ( Trig_EnemySpawningMain_Func002C() ) then
        call ForGroupBJ(udg_heroes_alive, function Trig_EnemySpawningMain_Func002Func001A)
    else
    endif
endfunction

//===========================================================================
function InitTrig_EnemySpawningMain takes nothing returns nothing
    set gg_trg_EnemySpawningMain=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_EnemySpawningMain, 3.00)
    call TriggerAddAction(gg_trg_EnemySpawningMain, function Trig_EnemySpawningMain_Actions)
endfunction

//===========================================================================
// Trigger: EnemyDespawnMain
//
// Checks 1 random "spawned unit" every X seconds, if all heroes are over Y distance away, despawn!
//===========================================================================
function Trig_EnemyDespawnMain_Func004Func002C takes nothing returns boolean
    if ( not ( DistanceBetweenPoints(udg_t_loc1, udg_t_loc2) >= 3000.00 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemyDespawnMain_Func004A takes nothing returns nothing
    set udg_t_loc2=GetUnitLoc(GetEnumUnit())
    if ( Trig_EnemyDespawnMain_Func004Func002C() ) then
        set udg_t_int1=( udg_t_int1 + 1 )
    else
    endif
    call RemoveLocation(udg_t_loc2)
endfunction

function Trig_EnemyDespawnMain_Func005C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_heroes_all) == udg_t_int1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemyDespawnMain_Actions takes nothing returns nothing
    set udg_t_unit1=GroupPickRandomUnit(udg_spawnedEnemies)
    set udg_t_int1=0
    set udg_t_loc1=GetUnitLoc(udg_t_unit1)
    call ForGroupBJ(udg_heroes_all, function Trig_EnemyDespawnMain_Func004A)
    if ( Trig_EnemyDespawnMain_Func005C() ) then
        set udg_spawnedEnemiesHeat=IMaxBJ(0, ( udg_spawnedEnemiesHeat - 1 ))
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower - udg_spawnedPowerArr[GetUnitUserData(udg_t_unit1)] )
        call GroupRemoveUnitSimple(udg_t_unit1, udg_spawnedEnemies)
        call RemoveUnit(udg_t_unit1)
    else
    endif
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_EnemyDespawnMain takes nothing returns nothing
    set gg_trg_EnemyDespawnMain=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_EnemyDespawnMain, 1.00)
    call TriggerAddAction(gg_trg_EnemyDespawnMain, function Trig_EnemyDespawnMain_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL jass
//===========================================================================



    function s__FinalBossHoming_onFinish takes integer this returns boolean
        return true
    endfunction

    
    function s__FinalBossHoming_onHit takes integer this,unit hit returns boolean
        if not IsUnitAlly(hit, s__Missiles_owner[this]) then
            //set udg_NextDamageType = udg_DamageTypeCode
            //call UnitDamageTarget(source, hit, damage, true, true, ATTACK_TYPE_HERO, DAMAGE_TYPE_NORMAL, null)
call s__Damage_apply((s__Missiles_source[this] ) , ( hit ) , (( s__Missiles_damage[this] )*1.0) , true , ( true ) , ( ATTACK_TYPE_HERO ) , DAMAGE_TYPE_NORMAL , ( WEAPON_TYPE_WHOKNOWS)) // INLINED!!
            return true
        endif
        return false
    endfunction

    function s__FinalBossHoming_onDestructable takes integer this,destructable dest returns boolean
        if GetDestructableOccluderHeight(dest) > 50.0 and GetDestructableLife(dest) > 0. then
            return true
        else
            return false
        endif
    endfunction
    function s__FinalBossHoming_onTerrain takes integer this returns boolean
        return true
    endfunction
    function s__FinalBossHoming_onTileset takes integer this,integer tileset returns boolean
        if tileset == 'cOc1' then
            return true
        endif
        return false
    endfunction

    function s__FinalBossHoming_fire takes boolean isLeft returns nothing
        local real x= GetUnitX(udg_bossUnit)
        local real y= GetUnitY(udg_bossUnit)
        local real bossFacing= GetUnitFacing(udg_bossUnit) * bj_DEGTORAD
        local unit target= (BlzGroupUnitAt(udg_heroes_all, GetRandomInt(0, BlzGroupGetSize(udg_heroes_all) - 1))) // INLINED!!
        local real tx= GetUnitX(target)
        local real ty= GetUnitY(target)
        local integer this
        if isLeft then
            set x=x + 44. * Cos(bossFacing + bj_PI / 2.) + 30. * Cos(bossFacing)
            set y=y + 44. * Sin(bossFacing + bj_PI / 2.) + 30. * Sin(bossFacing)
        else
            set x=x - 44. * Cos(bossFacing + bj_PI / 2.) + 30. * Cos(bossFacing)
            set y=y - 44. * Sin(bossFacing + bj_PI / 2.) + 30. * Sin(bossFacing)
        endif
        set this=s__FinalBossHoming__allocate(x , y , 128. , tx , ty , 32.)
//      
        set s__Missiles_source[this]=udg_bossUnit
        set s__Missiles_target[this]=target
        call s__Missiles__set_arc(this,GetRandomReal(14., 24.))
        call s__Missiles__set_curve(this,GetRandomReal(- 7., 7.))
        call s__Missiles__set_model(this,"Units\\Jab1z\\Mecha-Locust.mdx")
        call s__Missiles__set_speed(this,GetRandomReal(425., 500.))
        set s__Missiles_acceleration[this]=0.025
        set s__Missiles_collision[this]=26.
        set s__Missiles_turn[this]=0.022
        set s__Missiles_damage[this]=0.75 * GetDamage(udg_bossUnit)
        set s__Missiles_owner[this]=GetOwningPlayer(udg_bossUnit)
        
//
        call s__Missiles_launch(this)
    endfunction

    function s__FinalBossHoming_fireTick takes nothing returns nothing
        call s__FinalBossHoming_fire(true)
        call s__FinalBossHoming_fire(false)
        call ReleaseTimer(GetExpiredTimer())
    endfunction

    function s__FinalBossHoming_startFire takes nothing returns nothing
        call s__FinalBossHoming_fire(true)
        call s__FinalBossHoming_fire(false)
        //call TimerStart(NewTimer(), 0.2, false, function thistype.fireTick)
    endfunction

function MCLLightningUpdate takes nothing returns nothing
    local real bossX= GetUnitX(udg_bossUnit)
    local real bossY= GetUnitY(udg_bossUnit)
    //call BJDebugMsg("Update Start")
    if UnitAlive(udg_boss_MC_crystal_l) then
        call DestroyLightning(mcl_l_beam_to_boss)
        set mcl_l_beam_to_boss=AddLightningEx("GRSB", false, mcl_transmitter_l_x, mcl_transmitter_l_y, GetZ(mcl_transmitter_l_x , mcl_transmitter_l_y) + 220., bossX, bossY, GetZ(bossX , bossY) + 72.)
        //call BJDebugMsg("L Update")
    endif
    if UnitAlive(udg_boss_MC_crystal_r) then
        call DestroyLightning(mcl_r_beam_to_boss)
        set mcl_r_beam_to_boss=AddLightningEx("GRSB", false, mcl_transmitter_r_x, mcl_transmitter_r_y, GetZ(mcl_transmitter_r_x , mcl_transmitter_r_y) + 220., bossX, bossY, GetZ(bossX , bossY) + 72.)
        //call BJDebugMsg("R Update")
    endif
endfunction

function MCLFinalLightning takes nothing returns nothing
    local real bossX= GetUnitX(udg_bossUnit)
    local real bossY= GetUnitY(udg_bossUnit)
    local real x= GetRectCenterX(gg_rct_FinalBoss_Door)
    local real y= GetRectCenterY(gg_rct_FinalBoss_Door)
    local lightning finalLightning= AddLightningEx("GRSB", false, bossX, bossY, GetZ(bossX , bossY) + 64., x, y, GetZ(x , y) + 64.)
    call s__LightningDestroyer_destroyLater((finalLightning ) , (( 0.5)*1.0)) // INLINED!!
    set finalLightning=null
endfunction

function MCLSetupLightning takes nothing returns nothing
    local real bossX= GetUnitX(udg_bossUnit)
    local real bossY= GetUnitY(udg_bossUnit)
    set mcl_l_beam_static=AddLightningEx("GRSB", false, mcl_crystal_l_x, mcl_crystal_l_y, GetZ(mcl_crystal_l_x , mcl_crystal_l_y) + 40., mcl_transmitter_l_x, mcl_transmitter_l_y, GetZ(mcl_transmitter_l_x , mcl_transmitter_l_y) + 220.)
    set mcl_r_beam_static=AddLightningEx("GRSB", false, mcl_crystal_r_x, mcl_crystal_r_y, GetZ(mcl_crystal_r_x , mcl_crystal_r_y) + 40., mcl_transmitter_r_x, mcl_transmitter_r_y, GetZ(mcl_transmitter_r_x , mcl_transmitter_r_y) + 220.)
    set mcl_l_beam_to_boss=AddLightningEx("GRSB", false, mcl_transmitter_l_x, mcl_transmitter_l_y, GetZ(mcl_transmitter_l_x , mcl_transmitter_l_y) + 220., bossX, bossY, GetZ(bossX , bossY) + 72.)
    set mcl_r_beam_to_boss=AddLightningEx("GRSB", false, mcl_transmitter_r_x, mcl_transmitter_r_y, GetZ(mcl_transmitter_r_x , mcl_transmitter_r_y) + 220., bossX, bossY, GetZ(bossX , bossY) + 72.)
endfunction

function MCLConveyorLightning_Create takes nothing returns nothing
    local real y= GetRectCenterY(gg_rct_FinalBoss_ConveyorZap1_1)
    local real minX= GetRectMinX(gg_rct_FinalBoss_ConveyorZap1_1) + 10.
    local real maxX= GetRectMaxX(gg_rct_FinalBoss_ConveyorZap1_1) - 10.
    local real z= GetZ(minX , y) + 60.

    set mcl_conveyor_s=AddLightningEx("BLNL", true, minX, y, z, maxX, y, z)

    set y=GetRectCenterY(gg_rct_FinalBoss_ConveyorZap2_1)
    set mcl_conveyor_n=AddLightningEx("BLNL", true, minX, y, z, maxX, y, z)

    call StartSound(gg_snd_MCL_Lightning1)
endfunction
function MCLConveyorLightning_End takes nothing returns nothing
    call ReleaseTimer(mcl_conveyor_t)
    if mcl_conveyor_counter < 30 then
        call DestroyLightning(mcl_conveyor_s)
        call DestroyLightning(mcl_conveyor_n)
    endif
endfunction
function MCLConveyorDamage takes nothing returns nothing
    local group g= CreateGroup()
    call GroupEnumUnitsInRect(g, gg_rct_FinalBoss_ConveyorZap1_1, null)
    call damageGroup(g , udg_bossUnit , MCL_CONVEYOR_BEAM_DMG_BASE , DAMAGE_TYPE_LIGHTNING)
    set g=CreateGroup()
    call GroupEnumUnitsInRect(g, gg_rct_FinalBoss_ConveyorZap2_1, null)
    call damageGroup(g , udg_bossUnit , MCL_CONVEYOR_BEAM_DMG_BASE , DAMAGE_TYPE_LIGHTNING)
    set g=null
endfunction
function MCLConveyorLightning_Tick takes nothing returns nothing
    set mcl_conveyor_counter=mcl_conveyor_counter + 1
    if mcl_conveyor_counter < 31 then
        //Deal dmg
        call MCLConveyorDamage()
    elseif mcl_conveyor_counter == 31 then
        //Stop
        call DestroyLightning(mcl_conveyor_s)
        call DestroyLightning(mcl_conveyor_n)
    elseif mcl_conveyor_counter < 39 then
        //Nothing Pause
    else
        //"Restart"
        call MCLConveyorLightning_Create()
        set mcl_conveyor_counter=0
    endif
endfunction
function MCLConveyorLightning_Start takes nothing returns nothing
    set mcl_conveyor_t=(NewTimerEx(0)) // INLINED!!
    set mcl_conveyor_counter=999
    call TimerStart(mcl_conveyor_t, 0.05, true, function MCLConveyorLightning_Tick)
    
    call SetSoundPosition(gg_snd_MCL_Lightning1, GetRectCenterX(gg_rct_FinalBoss_ConveyorZap1_1), GetRectCenterY(gg_rct_FinalBoss_ConveyorZap1_1), 512.)
endfunction

function MCLSpawnSawBotBirthed takes nothing returns nothing
    local timer t= GetExpiredTimer()
    local unit u= udg_UDexUnits[(LoadInteger(TimerUtils__ht, 0, GetHandleId((t))))] // INLINED!!
    call ResetUnitAnimation(u)
    call PauseUnit(u, false)
    call ReleaseTimer(t)
    call AttackMoveTowardsRandomHero(u)
    set t=null
    set u=null
endfunction
function MCLSpawnSawBot takes real x,real y,real angle returns nothing
    local unit u= CreateUnit(GetOwningPlayer(udg_bossUnit), 'u002', x, y, angle)
    call PauseUnit(u, true)
    call SetUnitAnimation(u, "birth")
    call TimerStart(NewTimerEx(GetUnitUserData(u)), 1.07, false, function MCLSpawnSawBotBirthed)
    set u=null
endfunction
function MCLSpawnSawBotNearBoss takes nothing returns nothing
    local real bx= GetUnitX(udg_bossUnit)
    local real by= GetUnitY(udg_bossUnit)
    local real angle= GetRandomReal(0., 2. * bj_PI)
    local real distance= 160.
    local real tx= bx + Cos(angle) * distance
    local real ty= by + Sin(angle) * distance
    loop
        exitwhen IsWalkableWithCollisionSize(tx , ty , 16.)
        set angle=GetRandomReal(0., 2. * bj_PI)
        set distance=distance + 5.
        set tx=bx + Cos(angle) * distance
        set ty=by + Sin(angle) * distance
    endloop
    call MCLSpawnSawBot(tx , ty , angle)
endfunction

function MCLHeroDeath takes nothing returns nothing
    call DestroyLightning(mcl_l_beam_static)
    call DestroyLightning(mcl_r_beam_static)
    call DestroyLightning(mcl_l_beam_to_boss)
    call DestroyLightning(mcl_r_beam_to_boss)
    call MCLConveyorLightning_End()
endfunction

//===========================================================================
// Trigger: MechaCL StartForceEnter
//===========================================================================
function Trig_MechaCL_StartForceEnter_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h000' ) ) then
        return false
    endif
    if ( not ( udg_bossOngoing == false ) ) then
        return false
    endif
    if ( not ( udg_bossUnit == null ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func001A takes nothing returns nothing
endfunction

function Trig_MechaCL_StartForceEnter_Func026Func001C takes nothing returns boolean
    if ( not ( GetEnumUnit() != GetTriggerUnit() ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func026A takes nothing returns nothing
    if ( Trig_MechaCL_StartForceEnter_Func026Func001C() ) then
        set udg_t_loc1=GetRandomLocInRect(gg_rct_FinalBoss_CloseToEnter)
        call SetUnitPositionLocFacingBJ(GetEnumUnit(), udg_t_loc1, 90.00)
        call RemoveLocation(udg_t_loc1)
    else
    endif
endfunction

function Trig_MechaCL_StartForceEnter_Func045A takes nothing returns nothing
    call UnitShareVisionBJ(true, udg_boss_MC_transmitter_l, GetOwningPlayer(GetEnumUnit()))
    call UnitShareVisionBJ(true, udg_boss_MC_transmitter_r, GetOwningPlayer(GetEnumUnit()))
    call UnitShareVisionBJ(true, udg_bossUnit, GetOwningPlayer(GetEnumUnit()))
    call UnitShareVisionBJ(true, GetEnumUnit(), GetOwningPlayer(udg_bossUnit))
    set udg_t_loc1=GetRandomLocInRect(gg_rct_FinalBoss_Enterence)
    call IssuePointOrderLocBJ(GetEnumUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func012A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_FinalBoss_Spawn1, GetEnumPlayer(), 0)
    call SetCameraTargetControllerNoZForPlayer(GetEnumPlayer(), udg_bossUnit, 0, 0, false)
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func013C takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func014C takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func015C takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func019C takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func020C takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func046Func026A takes nothing returns nothing
    call ResetToGameCameraForPlayer(GetEnumPlayer(), 0)
    set udg_t_unit1=(s__MetroidvaniaController_u[((GetPlayerId(((GetEnumPlayer())))))]) // INLINED!!
    call SetCameraTargetControllerNoZForPlayer(GetEnumPlayer(), udg_t_unit1, 0, 0, false)
endfunction

function Trig_MechaCL_StartForceEnter_Func046C takes nothing returns boolean
    if ( not ( udg_boss_MC_status == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func070Func001C takes nothing returns boolean
    if ( not ( RectContainsUnit(gg_rct_FinalBoss_Main_Arena, GetEnumUnit()) == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_StartForceEnter_Func070A takes nothing returns nothing
    if ( Trig_MechaCL_StartForceEnter_Func070Func001C() ) then
        set udg_t_loc1=GetRandomLocInRect(gg_rct_FinalBoss_Enterence)
        call SetUnitPositionLocFacingBJ(GetEnumUnit(), udg_t_loc1, 90.00)
        call RemoveLocation(udg_t_loc1)
    else
    endif
endfunction

function Trig_MechaCL_StartForceEnter_Actions takes nothing returns nothing
    call ForForce(udg_human_players, function Trig_MechaCL_StartForceEnter_Func001A)
    set udg_boss_hero_deaths=0
    set udg_bossAICounter=0
    set udg_bossAIEnabled=true
    set udg_bossOngoing=true
    set udg_bossBool1=false
    set udg_bossInt1=0
    set udg_t_destructible1=gg_dest_B01B_2877
    call CloseDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_2875
    call CloseDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_2886
    call CloseDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_3404
    call CloseDoor(udg_t_destructible1)
    call DestructableRestoreLife(gg_dest_B025_1826, GetDestructableMaxLife(GetLastCreatedDestructable()), true)
    call DestructableRestoreLife(gg_dest_B025_3152, GetDestructableMaxLife(GetLastCreatedDestructable()), true)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Transmitter_L)
    call CreateNUnitsAtLoc(1, 'u000', Player(6), udg_t_loc1, bj_UNIT_FACING)
    set udg_boss_MC_transmitter_l=GetLastCreatedUnit()
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Transmitter_R)
    call CreateNUnitsAtLoc(1, 'u000', Player(6), udg_t_loc1, bj_UNIT_FACING)
    set udg_boss_MC_transmitter_r=GetLastCreatedUnit()
    call RemoveLocation(udg_t_loc1)
    call ForGroupBJ(udg_heroes_alive, function Trig_MechaCL_StartForceEnter_Func026A)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Spawn)
    call CreateNUnitsAtLoc(1, 'u001', Player(6), udg_t_loc1, 270.00)
    call RemoveLocation(udg_t_loc1)
    set udg_bossUnit=GetLastCreatedUnit()
call s__ExtendableBonus_Set((udg_bossUnit ) , ( si__BonusMovementSpeed ) , (( 160)*1.0)) // INLINED!!
    call ClearSelection() // INLINED!!
    call AddSpecialEffectTargetUnitBJ("chest mount", udg_bossUnit, "Vfx\\Vinz\\Ubershield Spring.mdx")
    call BlzSpecialEffectAddSubAnimation(GetLastCreatedEffectBJ(), SUBANIM_TYPE_MEDIUM)
    set udg_bossVfx1=GetLastCreatedEffectBJ()
    call MCLSetupLightning()
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_GreenCrystal_R)
    call CreateNUnitsAtLoc(1, 'n009', Player(6), udg_t_loc1, GetRandomDirectionDeg())
    set udg_boss_MC_crystal_r=GetLastCreatedUnit()
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_GreenCrystal_L)
    call CreateNUnitsAtLoc(1, 'n009', Player(6), udg_t_loc1, GetRandomDirectionDeg())
    set udg_boss_MC_crystal_l=GetLastCreatedUnit()
    call RemoveLocation(udg_t_loc1)
    call ForGroupBJ(udg_heroes_alive, function Trig_MechaCL_StartForceEnter_Func045A)
    if ( Trig_MechaCL_StartForceEnter_Func046C() ) then
        set udg_boss_MC_status=1
        set udg_cinematic=2
        call CinematicModeBJ(true, GetPlayersAll())
        call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUTIN, 1.00, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0, 0, 0, 0)
        call TriggerSleepAction(0.50)
        call KillDestructable(gg_dest_B020_3503)
        call setUiVisible(false)
        call ForForce(GetPlayersAll(), function Trig_MechaCL_StartForceEnter_Func046Func012A)
        if ( Trig_MechaCL_StartForceEnter_Func046Func013C() ) then
            call TransmissionFromUnitWithNameBJ(GetPlayersAll(), udg_bossUnit, "TRIGSTR_320", null, "TRIGSTR_321", bj_TIMETYPE_SET, 3.50, false)
            call TriggerSleepAction(1.00)
        else
        endif
        if ( Trig_MechaCL_StartForceEnter_Func046Func014C() ) then
            call TriggerSleepAction(1.00)
        else
        endif
        if ( Trig_MechaCL_StartForceEnter_Func046Func015C() ) then
            call TriggerSleepAction(1.50)
        else
        endif
        set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_WalkStart)
        call IssuePointOrderLocBJ(udg_bossUnit, "move", udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        if ( Trig_MechaCL_StartForceEnter_Func046Func019C() ) then
            call TransmissionFromUnitWithNameBJ(GetPlayersAll(), udg_bossUnit, "TRIGSTR_324", null, "TRIGSTR_325", bj_TIMETYPE_SET, 6.50, true)
        else
        endif
        if ( Trig_MechaCL_StartForceEnter_Func046Func020C() ) then
            call TransmissionFromUnitWithNameBJ(GetPlayersAll(), udg_bossUnit, "TRIGSTR_326", null, "TRIGSTR_327", bj_TIMETYPE_SET, 3.00, true)
        else
        endif
        call DestructableRestoreLife(gg_dest_B020_3503, GetDestructableMaxLife(GetLastCreatedDestructable()), true)
        call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUTIN, 1.00, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0, 0, 0, 0)
        call TriggerSleepAction(0.50)
        call setUiVisible(true)
        call CinematicModeBJ(false, GetPlayersAll())
        call ForForce(GetPlayersAll(), function Trig_MechaCL_StartForceEnter_Func046Func026A)
        set udg_cinematic=0
        set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_WalkStart)
        call SetUnitPositionLocFacingBJ(udg_bossUnit, udg_t_loc1, 270.00)
        call RemoveLocation(udg_t_loc1)
    else
        set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_WalkStart)
        call SetUnitPositionLocFacingBJ(udg_bossUnit, udg_t_loc1, 270.00)
        call RemoveLocation(udg_t_loc1)
        call TriggerSleepAction(1.00)
    endif
    set udg_t_destructible1=gg_dest_B01B_3096
    call DestructableRestoreLife(gg_dest_B020_3503, GetDestructableMaxLife(GetLastCreatedDestructable()), true)
    call CloseDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_3097
    call CloseDoor(udg_t_destructible1)
    call SelectUnit(s__MetroidvaniaController_u[(GetPlayerId(GetLocalPlayer()))], true) // INLINED!!
    call TriggerSleepAction(0.50)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Enterence)
    call IssuePointOrderLocBJ(udg_bossUnit, "attack", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call MCLConveyorLightning_Start()
    call EnableTrigger(gg_trg_MechaCL_OnCrystalDeath)
    call EnableTrigger(gg_trg_MechaCL_Death)
    call EnableTrigger(gg_trg_MechaCL_AI_Main)
    call EnableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_Call)
    call EnableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart)
    call EnableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish)
    call EnableTrigger(gg_trg_MechaCL_Missile_End)
    call EnableTrigger(gg_trg_MechaCL_Missile_FireFirstRound)
    call EnableTrigger(gg_trg_MechaCL_Missile_FireSecondRound)
    call EnableTrigger(gg_trg_MechaCL_OnDamageTaken)
    call EnableTrigger(gg_trg_MechaCL_OnDamageTaken_Message_Reset)
    call EnableTrigger(gg_trg_MechaCL_UpdateLightning)
    call ForGroupBJ(udg_heroes_alive, function Trig_MechaCL_StartForceEnter_Func070A)
endfunction

//===========================================================================
function InitTrig_MechaCL_StartForceEnter takes nothing returns nothing
    set gg_trg_MechaCL_StartForceEnter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_MechaCL_StartForceEnter, gg_rct_FinalBoss_CloseToEnter)
    call TriggerAddCondition(gg_trg_MechaCL_StartForceEnter, Condition(function Trig_MechaCL_StartForceEnter_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_StartForceEnter, function Trig_MechaCL_StartForceEnter_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL HeroDeath
//===========================================================================
function Trig_MechaCL_HeroDeath_Conditions takes nothing returns boolean
    if ( not ( udg_bossOngoing == true ) ) then
        return false
    endif
    if ( not ( udg_boss_MC_status > 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_HeroDeath_Func003Func003Func031Func001C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnumUnit()) == 'u002' ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_HeroDeath_Func003Func003Func031A takes nothing returns nothing
    if ( Trig_MechaCL_HeroDeath_Func003Func003Func031Func001C() ) then
        call UnitApplyTimedLifeBJ(1.00, 'BTLF', GetEnumUnit())
    else
    endif
endfunction

function Trig_MechaCL_HeroDeath_Func003Func003C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_heroes_all) == udg_boss_hero_deaths ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_HeroDeath_Func003C takes nothing returns boolean
    if ( not ( RectContainsLoc(gg_rct_FinalBoss_Full_Arena, udg_t_loc2) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_HeroDeath_Actions takes nothing returns nothing
    set udg_t_loc2=GetUnitLoc(udg_t_unit1)
    if ( Trig_MechaCL_HeroDeath_Func003C() ) then
        set udg_boss_hero_deaths=( udg_boss_hero_deaths + 1 )
        if ( Trig_MechaCL_HeroDeath_Func003Func003C() ) then
            call DisableTrigger(gg_trg_MechaCL_OnCrystalDeath)
            call DisableTrigger(gg_trg_MechaCL_OnDamageTaken)
            call DisableTrigger(gg_trg_MechaCL_Death)
            call DisableTrigger(gg_trg_MechaCL_AI_Main)
            call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_Call)
            call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart)
            call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish)
            call DisableTrigger(gg_trg_MechaCL_Missile_FireFirstRound)
            call DisableTrigger(gg_trg_MechaCL_Missile_FireSecondRound)
            call DisableTrigger(gg_trg_MechaCL_Missile_End)
            call DisableTrigger(gg_trg_MechaCL_UpdateLightning)
            set udg_boss_MC_status=1
            set udg_bossOngoing=false
            set udg_bossAIEnabled=false
            set udg_bossAICounter=0
            call RemoveLocation(udg_t_loc2)
            call MCLHeroDeath()
            call TriggerSleepAction(1.00)
            call DestroyEffectBJ(udg_bossVfx1)
            set udg_t_destructible1=gg_dest_B01B_3096
            call OpenDoor(udg_t_destructible1)
            set udg_t_destructible1=gg_dest_B01B_3097
            call OpenDoor(udg_t_destructible1)
            call RemoveUnit(udg_bossUnit)
            call RemoveUnit(udg_boss_MC_crystal_l)
            call RemoveUnit(udg_boss_MC_crystal_r)
            call RemoveUnit(udg_boss_MC_transmitter_l)
            call RemoveUnit(udg_boss_MC_transmitter_r)
            set udg_bossUnit=null
            set udg_t_group1=GetUnitsInRectAll(gg_rct_FinalBoss_Full_Arena)
            call ForGroupBJ(udg_t_group1, function Trig_MechaCL_HeroDeath_Func003Func003Func031A)
            call DestroyGroup(udg_t_group1)
        else
        endif
    else
        call RemoveLocation(udg_t_loc2)
    endif
endfunction

//===========================================================================
function InitTrig_MechaCL_HeroDeath takes nothing returns nothing
    set gg_trg_MechaCL_HeroDeath=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_MechaCL_HeroDeath, "udg_onHeroDeathEvent", EQUAL, 1.00)
    call TriggerAddCondition(gg_trg_MechaCL_HeroDeath, Condition(function Trig_MechaCL_HeroDeath_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_HeroDeath, function Trig_MechaCL_HeroDeath_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL SkipCinematic
//===========================================================================
function Trig_MechaCL_SkipCinematic_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_SkipCinematic_Actions takes nothing returns nothing
    set udg_cinematic=0
endfunction

//===========================================================================
function InitTrig_MechaCL_SkipCinematic takes nothing returns nothing
    set gg_trg_MechaCL_SkipCinematic=CreateTrigger()
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_MechaCL_SkipCinematic, Player(0))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_MechaCL_SkipCinematic, Player(1))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_MechaCL_SkipCinematic, Player(2))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_MechaCL_SkipCinematic, Player(3))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_MechaCL_SkipCinematic, Player(4))
    call TriggerAddCondition(gg_trg_MechaCL_SkipCinematic, Condition(function Trig_MechaCL_SkipCinematic_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_SkipCinematic, function Trig_MechaCL_SkipCinematic_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL OnDamageTaken
//
// When crystals are alive, take 1 damage
//===========================================================================
function Trig_MechaCL_OnDamageTaken_Conditions takes nothing returns boolean
    if ( not ( udg_DamageEventTarget == udg_bossUnit ) ) then
        return false
    endif
    if ( not ( udg_bossInt1 < 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnDamageTaken_Func002Func004C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnDamageTaken_Func002C takes nothing returns boolean
    if ( not ( udg_bossBool1 == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnDamageTaken_Actions takes nothing returns nothing
    set udg_DamageEventAmount=1.00
    if ( Trig_MechaCL_OnDamageTaken_Func002C() ) then
        set udg_bossBool1=true
        call StartTimerBJ(udg_bossTimer2, false, 14.00)
        set udg_t_loc1=GetUnitLoc(udg_bossUnit)
        if ( Trig_MechaCL_OnDamageTaken_Func002Func004C() ) then
            set udg_t_string1="Your attacks are useless!"
        else
            set udg_t_string1="You can't hurt me!"
        endif
        call CreateTextTagLocBJ(udg_t_string1, udg_t_loc1, 128.00, 8.00, 40.00, 75.00, 60.00, 0)
        call RemoveLocation(udg_t_loc1)
        call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 24.00, 90)
        call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
        call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 3.00)
        call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 2.25)
    else
    endif
endfunction

//===========================================================================
function InitTrig_MechaCL_OnDamageTaken takes nothing returns nothing
    set gg_trg_MechaCL_OnDamageTaken=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_OnDamageTaken)
    call h__TriggerRegisterVariableEvent(gg_trg_MechaCL_OnDamageTaken, "udg_DamageModifierEvent", EQUAL, 0)
    call TriggerAddCondition(gg_trg_MechaCL_OnDamageTaken, Condition(function Trig_MechaCL_OnDamageTaken_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_OnDamageTaken, function Trig_MechaCL_OnDamageTaken_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL OnDamageTaken Message Reset
//===========================================================================
function Trig_MechaCL_OnDamageTaken_Message_Reset_Actions takes nothing returns nothing
    set udg_bossBool1=false
endfunction

//===========================================================================
function InitTrig_MechaCL_OnDamageTaken_Message_Reset takes nothing returns nothing
    set gg_trg_MechaCL_OnDamageTaken_Message_Reset=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_OnDamageTaken_Message_Reset)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_OnDamageTaken_Message_Reset, udg_bossTimer2)
    call TriggerAddAction(gg_trg_MechaCL_OnDamageTaken_Message_Reset, function Trig_MechaCL_OnDamageTaken_Message_Reset_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL UpdateLightning
//===========================================================================
function Trig_MechaCL_UpdateLightning_Actions takes nothing returns nothing
    call MCLLightningUpdate()
endfunction

//===========================================================================
function InitTrig_MechaCL_UpdateLightning takes nothing returns nothing
    set gg_trg_MechaCL_UpdateLightning=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_UpdateLightning)
    call TriggerRegisterTimerEventPeriodic(gg_trg_MechaCL_UpdateLightning, 0.03)
    call TriggerAddAction(gg_trg_MechaCL_UpdateLightning, function Trig_MechaCL_UpdateLightning_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Death
//===========================================================================
function Trig_MechaCL_Death_Conditions takes nothing returns boolean
    if ( not ( GetTriggerUnit() == udg_bossUnit ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Death_Actions takes nothing returns nothing
    set udg_boss_MC_status=10
    set udg_bossOngoing=false
    set udg_bossAIEnabled=false
    call DestroyEffectBJ(udg_bossVfx1)
    call MCLFinalLightning()
    call MCLConveyorLightning_End()
    call KillDestructable(gg_dest_B020_3503)
    call DisableTrigger(gg_trg_MechaCL_OnCrystalDeath)
    call DisableTrigger(gg_trg_MechaCL_OnDamageTaken)
    call DisableTrigger(gg_trg_MechaCL_OnDamageTaken_Message_Reset)
    call DisableTrigger(gg_trg_MechaCL_Death)
    call DisableTrigger(gg_trg_MechaCL_AI_Main)
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_Call)
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart)
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish)
    call DisableTrigger(gg_trg_MechaCL_Missile_FireFirstRound)
    call DisableTrigger(gg_trg_MechaCL_Missile_FireSecondRound)
    call DisableTrigger(gg_trg_MechaCL_Missile_End)
    call DisableTrigger(gg_trg_MechaCL_UpdateLightning)
endfunction

//===========================================================================
function InitTrig_MechaCL_Death takes nothing returns nothing
    set gg_trg_MechaCL_Death=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_Death)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_MechaCL_Death, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_MechaCL_Death, Condition(function Trig_MechaCL_Death_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Death, function Trig_MechaCL_Death_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Hero EnterConveyorArea
//===========================================================================
function Trig_MechaCL_Hero_EnterConveyorArea_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Hero_EnterConveyorArea_Actions takes nothing returns nothing
    set udg_t_int1=( ( GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit())) * 100 ) + 0 )
    call FogModifierStart(udg_g_visModArr[udg_t_int1])
endfunction

//===========================================================================
function InitTrig_MechaCL_Hero_EnterConveyorArea takes nothing returns nothing
    set gg_trg_MechaCL_Hero_EnterConveyorArea=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_MechaCL_Hero_EnterConveyorArea, gg_rct_FinalBoss_Conveyor_Enterence)
    call TriggerRegisterEnterRectSimple(gg_trg_MechaCL_Hero_EnterConveyorArea, gg_rct_FinalBoss_Conveyor_Enterence)
    call TriggerAddCondition(gg_trg_MechaCL_Hero_EnterConveyorArea, Condition(function Trig_MechaCL_Hero_EnterConveyorArea_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Hero_EnterConveyorArea, function Trig_MechaCL_Hero_EnterConveyorArea_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Hero LeaveConveyorArea
//===========================================================================
function Trig_MechaCL_Hero_LeaveConveyorArea_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Hero_LeaveConveyorArea_Actions takes nothing returns nothing
    set udg_t_int1=( ( GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit())) * 100 ) + 0 )
    call FogModifierStop(udg_g_visModArr[udg_t_int1])
endfunction

//===========================================================================
function InitTrig_MechaCL_Hero_LeaveConveyorArea takes nothing returns nothing
    set gg_trg_MechaCL_Hero_LeaveConveyorArea=CreateTrigger()
    call TriggerRegisterLeaveRectSimple(gg_trg_MechaCL_Hero_LeaveConveyorArea, gg_rct_FinalBoss_Conveyor_Corridor)
    call TriggerAddCondition(gg_trg_MechaCL_Hero_LeaveConveyorArea, Condition(function Trig_MechaCL_Hero_LeaveConveyorArea_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Hero_LeaveConveyorArea, function Trig_MechaCL_Hero_LeaveConveyorArea_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL AI Main
//===========================================================================
function Trig_MechaCL_AI_Main_Conditions takes nothing returns boolean
    if ( not ( udg_bossAIEnabled == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Main_Func002Func001C takes nothing returns boolean
    if ( not ( 0 == GetRandomInt(0, 1) ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Main_Func002C takes nothing returns boolean
    if ( not ( udg_bossAICounter > GetRandomInt(13, 20) ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Main_Actions takes nothing returns nothing
    set udg_bossAICounter=( udg_bossAICounter + 1 )
    if ( Trig_MechaCL_AI_Main_Func002C() ) then
        if ( Trig_MechaCL_AI_Main_Func002Func001C() ) then
            call TriggerExecute(gg_trg_MechaCL_AI_Spawn_SawBot_Start)
        else
            call TriggerExecute(gg_trg_MechaCL_Missile_StartAnim)
        endif
    else
    endif
endfunction

//===========================================================================
function InitTrig_MechaCL_AI_Main takes nothing returns nothing
    set gg_trg_MechaCL_AI_Main=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_AI_Main)
    call TriggerRegisterTimerEventPeriodic(gg_trg_MechaCL_AI_Main, 1.00)
    call TriggerAddCondition(gg_trg_MechaCL_AI_Main, Condition(function Trig_MechaCL_AI_Main_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_AI_Main, function Trig_MechaCL_AI_Main_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Missile StartAnim
//===========================================================================
function Trig_MechaCL_Missile_StartAnim_Actions takes nothing returns nothing
    set udg_bossAIEnabled=false
    set udg_bossAICounter=201
    call PauseUnitBJ(true, udg_bossUnit)
    call SetUnitAnimation(udg_bossUnit, "spell two")
    call QueueUnitAnimationBJ(udg_bossUnit, "spell two")
    call StartTimerBJ(udg_bossTimer1, false, 0.80)
endfunction

//===========================================================================
function InitTrig_MechaCL_Missile_StartAnim takes nothing returns nothing
    set gg_trg_MechaCL_Missile_StartAnim=CreateTrigger()
    call TriggerAddAction(gg_trg_MechaCL_Missile_StartAnim, function Trig_MechaCL_Missile_StartAnim_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Missile FireFirstRound
//===========================================================================
function Trig_MechaCL_Missile_FireFirstRound_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 201 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Missile_FireFirstRound_Actions takes nothing returns nothing
    call s__FinalBossHoming_startFire()
    call TriggerSleepAction(0.00)
    set udg_bossAICounter=202
    call StartTimerBJ(udg_bossTimer1, false, 1.20)
endfunction

//===========================================================================
function InitTrig_MechaCL_Missile_FireFirstRound takes nothing returns nothing
    set gg_trg_MechaCL_Missile_FireFirstRound=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_Missile_FireFirstRound)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_Missile_FireFirstRound, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_Missile_FireFirstRound, Condition(function Trig_MechaCL_Missile_FireFirstRound_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Missile_FireFirstRound, function Trig_MechaCL_Missile_FireFirstRound_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Missile FireSecondRound
//===========================================================================
function Trig_MechaCL_Missile_FireSecondRound_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 202 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Missile_FireSecondRound_Actions takes nothing returns nothing
    call s__FinalBossHoming_startFire()
    call TriggerSleepAction(0.00)
    set udg_bossAICounter=203
    call StartTimerBJ(udg_bossTimer1, false, 0.60)
endfunction

//===========================================================================
function InitTrig_MechaCL_Missile_FireSecondRound takes nothing returns nothing
    set gg_trg_MechaCL_Missile_FireSecondRound=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_Missile_FireSecondRound)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_Missile_FireSecondRound, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_Missile_FireSecondRound, Condition(function Trig_MechaCL_Missile_FireSecondRound_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Missile_FireSecondRound, function Trig_MechaCL_Missile_FireSecondRound_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL Missile End
//===========================================================================
function Trig_MechaCL_Missile_End_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 203 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_Missile_End_Actions takes nothing returns nothing
    set udg_bossAICounter=4
    set udg_bossAIEnabled=true
    call PauseUnitBJ(false, udg_bossUnit)
    call ResetUnitAnimation(udg_bossUnit)
    call AttackMoveTowardsRandomHero(udg_bossUnit)
endfunction

//===========================================================================
function InitTrig_MechaCL_Missile_End takes nothing returns nothing
    set gg_trg_MechaCL_Missile_End=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_Missile_End)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_Missile_End, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_Missile_End, Condition(function Trig_MechaCL_Missile_End_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_Missile_End, function Trig_MechaCL_Missile_End_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL AI Spawn SawBot Start
//===========================================================================
function Trig_MechaCL_AI_Spawn_SawBot_Start_Actions takes nothing returns nothing
    set udg_bossAIEnabled=false
    set udg_bossAICounter=101
    call PauseUnitBJ(true, udg_bossUnit)
    call SetUnitAnimation(udg_bossUnit, "stand channel")
    call StartTimerBJ(udg_bossTimer1, false, 1.25)
endfunction

//===========================================================================
function InitTrig_MechaCL_AI_Spawn_SawBot_Start takes nothing returns nothing
    set gg_trg_MechaCL_AI_Spawn_SawBot_Start=CreateTrigger()
    call TriggerAddAction(gg_trg_MechaCL_AI_Spawn_SawBot_Start, function Trig_MechaCL_AI_Spawn_SawBot_Start_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL AI Spawn SawBot Call
//===========================================================================
function Trig_MechaCL_AI_Spawn_SawBot_Call_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 101 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Spawn_SawBot_Call_Actions takes nothing returns nothing
    set udg_t_loc1=GetUnitLoc(udg_bossUnit)
    call CreateTextTagLocBJ("TRIGSTR_352", udg_t_loc1, 128.00, 8.00, 40.00, 75.00, 60.00, 0)
    call RemoveLocation(udg_t_loc1)
    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 24.00, 90)
    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 3.00)
    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 2.25)
    call TriggerSleepAction(0.00)
    set udg_bossAICounter=102
    call StartTimerBJ(udg_bossTimer1, false, 1.50)
endfunction

//===========================================================================
function InitTrig_MechaCL_AI_Spawn_SawBot_Call takes nothing returns nothing
    set gg_trg_MechaCL_AI_Spawn_SawBot_Call=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_Call)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_AI_Spawn_SawBot_Call, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_AI_Spawn_SawBot_Call, Condition(function Trig_MechaCL_AI_Spawn_SawBot_Call_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_AI_Spawn_SawBot_Call, function Trig_MechaCL_AI_Spawn_SawBot_Call_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL AI Spawn SawBot SpawnStart
//===========================================================================
function Trig_MechaCL_AI_Spawn_SawBot_SpawnStart_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 102 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Spawn_SawBot_SpawnStart_Actions takes nothing returns nothing
    call MCLSpawnSawBotNearBoss()
    call TriggerSleepAction(0.00)
    set udg_bossAICounter=103
    call StartTimerBJ(udg_bossTimer1, false, 0.50)
endfunction

//===========================================================================
function InitTrig_MechaCL_AI_Spawn_SawBot_SpawnStart takes nothing returns nothing
    set gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart, Condition(function Trig_MechaCL_AI_Spawn_SawBot_SpawnStart_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnStart, function Trig_MechaCL_AI_Spawn_SawBot_SpawnStart_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL AI Spawn SawBot SpawnFinish
//===========================================================================
function Trig_MechaCL_AI_Spawn_SawBot_SpawnFinish_Conditions takes nothing returns boolean
    if ( not ( udg_bossAICounter == 103 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_AI_Spawn_SawBot_SpawnFinish_Actions takes nothing returns nothing
    set udg_bossAICounter=0
    set udg_bossAIEnabled=true
    call PauseUnitBJ(false, udg_bossUnit)
    call ResetUnitAnimation(udg_bossUnit)
    call AttackMoveTowardsRandomHero(udg_bossUnit)
endfunction

//===========================================================================
function InitTrig_MechaCL_AI_Spawn_SawBot_SpawnFinish takes nothing returns nothing
    set gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish)
    call TriggerRegisterTimerExpireEventBJ(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish, udg_bossTimer1)
    call TriggerAddCondition(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish, Condition(function Trig_MechaCL_AI_Spawn_SawBot_SpawnFinish_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_AI_Spawn_SawBot_SpawnFinish, function Trig_MechaCL_AI_Spawn_SawBot_SpawnFinish_Actions)
endfunction

//===========================================================================
// Trigger: MechaCL OnCrystalDeath
//===========================================================================
function Trig_MechaCL_OnCrystalDeath_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n009' ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnCrystalDeath_Func001C takes nothing returns boolean
    if ( not ( GetTriggerUnit() == udg_boss_MC_crystal_l ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnCrystalDeath_Func002C takes nothing returns boolean
    if ( not ( GetTriggerUnit() == udg_boss_MC_crystal_r ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnCrystalDeath_Func003Func001C takes nothing returns boolean
    if ( not ( udg_bossInt1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnCrystalDeath_Func003C takes nothing returns boolean
    if ( not ( udg_bossInt1 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCL_OnCrystalDeath_Actions takes nothing returns nothing
    if ( Trig_MechaCL_OnCrystalDeath_Func001C() ) then
        call DestroyLightning(mcl_l_beam_static)
        call DestroyLightning(mcl_l_beam_to_boss)
        set udg_bossInt1=( udg_bossInt1 + 1 )
        call KillUnit(udg_boss_MC_transmitter_l)
    else
    endif
    if ( Trig_MechaCL_OnCrystalDeath_Func002C() ) then
        call DestroyLightning(mcl_r_beam_static)
        call DestroyLightning(mcl_r_beam_to_boss)
        set udg_t_destructible1=gg_dest_B01B_2886
        call OpenDoor(udg_t_destructible1)
        set udg_t_destructible1=gg_dest_B01B_3404
        call OpenDoor(udg_t_destructible1)
        set udg_bossInt1=( udg_bossInt1 + 1 )
        call KillUnit(udg_boss_MC_transmitter_r)
    else
    endif
    if ( Trig_MechaCL_OnCrystalDeath_Func003C() ) then
        call DestroyEffectBJ(udg_bossVfx1)
call s__ExtendableBonus_Set((udg_bossUnit ) , ( si__BonusMovementSpeed ) , (( 269)*1.0)) // INLINED!!
        set udg_t_loc1=GetUnitLoc(udg_bossUnit)
        call CreateTextTagLocBJ("TRIGSTR_356", udg_t_loc1, 128.00, 8.00, 40.00, 75.00, 60.00, 0)
        call RemoveLocation(udg_t_loc1)
        call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 24.00, 90)
        call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
        call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 4.00)
        call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 3.25)
    else
        if ( Trig_MechaCL_OnCrystalDeath_Func003Func001C() ) then
            set udg_t_loc1=GetUnitLoc(udg_bossUnit)
            call CreateTextTagLocBJ("TRIGSTR_357", udg_t_loc1, 128.00, 8.00, 40.00, 75.00, 60.00, 0)
            call RemoveLocation(udg_t_loc1)
            call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 24.00, 90)
            call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
            call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 4.00)
            call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 3.25)
        else
        endif
    endif
endfunction

//===========================================================================
function InitTrig_MechaCL_OnCrystalDeath takes nothing returns nothing
    set gg_trg_MechaCL_OnCrystalDeath=CreateTrigger()
    call DisableTrigger(gg_trg_MechaCL_OnCrystalDeath)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_MechaCL_OnCrystalDeath, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_MechaCL_OnCrystalDeath, Condition(function Trig_MechaCL_OnCrystalDeath_Conditions))
    call TriggerAddAction(gg_trg_MechaCL_OnCrystalDeath, function Trig_MechaCL_OnCrystalDeath_Actions)
endfunction

//===========================================================================
// Trigger: MechaCLOnFanDeath
//===========================================================================
function Trig_MechaCLOnFanDeath_Conditions takes nothing returns boolean
    if ( not ( IsDestructableDeadBJ(gg_dest_B025_1826) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableDeadBJ(gg_dest_B025_3152) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_MechaCLOnFanDeath_Actions takes nothing returns nothing
    set udg_t_destructible1=gg_dest_B01B_2877
    call OpenDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_2875
    call OpenDoor(udg_t_destructible1)
endfunction

//===========================================================================
function InitTrig_MechaCLOnFanDeath takes nothing returns nothing
    set gg_trg_MechaCLOnFanDeath=CreateTrigger()
    call TriggerRegisterDeathEvent(gg_trg_MechaCLOnFanDeath, gg_dest_B025_1826)
    call TriggerRegisterDeathEvent(gg_trg_MechaCLOnFanDeath, gg_dest_B025_3152)
    call TriggerAddCondition(gg_trg_MechaCLOnFanDeath, Condition(function Trig_MechaCLOnFanDeath_Conditions))
    call TriggerAddAction(gg_trg_MechaCLOnFanDeath, function Trig_MechaCLOnFanDeath_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother Spawn
//===========================================================================
function Trig_BroodMother_Spawn_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h000' ) ) then
        return false
    endif
    if ( not ( udg_boss_BM_status == 0 ) ) then
        return false
    endif
    if ( not ( udg_bossOngoing == false ) ) then
        return false
    endif
    if ( not ( udg_bossUnit == null ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_Spawn_Func010Func001C takes nothing returns boolean
    if ( not ( RectContainsUnit(gg_rct_Brood_Mother_Arena, GetEnumUnit()) == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_Spawn_Func010A takes nothing returns nothing
    if ( Trig_BroodMother_Spawn_Func010Func001C() ) then
        call SetUnitPositionLocFacingBJ(GetEnumUnit(), udg_t_loc1, 45.00)
    else
    endif
endfunction

function Trig_BroodMother_Spawn_Actions takes nothing returns nothing
    set udg_boss_BM_status=1
    set udg_boss_hero_deaths=0
    set udg_bossAICounter=0
    set udg_bossAIEnabled=true
    set udg_bossOngoing=true
    set udg_t_loc1=GetRectCenter(gg_rct_Brood_Mother_Entrence_Block1)
    call CreateDestructableLoc('B01Y', udg_t_loc1, 200.00, 1.85, 0)
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_Brood_Mother_TP_Others)
    call ForGroupBJ(udg_heroes_alive, function Trig_BroodMother_Spawn_Func010A)
    call RemoveLocation(udg_t_loc1)
    call TriggerSleepAction(2)
    set udg_t_loc1=GetRectCenter(gg_rct_Brood_Mother_Spawn)
    call CreateNUnitsAtLoc(1, 'n004', Player(10), udg_t_loc1, 180.00)
    call RemoveLocation(udg_t_loc1)
    set udg_bossUnit=GetLastCreatedUnit()
    call SetUnitAnimation(udg_bossUnit, "birth")
    call PauseUnitBJ(true, udg_bossUnit)
    call TriggerSleepAction(0.95)
    call ResetUnitAnimation(udg_bossUnit)
    call PauseUnitBJ(false, udg_bossUnit)
    set udg_t_loc1=GetRectCenter(gg_rct_Brood_Mother_TP_Others)
    call IssuePointOrderLocBJ(udg_bossUnit, "attack", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call EnableTrigger(gg_trg_BroodMother_AI)
    call EnableTrigger(gg_trg_BroodMother_Death)
endfunction

//===========================================================================
function InitTrig_BroodMother_Spawn takes nothing returns nothing
    set gg_trg_BroodMother_Spawn=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_BroodMother_Spawn, gg_rct_Brood_Mother_StartBattle)
    call TriggerAddCondition(gg_trg_BroodMother_Spawn, Condition(function Trig_BroodMother_Spawn_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_Spawn, function Trig_BroodMother_Spawn_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother Death
//===========================================================================
function Trig_BroodMother_Death_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n004' ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_Death_Func011A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_Death_Actions takes nothing returns nothing
    set udg_boss_BM_status=10
    set udg_bossOngoing=false
    set udg_bossUnit=null
    call DisableTrigger(gg_trg_BroodMother_Death)
    call DisableTrigger(gg_trg_BroodMother_HeroDeath)
    call DisableTrigger(gg_trg_BroodMother_Spawn)
    call DisableTrigger(gg_trg_BroodMother_AI)
    call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnCast)
    call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnEggDeath)
    call TriggerSleepAction(2.00)
    call EnumDestructablesInRectAll(gg_rct_Brood_Mother_Reward_Block, function Trig_BroodMother_Death_Func011A)
endfunction

//===========================================================================
function InitTrig_BroodMother_Death takes nothing returns nothing
    set gg_trg_BroodMother_Death=CreateTrigger()
    call DisableTrigger(gg_trg_BroodMother_Death)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_BroodMother_Death, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_BroodMother_Death, Condition(function Trig_BroodMother_Death_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_Death, function Trig_BroodMother_Death_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother RewardEnter
//===========================================================================
function Trig_BroodMother_RewardEnter_Func003A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_RewardEnter_Func004A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_RewardEnter_Func005A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_RewardEnter_Actions takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call EnumDestructablesInRectAll(gg_rct_Brood_Mother_Entrence_Block1, function Trig_BroodMother_RewardEnter_Func003A)
    call EnumDestructablesInRectAll(gg_rct_Brood_Mother_Entrence_Block2, function Trig_BroodMother_RewardEnter_Func004A)
    call EnumDestructablesInRectAll(gg_rct_Brood_Mother_North_Doors, function Trig_BroodMother_RewardEnter_Func005A)
endfunction

//===========================================================================
function InitTrig_BroodMother_RewardEnter takes nothing returns nothing
    set gg_trg_BroodMother_RewardEnter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_BroodMother_RewardEnter, gg_rct_Brood_Mother_Reward)
    call TriggerAddAction(gg_trg_BroodMother_RewardEnter, function Trig_BroodMother_RewardEnter_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother HeroDeath
//===========================================================================
function Trig_BroodMother_HeroDeath_Conditions takes nothing returns boolean
    if ( not ( udg_bossOngoing == true ) ) then
        return false
    endif
    if ( not ( udg_boss_BM_status > 0 ) ) then
        return false
    endif
    if ( not ( udg_boss_BM_status != 10 ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_HeroDeath_Func003Func002Func003A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_HeroDeath_Func003Func002Func004A takes nothing returns nothing
    call KillDestructable(GetEnumDestructable())
endfunction

function Trig_BroodMother_HeroDeath_Func003Func002Func011Func001C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnumUnit()) == 'n006' ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_HeroDeath_Func003Func002Func011A takes nothing returns nothing
    if ( Trig_BroodMother_HeroDeath_Func003Func002Func011Func001C() ) then
        call UnitApplyTimedLifeBJ(7.00, 'BTLF', GetEnumUnit())
    else
    endif
endfunction

function Trig_BroodMother_HeroDeath_Func003Func002C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_heroes_all) == udg_boss_hero_deaths ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_HeroDeath_Func003C takes nothing returns boolean
    if ( not ( RectContainsLoc(gg_rct_Brood_Mother_Arena, udg_t_loc2) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_HeroDeath_Actions takes nothing returns nothing
    set udg_t_loc2=GetUnitLoc(udg_t_unit1)
    if ( Trig_BroodMother_HeroDeath_Func003C() ) then
        set udg_boss_hero_deaths=( udg_boss_hero_deaths + 1 )
        if ( Trig_BroodMother_HeroDeath_Func003Func002C() ) then
            set udg_boss_BM_status=0
            call DisableTrigger(gg_trg_BroodMother_AI)
            call EnumDestructablesInRectAll(gg_rct_Brood_Mother_Entrence_Block1, function Trig_BroodMother_HeroDeath_Func003Func002Func003A)
            call EnumDestructablesInRectAll(gg_rct_Brood_Mother_Entrence_Block2, function Trig_BroodMother_HeroDeath_Func003Func002Func004A)
            call RemoveUnit(udg_bossUnit)
            set udg_bossUnit=null
            set udg_bossOngoing=false
            call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnCast)
            call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnEggDeath)
            set udg_t_group1=GetUnitsInRectAll(gg_rct_Brood_Mother_Arena)
            call ForGroupBJ(udg_t_group1, function Trig_BroodMother_HeroDeath_Func003Func002Func011A)
            call DestroyGroup(udg_t_group1)
        else
        endif
    else
    endif
    call RemoveLocation(udg_t_loc2)
endfunction

//===========================================================================
function InitTrig_BroodMother_HeroDeath takes nothing returns nothing
    set gg_trg_BroodMother_HeroDeath=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_BroodMother_HeroDeath, "udg_onHeroDeathEvent", EQUAL, 1.00)
    call TriggerAddCondition(gg_trg_BroodMother_HeroDeath, Condition(function Trig_BroodMother_HeroDeath_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_HeroDeath, function Trig_BroodMother_HeroDeath_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother AI LayEgg
//===========================================================================
function Trig_BroodMother_AI_LayEgg_Actions takes nothing returns nothing
    set udg_bossAICounter=0
    set udg_bossAIEnabled=false
    set udg_t_loc1=GetRectCenter(udg_bossRegions[GetRandomInt(0, 5)])
    call IssuePointOrderLocBJ(udg_bossUnit, "farsight", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call EnableTrigger(gg_trg_BroodMother_AI_LayEgg_OnCast)
endfunction

//===========================================================================
function InitTrig_BroodMother_AI_LayEgg takes nothing returns nothing
    set gg_trg_BroodMother_AI_LayEgg=CreateTrigger()
    call TriggerAddAction(gg_trg_BroodMother_AI_LayEgg, function Trig_BroodMother_AI_LayEgg_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother AI LayEgg OnCast
//===========================================================================
function Trig_BroodMother_AI_LayEgg_OnCast_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A006' ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_AI_LayEgg_OnCast_Actions takes nothing returns nothing
    set udg_bossAIEnabled=true
    set udg_t_loc1=GetSpellTargetLoc()
    call CreateNUnitsAtLoc(1, 'n007', GetOwningPlayer(GetTriggerUnit()), udg_t_loc1, GetRandomDirectionDeg())
    call RemoveLocation(udg_t_loc1)
    call UnitApplyTimedLifeBJ(10.25, 'BTLF', GetLastCreatedUnit())
    call EnableTrigger(gg_trg_BroodMother_AI_LayEgg_OnEggDeath)
    call TriggerSleepAction(1.50)
    set udg_t_loc1=GetRectCenter(gg_rct_Brood_Mother_StartBattle)
    call IssuePointOrderLocBJ(udg_bossUnit, "patrol", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_BroodMother_AI_LayEgg_OnCast takes nothing returns nothing
    set gg_trg_BroodMother_AI_LayEgg_OnCast=CreateTrigger()
    call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnCast)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_BroodMother_AI_LayEgg_OnCast, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_BroodMother_AI_LayEgg_OnCast, Condition(function Trig_BroodMother_AI_LayEgg_OnCast_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_AI_LayEgg_OnCast, function Trig_BroodMother_AI_LayEgg_OnCast_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother AI LayEgg OnEggDeath
//===========================================================================
function Trig_BroodMother_AI_LayEgg_OnEggDeath_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n007' ) ) then
        return false
    endif
    if ( not ( GetUnitStateSwap(UNIT_STATE_MANA, GetTriggerUnit()) >= 9.75 ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_AI_LayEgg_OnEggDeath_Actions takes nothing returns nothing
    set udg_t_int1=0
    set udg_t_int1=1
    loop
        exitwhen udg_t_int1 > GetRandomInt(2, 3)
        set udg_t_loc1=GetUnitLoc(GetDyingUnit())
        call CreateNUnitsAtLoc(1, 'n006', GetOwningPlayer(GetTriggerUnit()), udg_t_loc1, GetRandomDirectionDeg())
        call RemoveLocation(udg_t_loc1)
        set udg_t_loc1=GetRandomLocInRect(gg_rct_Brood_Mother_StartBattle)
        call IssuePointOrderLocBJ(GetLastCreatedUnit(), "patrol", udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int1=udg_t_int1 + 1
    endloop
endfunction

//===========================================================================
function InitTrig_BroodMother_AI_LayEgg_OnEggDeath takes nothing returns nothing
    set gg_trg_BroodMother_AI_LayEgg_OnEggDeath=CreateTrigger()
    call DisableTrigger(gg_trg_BroodMother_AI_LayEgg_OnEggDeath)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_BroodMother_AI_LayEgg_OnEggDeath, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_BroodMother_AI_LayEgg_OnEggDeath, Condition(function Trig_BroodMother_AI_LayEgg_OnEggDeath_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_AI_LayEgg_OnEggDeath, function Trig_BroodMother_AI_LayEgg_OnEggDeath_Actions)
endfunction

//===========================================================================
// Trigger: BroodMother AI
//===========================================================================
function Trig_BroodMother_AI_Conditions takes nothing returns boolean
    if ( not ( udg_bossAIEnabled == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_AI_Func003C takes nothing returns boolean
    if ( not ( udg_bossAICounter >= GetRandomInt(6, 10) ) ) then
        return false
    endif
    return true
endfunction

function Trig_BroodMother_AI_Actions takes nothing returns nothing
    set udg_bossAICounter=( udg_bossAICounter + 1 )
    if ( Trig_BroodMother_AI_Func003C() ) then
        call TriggerExecute(gg_trg_BroodMother_AI_LayEgg)
    else
    endif
endfunction

//===========================================================================
function InitTrig_BroodMother_AI takes nothing returns nothing
    set gg_trg_BroodMother_AI=CreateTrigger()
    call DisableTrigger(gg_trg_BroodMother_AI)
    call TriggerRegisterTimerEventPeriodic(gg_trg_BroodMother_AI, 1.00)
    call TriggerAddCondition(gg_trg_BroodMother_AI, Condition(function Trig_BroodMother_AI_Conditions))
    call TriggerAddAction(gg_trg_BroodMother_AI, function Trig_BroodMother_AI_Actions)
endfunction

//===========================================================================
// Trigger: EnemyKill
//===========================================================================
function Trig_EnemyKill_Conditions takes nothing returns boolean
    if ( not ( IsUnitEnemy(GetDyingUnit(), Player(9)) == true ) ) then
        return false
    endif
    if ( not ( IsUnitAlly(GetKillingUnitBJ(), Player(9)) == true ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetKillingUnitBJ()) != Player(9) ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemyKill_Func004C takes nothing returns boolean
    if ( not ( udg_spawnedEnemiesPower < 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_EnemyKill_Actions takes nothing returns nothing
    set udg_t_unittype1=GetUnitTypeId(GetDyingUnit())
    if (HaveSavedInteger(Table__ht, (coreDropGrowT), (udg_t_unittype1))) then // INLINED!!
    set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower - udg_spawnedPowerArr[GetUnitUserData(GetDyingUnit())] )
    if ( Trig_EnemyKill_Func004C() ) then
        set udg_spawnedEnemiesPower=0
    else
    endif
    call GroupRemoveUnitSimple(GetDyingUnit(), udg_spawnedEnemies)
    call SaveInteger(Table__ht, (enemyKillsT), (udg_t_unittype1), ( (LoadInteger(Table__ht, (enemyKillsT), (udg_t_unittype1))) + 1)) // INLINED!!
    call SaveInteger(Table__ht, (coreKillsToNextDropT), (udg_t_unittype1), ( (LoadInteger(Table__ht, (coreKillsToNextDropT), (udg_t_unittype1))) - 1)) // INLINED!!
    //call BJDebugMsg("Kills: " + I2S(enemyKillsT[udg_t_unittype1]) + ", coresDropped=" + I2S(coreDropT[udg_t_unittype1]) + ", req=" + I2S(coreDropKillsRequiredT[udg_t_unittype1]) + ", max=" + I2S(coreMaxDropT[udg_t_unittype1]))
    if (LoadInteger(Table__ht, (coreKillsToNextDropT), (udg_t_unittype1))) <= 0 then // INLINED!!
    call SaveInteger(Table__ht, (coreDropKillsRequiredT), (udg_t_unittype1), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (udg_t_unittype1))) + (LoadInteger(Table__ht, (coreDropGrowT), (udg_t_unittype1))))) // INLINED!!
    call SaveInteger(Table__ht, (coreKillsToNextDropT), (udg_t_unittype1), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (udg_t_unittype1))))) // INLINED!!
    set udg_t_loc1=GetUnitLoc(GetDyingUnit())
    call CreateItemLoc('I001', udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    endif
    endif
endfunction

//===========================================================================
function InitTrig_EnemyKill takes nothing returns nothing
    set gg_trg_EnemyKill=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_EnemyKill, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_EnemyKill, Condition(function Trig_EnemyKill_Conditions))
    call TriggerAddAction(gg_trg_EnemyKill, function Trig_EnemyKill_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorNorthEnter
//===========================================================================
function Trig_ConveyorNorthEnter_Actions takes nothing returns nothing
    call GroupAddUnitSimple(GetTriggerUnit(), udg_conveyorNorthGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorNorthEnter takes nothing returns nothing
    set gg_trg_ConveyorNorthEnter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_ConveyorNorthEnter, gg_rct_FinalBoss_Conveyor_Upper_Upwards_1)
    call TriggerRegisterEnterRectSimple(gg_trg_ConveyorNorthEnter, gg_rct_FinalBoss_Conveyor_Upper_Upwards_2)
    call TriggerAddAction(gg_trg_ConveyorNorthEnter, function Trig_ConveyorNorthEnter_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorNorthLeave
//===========================================================================
function Trig_ConveyorNorthLeave_Actions takes nothing returns nothing
    call GroupRemoveUnitSimple(GetTriggerUnit(), udg_conveyorNorthGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorNorthLeave takes nothing returns nothing
    set gg_trg_ConveyorNorthLeave=CreateTrigger()
    call TriggerRegisterLeaveRectSimple(gg_trg_ConveyorNorthLeave, gg_rct_FinalBoss_Conveyor_Upper_Upwards_1)
    call TriggerRegisterLeaveRectSimple(gg_trg_ConveyorNorthLeave, gg_rct_FinalBoss_Conveyor_Upper_Upwards_2)
    call TriggerAddAction(gg_trg_ConveyorNorthLeave, function Trig_ConveyorNorthLeave_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorEastEnter
//===========================================================================
function Trig_ConveyorEastEnter_Actions takes nothing returns nothing
    call GroupAddUnitSimple(GetTriggerUnit(), udg_conveyorEastGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorEastEnter takes nothing returns nothing
    set gg_trg_ConveyorEastEnter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_ConveyorEastEnter, gg_rct_FinalBoss_Conveyor_Lower_Right_1)
    call TriggerAddAction(gg_trg_ConveyorEastEnter, function Trig_ConveyorEastEnter_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorEastLeave
//===========================================================================
function Trig_ConveyorEastLeave_Actions takes nothing returns nothing
    call GroupRemoveUnitSimple(GetTriggerUnit(), udg_conveyorEastGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorEastLeave takes nothing returns nothing
    set gg_trg_ConveyorEastLeave=CreateTrigger()
    call TriggerRegisterLeaveRectSimple(gg_trg_ConveyorEastLeave, gg_rct_FinalBoss_Conveyor_Lower_Right_1)
    call TriggerAddAction(gg_trg_ConveyorEastLeave, function Trig_ConveyorEastLeave_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorWestEnter
//===========================================================================
function Trig_ConveyorWestEnter_Actions takes nothing returns nothing
    call GroupAddUnitSimple(GetTriggerUnit(), udg_conveyorWestGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorWestEnter takes nothing returns nothing
    set gg_trg_ConveyorWestEnter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_ConveyorWestEnter, gg_rct_FinalBoss_Conveyor_Upper_Left_1)
    call TriggerRegisterEnterRectSimple(gg_trg_ConveyorWestEnter, gg_rct_FinalBoss_Conveyor_Upper_Left_2)
    call TriggerAddAction(gg_trg_ConveyorWestEnter, function Trig_ConveyorWestEnter_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorWestLeave
//===========================================================================
function Trig_ConveyorWestLeave_Actions takes nothing returns nothing
    call GroupRemoveUnitSimple(GetTriggerUnit(), udg_conveyorWestGroup)
endfunction

//===========================================================================
function InitTrig_ConveyorWestLeave takes nothing returns nothing
    set gg_trg_ConveyorWestLeave=CreateTrigger()
    call TriggerRegisterLeaveRectSimple(gg_trg_ConveyorWestLeave, gg_rct_FinalBoss_Conveyor_Upper_Left_1)
    call TriggerRegisterLeaveRectSimple(gg_trg_ConveyorWestLeave, gg_rct_FinalBoss_Conveyor_Upper_Left_2)
    call TriggerAddAction(gg_trg_ConveyorWestLeave, function Trig_ConveyorWestLeave_Actions)
endfunction

//===========================================================================
// Trigger: ConveyorTick
//===========================================================================
function Trig_ConveyorTick_Func002A takes nothing returns nothing
    set udg_t_unit1=GetEnumUnit()
    call SetUnitY(udg_t_unit1, GetUnitY(udg_t_unit1) + CONVEYOR_SPEED)
endfunction

function Trig_ConveyorTick_Func003A takes nothing returns nothing
    set udg_t_unit1=GetEnumUnit()
    call SetUnitX(udg_t_unit1, GetUnitX(udg_t_unit1) + CONVEYOR_SPEED)
endfunction

function Trig_ConveyorTick_Func004A takes nothing returns nothing
    set udg_t_unit1=GetEnumUnit()
    call SetUnitY(udg_t_unit1, GetUnitY(udg_t_unit1) - CONVEYOR_SPEED)
endfunction

function Trig_ConveyorTick_Func005A takes nothing returns nothing
    set udg_t_unit1=GetEnumUnit()
    call SetUnitX(udg_t_unit1, GetUnitX(udg_t_unit1) - CONVEYOR_SPEED)
endfunction

function Trig_ConveyorTick_Actions takes nothing returns nothing
    call ForGroupBJ(udg_conveyorNorthGroup, function Trig_ConveyorTick_Func002A)
    call ForGroupBJ(udg_conveyorEastGroup, function Trig_ConveyorTick_Func003A)
    call ForGroupBJ(udg_conveyorSouthGroup, function Trig_ConveyorTick_Func004A)
    call ForGroupBJ(udg_conveyorWestGroup, function Trig_ConveyorTick_Func005A)
endfunction

//===========================================================================
function InitTrig_ConveyorTick takes nothing returns nothing
    set gg_trg_ConveyorTick=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_ConveyorTick, 0.03)
    call TriggerAddAction(gg_trg_ConveyorTick, function Trig_ConveyorTick_Actions)
endfunction

//===========================================================================
// Trigger: FinalBossCrystalsInit
//===========================================================================
function Trig_FinalBossCrystalsInit_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Conveyor_Lower_Downwards_1)
    call CreateNUnitsAtLoc(1, 'n008', Player(PLAYER_NEUTRAL_PASSIVE), udg_t_loc1, GetRandomDirectionDeg())
    call GroupAddUnitSimple(GetLastCreatedUnit(), udg_conveyorNorthGroup)
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_Conveyor_Lower_Right_1)
    call CreateNUnitsAtLoc(1, 'n008', Player(PLAYER_NEUTRAL_PASSIVE), udg_t_loc1, GetRandomDirectionDeg())
    call GroupAddUnitSimple(GetLastCreatedUnit(), udg_conveyorNorthGroup)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_FinalBossCrystalsInit takes nothing returns nothing
    set gg_trg_FinalBossCrystalsInit=CreateTrigger()
    call TriggerAddAction(gg_trg_FinalBossCrystalsInit, function Trig_FinalBossCrystalsInit_Actions)
endfunction

//===========================================================================
// Trigger: TP To final boss
//===========================================================================
function Trig_TP_To_final_boss_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_FinalBoss_TP)
    call SetUnitPositionLocFacingBJ(GetTriggerUnit(), udg_t_loc1, 90.00)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_TP_To_final_boss takes nothing returns nothing
    set gg_trg_TP_To_final_boss=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_TP_To_final_boss, gg_rct_Ehhm_TP)
    call TriggerAddAction(gg_trg_TP_To_final_boss, function Trig_TP_To_final_boss_Actions)
endfunction

//===========================================================================
// Trigger: OilBarrel
//===========================================================================
function Trig_OilBarrel_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_OilBarrel_Actions takes nothing returns nothing
    local unit killer= GetKillingUnit()
    call TriggerSleepAction(0.10)
    call damageAoEWithResult((killer ) , (( GetUnitX(GetTriggerUnit()) )*1.0) , (( GetUnitY(GetTriggerUnit()) )*1.0) , (( 62. )*1.0) , (( 200. )*1.0) , ( DAMAGE_TYPE_DEMOLITION) , null) // INLINED!!
    call destroyDest1(GetUnitX(GetTriggerUnit()) , GetUnitY(GetTriggerUnit()) , 225.)
    set killer=null
endfunction

//===========================================================================
function InitTrig_OilBarrel takes nothing returns nothing
    set gg_trg_OilBarrel=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_OilBarrel, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_OilBarrel, Condition(function Trig_OilBarrel_Conditions))
    call TriggerAddAction(gg_trg_OilBarrel, function Trig_OilBarrel_Actions)
endfunction

//===========================================================================
// Trigger: InitializeDebug
//
// Will turn on debug mode if map is launched from World Editor (i.e. Player 1 name is "WorldEditDev").
//===========================================================================
function Trig_InitializeDebug_Func002C takes nothing returns boolean
    if ( not ( GetPlayerName(Player(0)) == "WorldEditDev" ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitializeDebug_Actions takes nothing returns nothing
    if ( Trig_InitializeDebug_Func002C() ) then
        set udg_is_testing=true
        call TriggerExecute(gg_trg_InitializeDebugTriggers)
    else
        set udg_is_testing=false
        call ConditionalTriggerExecute(gg_trg_RemoveDebugTriggers)
    endif
    call TriggerExecute(gg_trg_MapInit)
    call DestroyTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_InitializeDebug takes nothing returns nothing
    set gg_trg_InitializeDebug=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_InitializeDebug, "udg_UnitIndexEvent", EQUAL, - 1.00)
    call TriggerAddAction(gg_trg_InitializeDebug, function Trig_InitializeDebug_Actions)
endfunction

//===========================================================================
// Trigger: InitializeDebugTriggers
//===========================================================================
function Trig_InitializeDebugTriggers_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitTrig_InitializeDebugTriggers takes nothing returns nothing
    set gg_trg_InitializeDebugTriggers=CreateTrigger()
    call TriggerAddAction(gg_trg_InitializeDebugTriggers, function Trig_InitializeDebugTriggers_Actions)
endfunction

//===========================================================================
// Trigger: RemoveDebugTriggers
//===========================================================================
function Trig_RemoveDebugTriggers_Actions takes nothing returns nothing
    call DestroyTrigger(gg_trg_ChatKill)
endfunction

//===========================================================================
function InitTrig_RemoveDebugTriggers takes nothing returns nothing
    set gg_trg_RemoveDebugTriggers=CreateTrigger()
    call TriggerAddAction(gg_trg_RemoveDebugTriggers, function Trig_RemoveDebugTriggers_Actions)
endfunction

//===========================================================================
// Trigger: ChatKill
//
// -kill
// Kills all selected units.
//===========================================================================
function Trig_ChatKill_Func002A takes nothing returns nothing
    call KillUnit(GetEnumUnit())
endfunction

function Trig_ChatKill_Actions takes nothing returns nothing
    set udg_t_group1=GetUnitsSelectedAll(Player(0))
    call ForGroupBJ(udg_t_group1, function Trig_ChatKill_Func002A)
    call DestroyGroup(udg_t_group1)
endfunction

//===========================================================================
function InitTrig_ChatKill takes nothing returns nothing
    set gg_trg_ChatKill=CreateTrigger()
    call TriggerRegisterPlayerChatEvent(gg_trg_ChatKill, Player(0), "-kill", false)
    call TriggerAddAction(gg_trg_ChatKill, function Trig_ChatKill_Actions)
endfunction

//===========================================================================
// Trigger: HintExitSpawnArea
//===========================================================================
function Trig_HintExitSpawnArea_Func012002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012Func011002002 takes nothing returns boolean
    return ( IsUnitType(GetFilterUnit(), UNIT_TYPE_HERO) == true )
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013Func012Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013Func012C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Func013C takes nothing returns boolean
    if ( not ( CountUnitsInGroup(udg_t_group1) == 0 ) ) then
        return false
    endif
    if ( not ( IsTriggerEnabled(gg_trg_HintOpenDoors) == true ) ) then
        return false
    endif
    if ( not ( IsDestructableAliveBJ(gg_dest_B01B_0357) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_HintExitSpawnArea_Actions takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call DisplayTextToForce(GetPlayersAll(), "TRIGSTR_225")
    call TriggerSleepAction(1.00)
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
    call CreateTextTagLocBJ("TRIGSTR_358", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
    call RemoveLocation(udg_t_loc1)
    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
    call TriggerSleepAction(4.25)
    set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func012002002))
    if ( Trig_HintExitSpawnArea_Func013C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
        call CreateTextTagLocBJ("TRIGSTR_372", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
        call RemoveLocation(udg_t_loc1)
        call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
        call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
        call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
        call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
        call DestroyGroup(udg_t_group1)
        call TriggerSleepAction(4.25)
        set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func011002002))
        if ( Trig_HintExitSpawnArea_Func013Func012C() ) then
            set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
            call CreateTextTagLocBJ("TRIGSTR_373", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
            call RemoveLocation(udg_t_loc1)
            call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
            call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
            call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
            call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
            call DestroyGroup(udg_t_group1)
            call TriggerSleepAction(4.25)
            set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func012Func011002002))
            if ( Trig_HintExitSpawnArea_Func013Func012Func012C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
                call CreateTextTagLocBJ("TRIGSTR_374", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
                call RemoveLocation(udg_t_loc1)
                call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
                call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
                call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
                call DestroyGroup(udg_t_group1)
                call TriggerSleepAction(4.25)
                set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func012Func012Func011002002))
                if ( Trig_HintExitSpawnArea_Func013Func012Func012Func012C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
                    call CreateTextTagLocBJ("TRIGSTR_375", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
                    call RemoveLocation(udg_t_loc1)
                    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
                    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
                    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
                    call DestroyGroup(udg_t_group1)
                    call TriggerSleepAction(4.25)
                    set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func011002002))
                    if ( Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
                        call CreateTextTagLocBJ("TRIGSTR_376", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
                        call RemoveLocation(udg_t_loc1)
                        call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
                        call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                        call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
                        call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
                        call DestroyGroup(udg_t_group1)
                        call TriggerSleepAction(4.25)
                        set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func011002002))
                        if ( Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
                            call CreateTextTagLocBJ("TRIGSTR_377", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
                            call RemoveLocation(udg_t_loc1)
                            call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
                            call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                            call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
                            call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
                            call DestroyGroup(udg_t_group1)
                            call TriggerSleepAction(4.25)
                            set udg_t_group1=GetUnitsInRectMatching(gg_rct_StartRoom_UtilityRoom, Condition(function Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012Func011002002))
                            if ( Trig_HintExitSpawnArea_Func013Func012Func012Func012Func012Func012Func012C() ) then
                                set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
                                call CreateTextTagLocBJ("TRIGSTR_378", udg_t_loc1, 72.00, 8.00, 30.00, 50.00, 75.00, 0)
                                call RemoveLocation(udg_t_loc1)
                                call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 20.00, 90)
                                call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                                call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 5.00)
                                call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 4.00)
                                call DestroyGroup(udg_t_group1)
                            else
                                call DestroyGroup(udg_t_group1)
                            endif
                        else
                            call DestroyGroup(udg_t_group1)
                        endif
                    else
                        call DestroyGroup(udg_t_group1)
                    endif
                else
                    call DestroyGroup(udg_t_group1)
                endif
            else
                call DestroyGroup(udg_t_group1)
            endif
        else
            call DestroyGroup(udg_t_group1)
        endif
    else
        call DestroyGroup(udg_t_group1)
    endif
endfunction

//===========================================================================
function InitTrig_HintExitSpawnArea takes nothing returns nothing
    set gg_trg_HintExitSpawnArea=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_HintExitSpawnArea, gg_rct_ExitingSpawnArea)
    call TriggerAddAction(gg_trg_HintExitSpawnArea, function Trig_HintExitSpawnArea_Actions)
endfunction

//===========================================================================
// Trigger: HintOpenDoors
//===========================================================================
function Trig_HintOpenDoors_Actions takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call DisplayTextToForce(GetPlayersAll(), "TRIGSTR_224")
endfunction

//===========================================================================
function InitTrig_HintOpenDoors takes nothing returns nothing
    set gg_trg_HintOpenDoors=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_HintOpenDoors, gg_rct_OpenDoorHint)
    call TriggerAddAction(gg_trg_HintOpenDoors, function Trig_HintOpenDoors_Actions)
endfunction

//===========================================================================
// Trigger: HintExplodeStuff
//===========================================================================
function Trig_HintExplodeStuff_Actions takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call DisplayTextToForce(GetPlayersAll(), "TRIGSTR_272")
endfunction

//===========================================================================
function InitTrig_HintExplodeStuff takes nothing returns nothing
    set gg_trg_HintExplodeStuff=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_HintExplodeStuff, gg_rct_ExplodeStuffHint)
    call TriggerAddAction(gg_trg_HintExplodeStuff, function Trig_HintExplodeStuff_Actions)
endfunction

//===========================================================================
// Trigger: HintExplodeVents
//===========================================================================
function Trig_HintExplodeVents_Actions takes nothing returns nothing
    call DisableTrigger(GetTriggeringTrigger())
    call DisplayTextToForce(GetPlayersAll(), "TRIGSTR_360")
endfunction

//===========================================================================
function InitTrig_HintExplodeVents takes nothing returns nothing
    set gg_trg_HintExplodeVents=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_HintExplodeVents, gg_rct_FinalBoss_Vents)
    call TriggerAddAction(gg_trg_HintExplodeVents, function Trig_HintExplodeVents_Actions)
endfunction

//===========================================================================
// Trigger: IceCavesFunctions
//===========================================================================

function HasIceWallCheck takes nothing returns nothing
    //call BJDebugMsg("EnumDest=" + I2S(GetDestructableTypeId(GetEnumDestructable())) + ", IW: " + I2S(DEST_ICE_WALL))
    if GetDestructableTypeId(GetEnumDestructable()) == DEST_ICE_WALL then
        set udg_t_bool1=true
    endif
endfunction

function CreateIceWall takes real x,real y returns nothing
    //call BJDebugMsg("Create called!")
    call CreateDestructable(DEST_ICE_WALL, x, y, GetRandomDirectionDeg(), GetRandomReal(0.42, 0.52), GetRandomInt(0, 5))
    //call BJDebugMsg("Created!")
endfunction

function HasIceWall takes rect where returns boolean
    set udg_t_bool1=false
    //call BJDebugMsg("Has check")
    call EnumDestructablesInRect(where, null, function HasIceWallCheck)
    //call BJDebugMsg("Has checked")
    return udg_t_bool1
endfunction

function CreateIceWallUnlessExists takes rect where returns nothing
    if not HasIceWall(where) then
        call CreateDestructable(DEST_ICE_WALL, ((GetRectCenterX(where) )*1.0), (( GetRectCenterY(where))*1.0), GetRandomDirectionDeg(), GetRandomReal(0.42, 0.52), GetRandomInt(0, 5)) // INLINED!!
    endif
endfunction

function CreateIceWallUnlessExistsCoinflip takes rect where returns nothing
    if GetRandomInt(0, 1) == 0 then
        call CreateIceWallUnlessExists(where)
    endif
endfunction

function CreateIceWallUEAtLeastOne takes rect r1,rect r2 returns nothing
    local integer random= GetRandomInt(1, 3)
    if BlzBitAnd(random, 1) > 0 then
        call CreateIceWallUnlessExists(r1)
    endif
    if BlzBitAnd(random, 2) > 0 then
        call CreateIceWallUnlessExists(r2)
    endif
endfunction

function CreateIceWallUEAtMostOne takes rect r1,rect r2 returns nothing
    local integer random= GetRandomInt(0, 2)
    if random == 1 then
        call CreateIceWallUnlessExists(r1)
    endif
    if random == 2 then
        call CreateIceWallUnlessExists(r2)
    endif
endfunction
//===========================================================================
// Trigger: IceCavesSetupEnd
//
// Assumes InitIceCaves has setup:
// g_int1 == Start opening, 0 is bottom, 1 is "center", 2 is "top". 
// g_int2 == End opening, 0 is bottom, 1 is "center", 2 is "top". 
// Creates 2 "General" Cores
// Create 1 "end" core
//===========================================================================
function Trig_IceCavesSetupEnd_Func002Func005Func003Func008C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002Func005Func003Func013C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002Func005Func003C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002Func005Func008C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002Func005C takes nothing returns boolean
    if ( not ( udg_g_int1 != 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002Func008C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func002C takes nothing returns boolean
    if ( not ( udg_g_int2 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001Func008C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001Func009C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001Func019C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001Func020C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001Func021C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func001C takes nothing returns boolean
    if ( not ( udg_t_int1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func007C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006Func008C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003Func006C takes nothing returns boolean
    if ( not ( udg_t_int1 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func003C takes nothing returns boolean
    if ( not ( udg_g_int2 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func010C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func011C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func019C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func002C takes nothing returns boolean
    if ( not ( udg_t_int1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func007C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007Func008C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func007C takes nothing returns boolean
    if ( not ( udg_t_int1 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008Func010C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008Func011C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008Func023C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008Func024C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008Func025C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003Func008C takes nothing returns boolean
    if ( not ( udg_t_int1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004Func003C takes nothing returns boolean
    if ( not ( udg_t_int1 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Func004C takes nothing returns boolean
    if ( not ( udg_g_int2 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupEnd_Actions takes nothing returns nothing
    // Setup "end"
    if ( Trig_IceCavesSetupEnd_Func002C() ) then
        // Bottom is open
        set udg_t_rect1=gg_rct_IceCaveBlock13
        call CreateIceWallUnlessExists(udg_t_rect1)
        set udg_t_int3=0
        if ( Trig_IceCavesSetupEnd_Func002Func005C() ) then
            // Start is NOT top
            if ( Trig_IceCavesSetupEnd_Func002Func005Func003C() ) then
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt
                set udg_t_rect2=gg_rct_IceCaveBlock4
                call CreateIceWallUEAtLeastOne(udg_t_rect1 , udg_t_rect2)
                // Setup Cores
                if ( Trig_IceCavesSetupEnd_Func002Func005Func003Func013C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_16_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                set udg_t_rect1=gg_rct_IceCaveBlock5_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock5_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                if ( Trig_IceCavesSetupEnd_Func002Func005Func003Func008C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        else
            // Start is top
            set udg_t_rect1=gg_rct_IceCaveBlock4_Alt
            set udg_t_rect2=gg_rct_IceCaveBlock4
            call CreateIceWallUEAtLeastOne(udg_t_rect1 , udg_t_rect2)
            // Setup Cores
            if ( Trig_IceCavesSetupEnd_Func002Func005Func008C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_16_reward)
                call CreateItemLoc('I001', udg_t_loc1)
                call RemoveLocation(udg_t_loc1)
                set udg_t_int3=( udg_t_int3 + 1 )
            else
            endif
        endif
        // Setup Cores
        // Last 1 Core, 100% if no other has been created
        if ( Trig_IceCavesSetupEnd_Func002Func008C() ) then
            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_9_reward)
            call CreateItemLoc('I001', udg_t_loc1)
            call RemoveLocation(udg_t_loc1)
            set udg_t_int3=( udg_t_int3 + 1 )
        else
        endif
    else
    endif
    if ( Trig_IceCavesSetupEnd_Func003C() ) then
        // Center is open
        set udg_t_rect1=gg_rct_IceCaveBlock4_Alt
        set udg_t_rect2=gg_rct_IceCaveBlock4
        call CreateIceWallUEAtLeastOne(udg_t_rect1 , udg_t_rect2)
        set udg_t_int1=GetRandomInt(0, 2)
        if ( Trig_IceCavesSetupEnd_Func003Func006C() ) then
            // Center is "Main", "Bottom" is Closed near end
            set udg_t_rect1=gg_rct_IceCaveBlock12
            call CreateIceWallUnlessExists(udg_t_rect1)
            // Setup Cores
            set udg_t_int3=0
            if ( Trig_IceCavesSetupEnd_Func003Func006Func007C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_16_reward)
                call CreateItemLoc('I001', udg_t_loc1)
                call RemoveLocation(udg_t_loc1)
                set udg_t_int3=( udg_t_int3 + 1 )
            else
            endif
            if ( Trig_IceCavesSetupEnd_Func003Func006Func008C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_14_reward)
                call CreateItemLoc('I001', udg_t_loc1)
                call RemoveLocation(udg_t_loc1)
                set udg_t_int3=( udg_t_int3 + 1 )
            else
            endif
        else
            if ( Trig_IceCavesSetupEnd_Func003Func006Func001C() ) then
                // Center is "Main", "Bottom" is closed near center-of-ice-caves
                set udg_t_rect1=gg_rct_IceCaveBlock17_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock17_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock17_3
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                set udg_t_int3=0
                if ( Trig_IceCavesSetupEnd_Func003Func006Func001Func019C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_15_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func003Func006Func001Func020C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_14_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func003Func006Func001Func021C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_16_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                // Center is "Main", "Bottom" is closed in middle of bottom-cave
                set udg_t_rect1=gg_rct_IceCaveBlock9_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock9_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                set udg_t_int3=0
                if ( Trig_IceCavesSetupEnd_Func003Func006Func001Func008C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_7_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func003Func006Func001Func009C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_16_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        endif
    else
    endif
    if ( Trig_IceCavesSetupEnd_Func004C() ) then
        // Top is open
        set udg_t_int1=GetRandomInt(0, 2)
        if ( Trig_IceCavesSetupEnd_Func004Func003C() ) then
            // Blocked Near very-end
            set udg_t_rect1=gg_rct_IceCaveBlock15_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock15_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_int1=GetRandomInt(0, 2)
            if ( Trig_IceCavesSetupEnd_Func004Func003Func007C() ) then
                // Blocked "End-Center"
                set udg_t_rect1=gg_rct_IceCaveBlock13
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                set udg_t_int3=0
                if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func007C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_9_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func008C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_17_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func002C() ) then
                    // Blocked End-Bottom-enterence
                    set udg_t_rect1=gg_rct_IceCaveBlock9_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock9_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    // Setup Cores
                    set udg_t_int3=0
                    if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func019C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_7_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    // Blocked End-Bottom-middle
                    set udg_t_rect1=gg_rct_IceCaveBlock17_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock17_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock17_3
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    // Setup Cores
                    set udg_t_int3=0
                    if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func010C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_14_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                    if ( Trig_IceCavesSetupEnd_Func004Func003Func007Func002Func011C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_15_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
            endif
        else
            if ( Trig_IceCavesSetupEnd_Func004Func003Func008C() ) then
                // Blocked at center and Middle of bottom-cave
                set udg_t_rect1=gg_rct_IceCaveBlock13
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock17_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock17_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock17_3
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                set udg_t_int3=0
                if ( Trig_IceCavesSetupEnd_Func004Func003Func008Func023C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_15_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func004Func003Func008Func024C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_14_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func004Func003Func008Func025C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_9_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                // Blocked at center and entrence of bottom-cave
                set udg_t_rect1=gg_rct_IceCaveBlock13
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock9_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock9_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                // Setup Cores
                set udg_t_int3=0
                if ( Trig_IceCavesSetupEnd_Func004Func003Func008Func010C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_7_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupEnd_Func004Func003Func008Func011C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_9_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        endif
    else
    endif
endfunction

//===========================================================================
function InitTrig_IceCavesSetupEnd takes nothing returns nothing
    set gg_trg_IceCavesSetupEnd=CreateTrigger()
    call TriggerAddAction(gg_trg_IceCavesSetupEnd, function Trig_IceCavesSetupEnd_Actions)
endfunction

//===========================================================================
// Trigger: IceCavesSetupMain
//
// g_int1 == Start opening, 0 is bottom, 1 is "center", 2 is "top". 
// g_int2 == End opening, 0 is bottom, 1 is "center", 2 is "top". 
//===========================================================================
function Trig_IceCavesSetupMain_Func002Func002Func004Func010Func005C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func010Func006C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007Func005C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007Func012C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007C takes nothing returns boolean
    if ( not ( udg_t_int1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func010C takes nothing returns boolean
    if ( not ( udg_t_int1 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func011C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func012C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func024C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func025C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func031C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004Func033C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func004C takes nothing returns boolean
    if ( not ( udg_g_int2 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006Func004C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006Func010C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func007C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func015C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_g_int2 != 2 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002Func021C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func002C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func003C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func005Func001C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 2) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func005C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func006Func005C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func006Func011C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func006C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func008Func002C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func008Func008C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010Func008C takes nothing returns boolean
    if ( not ( udg_g_int2 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002Func010C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002Func002C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func002C takes nothing returns boolean
    if ( not ( udg_g_int1 == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func014Func003C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func014Func008C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func014C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func015C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func029Func009C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func029C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002Func030C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func002C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004Func017C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004Func028C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004Func046C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004Func049C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004Func051C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007Func004C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003Func007C takes nothing returns boolean
    if ( not ( udg_g_int2 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func003C takes nothing returns boolean
    if ( not ( udg_g_int1 == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func002C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 5) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func006C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 2) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func007C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func013C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007Func018C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func007C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func017Func005C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func017Func006C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func017Func011C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func017C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006Func018C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func006C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func025Func005C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func025Func006C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func025Func011C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func025C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func040Func005C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func040Func006C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func040Func011C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func040C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func059C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007Func061C takes nothing returns boolean
    if ( not ( udg_t_int3 < 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004Func007C takes nothing returns boolean
    if ( not ( udg_g_int2 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func004C takes nothing returns boolean
    if ( not ( udg_g_int1 == 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Func005C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IceCavesSetupMain_Actions takes nothing returns nothing
    set udg_t_int3=0
    if ( Trig_IceCavesSetupMain_Func002C() ) then
        // Bottom Start
        if ( Trig_IceCavesSetupMain_Func002Func002C() ) then
            // Left
            set udg_t_rect1=gg_rct_IceCaveBlock16_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock16_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func002Func002Func010C() ) then
                // Left
                if ( Trig_IceCavesSetupMain_Func002Func002Func010Func005C() ) then
                    // Coinflip if Blocking center
                    set udg_t_rect1=gg_rct_IceCaveBlock18_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock18_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock18_3
                    call CreateIceWallUnlessExists(udg_t_rect1)
                else
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func005Func001C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func010Func006C() ) then
                    // Open to bottom Left Secret
                    set udg_t_rect1=gg_rct_IceCaveBlock19_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock19_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func006Func011C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_19_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    set udg_t_rect1=gg_rct_IceCaveBlock7_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock7_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func006Func005C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_11_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
                // Check End
                if ( Trig_IceCavesSetupMain_Func002Func002Func010Func008C() ) then
                    // End it TOP
                    set udg_t_rect1=gg_rct_IceCaveBlock5_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock5_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func008Func008C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    // End is through "Main room"
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func008Func002C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
            else
                // Right
                if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002C() ) then
                    // Left
                    set udg_t_rect1=gg_rct_IceCaveBlock7_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock7_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006C() ) then
                        // Left
                        set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006Func004C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    else
                        // Right
                        set udg_t_rect1=gg_rct_IceCaveBlock5_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock5_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func006Func010C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    endif
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func007C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_11_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    // Right
                    set udg_t_rect1=gg_rct_IceCaveBlock18_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock18_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock18_3
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func015C() ) then
                        set udg_t_rect1=gg_rct_IceCaveBlock5_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock5_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                    set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                    set udg_t_rect2=gg_rct_IceCaveBlock5_2
                    if not HasIceWall(udg_t_rect1) and not HasIceWall(udg_t_rect2) then
                    set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func010Func002Func021C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                    endif
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func010Func003C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        else
            // Right
            set udg_t_rect1=gg_rct_IceCaveBlockCave_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func002Func002Func004C() ) then
                // Goal is top
                set udg_t_rect1=gg_rct_IceCaveBlock7_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock7_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_int1=GetRandomInt(0, 2)
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010C() ) then
                    set udg_t_rect1=gg_rct_IceCaveBlock6_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock6_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010Func005C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                    if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010Func006C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_12_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007C() ) then
                        set udg_t_rect1=gg_rct_IceCaveBlock18_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock18_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock18_3
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007Func012C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_10_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    else
                        set udg_t_rect1=gg_rct_IceCaveBlock2_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock2_12
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func002Func002Func004Func010Func007Func005C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    endif
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func011C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func012C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                // Goal is bottom 2
                set udg_t_rect1=gg_rct_IceCaveBlock19_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock19_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_3
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func024C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_19_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func025C() ) then
                    set udg_t_rect1=gg_rct_IceCaveBlock5_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock5_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                set udg_t_rect2=gg_rct_IceCaveBlock5_2
                if not HasIceWall(udg_t_rect1) and not HasIceWall(udg_t_rect2) then
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func031C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                endif
                if ( Trig_IceCavesSetupMain_Func002Func002Func004Func033C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        endif
    else
        // NOT Bottom
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_1_2
        call CreateIceWallUnlessExists(udg_t_rect1)
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_1
        call CreateIceWallUnlessExists(udg_t_rect1)
    endif
    if ( Trig_IceCavesSetupMain_Func003C() ) then
        // Center
        if ( Trig_IceCavesSetupMain_Func003Func007C() ) then
            // Goal Top
            if ( Trig_IceCavesSetupMain_Func003Func007Func002C() ) then
                // Left
                set udg_t_rect1=gg_rct_IceCaveBlock2_12
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock2_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock5_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock5_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock1_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock1_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func003Func007Func002Func014C() ) then
                    set udg_t_rect1=gg_rct_IceCaveBlock16_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock16_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func003Func007Func002Func014Func008C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    set udg_t_rect1=gg_rct_IceCaveBlockCave_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func003Func007Func002Func014Func003C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
                if ( Trig_IceCavesSetupMain_Func003Func007Func002Func015C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                // Right
                set udg_t_rect1=gg_rct_IceCaveBlock6_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock6_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock18_3
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func003Func007Func002Func029C() ) then
                    set udg_t_rect1=gg_rct_IceCaveBlock16_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock16_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func003Func007Func002Func029Func009C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    set udg_t_rect1=gg_rct_IceCaveBlock7_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock7_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                endif
                if ( Trig_IceCavesSetupMain_Func003Func007Func002Func030C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        else
            // Goal non-top
            if ( Trig_IceCavesSetupMain_Func003Func007Func004C() ) then
                // Left
                set udg_t_rect1=gg_rct_IceCaveBlock2_12
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock2_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                set udg_t_rect2=gg_rct_IceCaveBlock5_2
                if not HasIceWall(udg_t_rect1) and not HasIceWall(udg_t_rect2) then
                set udg_t_rect1=gg_rct_IceCaveBlock20_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock20_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock16_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock16_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func003Func007Func004Func017C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                else
                set udg_t_rect1=gg_rct_IceCaveBlock7_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock7_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                endif
                set udg_t_rect1=gg_rct_IceCaveBlock14
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock14_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func003Func007Func004Func028C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_22_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                // Right
                set udg_t_rect1=gg_rct_IceCaveBlock6_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock6_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock19_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock19_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock21_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock21_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock5_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock5_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func003Func007Func004Func046C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_13_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
                if not HasIceWall(udg_t_rect1) then
                if ( Trig_IceCavesSetupMain_Func003Func007Func004Func049C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_6_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                endif
                if ( Trig_IceCavesSetupMain_Func003Func007Func004Func051C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_19_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        endif
    else
        // NOT Center
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_2
        call CreateIceWallUnlessExists(udg_t_rect1)
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_3
        call CreateIceWallUnlessExists(udg_t_rect1)
    endif
    if ( Trig_IceCavesSetupMain_Func004C() ) then
        // Top
        if ( Trig_IceCavesSetupMain_Func004Func007C() ) then
            // GOAL: TOP
            set udg_t_rect1=gg_rct_IceCaveBlock5_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock5_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func004Func007Func006C() ) then
                // Left
                if ( Trig_IceCavesSetupMain_Func004Func007Func006Func002C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                set udg_t_rect1=gg_rct_IceCaveBlock20_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock20_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007C() ) then
                    // Left
                    set udg_t_rect1=gg_rct_IceCaveBlock21_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock21_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock18_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008C() ) then
                        // Left
                        set udg_t_rect1=gg_rct_IceCaveBlock19_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock19_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func006C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_22_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                        if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func007C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_19_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    else
                        // Right
                        set udg_t_rect1=gg_rct_IceCaveBlock1_1
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        set udg_t_rect1=gg_rct_IceCaveBlock1_2
                        call CreateIceWallUnlessExists(udg_t_rect1)
                        if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007Func008Func013C() ) then
                            set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_23_reward)
                            call CreateItemLoc('I001', udg_t_loc1)
                            call RemoveLocation(udg_t_loc1)
                            set udg_t_int3=( udg_t_int3 + 1 )
                        else
                        endif
                    endif
                else
                    // Right
                    set udg_t_rect1=gg_rct_IceCaveBlock1_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock1_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock16_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock16_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func004Func007Func006Func007Func018C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
            else
                // Right
                set udg_t_rect1=gg_rct_IceCaveBlock1_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock1_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock6_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock6_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func006Func017C() ) then
                    set udg_t_rect1=gg_rct_IceCaveBlock21_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock21_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func004Func007Func006Func017Func005C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_12_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                    if ( Trig_IceCavesSetupMain_Func004Func007Func006Func017Func006C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                else
                    set udg_t_rect1=gg_rct_IceCaveBlock16_1
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    set udg_t_rect1=gg_rct_IceCaveBlock16_2
                    call CreateIceWallUnlessExists(udg_t_rect1)
                    if ( Trig_IceCavesSetupMain_Func004Func007Func006Func017Func011C() ) then
                        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                        call CreateItemLoc('I001', udg_t_loc1)
                        call RemoveLocation(udg_t_loc1)
                        set udg_t_int3=( udg_t_int3 + 1 )
                    else
                    endif
                endif
                if ( Trig_IceCavesSetupMain_Func004Func007Func006Func018C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
        else
            // GOAL: NON-TOP
            set udg_t_rect1=gg_rct_IceCaveBlock4_Alt_2
            set udg_t_rect2=gg_rct_IceCaveBlock5_2
            set udg_t_int1=GetRandomInt(0, 2)
            if udg_t_int1 == 0 and not HasIceWall(udg_t_rect1) and not HasIceWall(udg_t_rect2) then
            // RIGHT
            set udg_t_rect1=gg_rct_IceCaveBlock6_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock6_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock20_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock20_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock14
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock14_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func004Func007Func025C() ) then
                set udg_t_rect1=gg_rct_IceCaveBlock21_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock21_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func025Func005C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_12_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupMain_Func004Func007Func025Func006C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                set udg_t_rect1=gg_rct_IceCaveBlock16_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock16_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func025Func011C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
            elseif udg_t_int1 == 1 then
            // CENTER
            set udg_t_rect1=gg_rct_IceCaveBlock1_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock1_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock5_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock5_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock6_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock6_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func004Func007Func040C() ) then
                set udg_t_rect1=gg_rct_IceCaveBlock21_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock21_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func040Func005C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_12_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
                if ( Trig_IceCavesSetupMain_Func004Func007Func040Func006C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_8_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            else
                set udg_t_rect1=gg_rct_IceCaveBlock16_1
                call CreateIceWallUnlessExists(udg_t_rect1)
                set udg_t_rect1=gg_rct_IceCaveBlock16_2
                call CreateIceWallUnlessExists(udg_t_rect1)
                if ( Trig_IceCavesSetupMain_Func004Func007Func040Func011C() ) then
                    set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_20_reward)
                    call CreateItemLoc('I001', udg_t_loc1)
                    call RemoveLocation(udg_t_loc1)
                    set udg_t_int3=( udg_t_int3 + 1 )
                else
                endif
            endif
            else
            // LEFT
            set udg_t_rect1=gg_rct_IceCaveBlock5_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock5_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock19_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock19_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock20_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock20_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock21_1
            call CreateIceWallUnlessExists(udg_t_rect1)
            set udg_t_rect1=gg_rct_IceCaveBlock21_2
            call CreateIceWallUnlessExists(udg_t_rect1)
            if ( Trig_IceCavesSetupMain_Func004Func007Func059C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_19_reward)
                call CreateItemLoc('I001', udg_t_loc1)
                call RemoveLocation(udg_t_loc1)
                set udg_t_int3=( udg_t_int3 + 1 )
            else
            endif
            endif
            if ( Trig_IceCavesSetupMain_Func004Func007Func061C() ) then
                set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_21_reward)
                call CreateItemLoc('I001', udg_t_loc1)
                call RemoveLocation(udg_t_loc1)
                set udg_t_int3=( udg_t_int3 + 1 )
            else
            endif
        endif
    else
        // NOT Top
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_4
        call CreateIceWallUnlessExists(udg_t_rect1)
        set udg_t_rect1=gg_rct_IceCaveBlockDebris_5
        call CreateIceWallUnlessExists(udg_t_rect1)
    endif
    if ( Trig_IceCavesSetupMain_Func005C() ) then
        // Left
    else
        // Right
    endif
endfunction

//===========================================================================
function InitTrig_IceCavesSetupMain takes nothing returns nothing
    set gg_trg_IceCavesSetupMain=CreateTrigger()
    call TriggerAddAction(gg_trg_IceCavesSetupMain, function Trig_IceCavesSetupMain_Actions)
endfunction

//===========================================================================
// Trigger: InitIceCave
//
// Called during delayed init
// g_int1 == Start opening, 0 is bottom, 1 is "center", 2 is "top". 
// g_int2 == End opening, 0 is bottom, 1 is "center", 2 is "top". 
// Create-functions defined in general_functions
//===========================================================================
function Trig_InitIceCave_Func019C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Func020C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Func021C takes nothing returns boolean
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    if ( not ( udg_t_int3 < 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Func023Func001Func002C takes nothing returns boolean
    if ( not ( udg_t_int3 < 2 ) ) then
        return false
    endif
    if ( not ( GetRandomInt(0, 1) == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Func023Func001C takes nothing returns boolean
    if ( ( udg_t_int3 == 0 ) ) then
        return true
    endif
    if ( Trig_InitIceCave_Func023Func001Func002C() ) then
        return true
    endif
    return false
endfunction

function Trig_InitIceCave_Func023C takes nothing returns boolean
    if ( not Trig_InitIceCave_Func023Func001C() ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Func024C takes nothing returns boolean
    if ( not ( udg_t_int3 < 2 ) ) then
        return false
    endif
    return true
endfunction

function Trig_InitIceCave_Actions takes nothing returns nothing
    set udg_g_int1=GetRandomInt(0, 2)
    set udg_g_int2=GetRandomInt(0, 2)
    // General Core Blockers
    set udg_t_rect1=gg_rct_IceCaveBlockSecret_1
    call CreateIceWallUnlessExistsCoinflip(udg_t_rect1)
    set udg_t_rect1=gg_rct_IceCaveBlockSecret_2
    call CreateIceWallUnlessExistsCoinflip(udg_t_rect1)
    set udg_t_rect1=gg_rct_IceCaveBlockSecret_5
    call CreateIceWallUnlessExistsCoinflip(udg_t_rect1)
    set udg_t_rect1=gg_rct_IceCaveBlock3_1
    call CreateIceWallUnlessExistsCoinflip(udg_t_rect1)
    set udg_t_rect1=gg_rct_IceCaveBlock3_2
    call CreateIceWallUnlessExistsCoinflip(udg_t_rect1)
    set udg_t_rect1=gg_rct_IceCaveBlock11
    set udg_t_rect2=gg_rct_IceCaveBlock10
    call CreateIceWallUEAtMostOne(udg_t_rect1 , udg_t_rect2)
    // General Core
    set udg_t_int3=0
    if ( Trig_InitIceCave_Func019C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_1_reward)
        call CreateItemLoc('I001', udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int3=( udg_t_int3 + 1 )
    else
    endif
    if ( Trig_InitIceCave_Func020C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_4_reward)
        call CreateItemLoc('I001', udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int3=( udg_t_int3 + 1 )
    else
    endif
    if ( Trig_InitIceCave_Func021C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_2_reward)
        call CreateItemLoc('I001', udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int3=( udg_t_int3 + 1 )
    else
    endif
    // General Core last 2, special conditions
    if ( Trig_InitIceCave_Func023C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_5_reward)
        call CreateItemLoc('I001', udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int3=( udg_t_int3 + 1 )
    else
    endif
    if ( Trig_InitIceCave_Func024C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_IceCaveBlockSecret_3_reward)
        call CreateItemLoc('I001', udg_t_loc1)
        call RemoveLocation(udg_t_loc1)
        set udg_t_int3=( udg_t_int3 + 1 )
    else
    endif
    // set it up
    call TriggerExecute(gg_trg_IceCavesSetupEnd)
    call TriggerExecute(gg_trg_IceCavesSetupMain)
endfunction

//===========================================================================
function InitTrig_InitIceCave takes nothing returns nothing
    set gg_trg_InitIceCave=CreateTrigger()
    call TriggerAddAction(gg_trg_InitIceCave, function Trig_InitIceCave_Actions)
endfunction

//===========================================================================
// Trigger: IntroSkipActions
//===========================================================================
function Trig_IntroSkipActions_Func005Func001C takes nothing returns boolean
    if ( not ( GetEnumUnit() == gg_unit_h001_0029 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroSkipActions_Func005A takes nothing returns nothing
    if ( Trig_IntroSkipActions_Func005Func001C() ) then
        set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
        call SetUnitPositionLocFacingBJ(GetEnumUnit(), udg_t_loc1, 90.00)
        call RemoveLocation(udg_t_loc1)
        call SetUnitAcquireRangeBJ(GetEnumUnit(), 100.00)
        call IssueImmediateOrderBJ(GetEnumUnit(), "holdposition")
    else
        call RemoveUnit(GetEnumUnit())
    endif
endfunction

function Trig_IntroSkipActions_Actions takes nothing returns nothing
    call DestructableRestoreLife(gg_dest_B01B_0357, GetDestructableMaxLife(gg_dest_B01B_0357), false)
    call DestructableRestoreLife(gg_dest_B01B_0355, GetDestructableMaxLife(gg_dest_B01B_0357), false)
    call KillDestructable(gg_dest_B00Y_0263)
    set udg_t_group1=GetUnitsInRectAll(gg_rct_Intro_Area)
    call ForGroupBJ(udg_t_group1, function Trig_IntroSkipActions_Func005A)
    call DestroyGroup(udg_t_group1)
    set bj_forLoopAIndex=1
    set bj_forLoopAIndexEnd=11
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        set udg_t_loc1=GetRandomLocInRect(gg_rct_Into_Remaining_Zombies)
        call CreateNUnitsAtLoc(1, 'n001', Player(8), udg_t_loc1, GetRandomDirectionDeg())
        call RemoveLocation(udg_t_loc1)
        call GroupAddUnitSimple(GetLastCreatedUnit(), udg_spawnedEnemies)
        set udg_t_int1=1
        set udg_spawnedPowerArr[GetUnitUserData(GetLastCreatedUnit())]=udg_t_int1
        set udg_spawnedEnemiesPower=( udg_spawnedEnemiesPower + udg_t_int1 )
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
endfunction

//===========================================================================
function InitTrig_IntroSkipActions takes nothing returns nothing
    set gg_trg_IntroSkipActions=CreateTrigger()
    call TriggerAddAction(gg_trg_IntroSkipActions, function Trig_IntroSkipActions_Actions)
endfunction

//===========================================================================
// Trigger: IntroSkip
//===========================================================================
function Trig_IntroSkip_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroSkip_Func007A takes nothing returns nothing
    call ResetToGameCameraForPlayer(GetEnumPlayer(), 0)
endfunction

function Trig_IntroSkip_Actions takes nothing returns nothing
    set udg_cinematic=0
    call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUTIN, 1.50, "ReplaceableTextures\\CameraMasks\\Black_mask.blp", 0, 0, 0, 0)
    call TriggerSleepAction(0.65)
    call TriggerExecute(gg_trg_IntroSkipActions)
    call TriggerSleepAction(0.50)
    call CinematicModeBJ(false, GetPlayersAll())
    call ForForce(GetPlayersAll(), function Trig_IntroSkip_Func007A)
    call TriggerExecute(gg_trg_GameStart)
endfunction

//===========================================================================
function InitTrig_IntroSkip takes nothing returns nothing
    set gg_trg_IntroSkip=CreateTrigger()
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_IntroSkip, Player(0))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_IntroSkip, Player(1))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_IntroSkip, Player(2))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_IntroSkip, Player(3))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_IntroSkip, Player(4))
    call TriggerAddCondition(gg_trg_IntroSkip, Condition(function Trig_IntroSkip_Conditions))
    call TriggerAddAction(gg_trg_IntroSkip, function Trig_IntroSkip_Actions)
endfunction

//===========================================================================
// Trigger: IntroCinematic
//
// Called from DelayedMapInit
//===========================================================================
function Trig_IntroCinematic_Func020A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera2, GetEnumPlayer(), udg_t_real1)
endfunction

function Trig_IntroCinematic_Func023C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func025A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera3, GetEnumPlayer(), udg_t_real1)
endfunction

function Trig_IntroCinematic_Func027C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func028A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera4, GetEnumPlayer(), udg_t_real1)
endfunction

function Trig_IntroCinematic_Func031C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func032A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera5, GetEnumPlayer(), udg_t_real1)
endfunction

function Trig_IntroCinematic_Func034C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func036A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera6, GetEnumPlayer(), udg_t_real1)
endfunction

function Trig_IntroCinematic_Func040C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func043C takes nothing returns boolean
    if ( not ( udg_cinematic == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCinematic_Func046A takes nothing returns nothing
    call ResetToGameCameraForPlayer(GetEnumPlayer(), 0)
endfunction

function Trig_IntroCinematic_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos)
    call IssuePointOrderLocBJ(gg_unit_h001_0032, "move", udg_t_loc1)
    set udg_t_group1=GetUnitsInRectAll(gg_rct_Intro_ZombiesGroup2)
    call GroupPointOrderLocBJ(udg_t_group1, "move", udg_t_loc1)
    call DestroyGroup(udg_t_group1)
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy)
    call IssuePointOrderLocBJ(gg_unit_h001_0030, "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_11)
    call IssuePointOrderLocBJ(gg_unit_h001_0029, "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_2)
    call IssuePointOrderLocBJ(gg_unit_h001_0031, "move", udg_t_loc1)
    set udg_t_group1=GetUnitsInRectAll(gg_rct_Intro_ZombiesGroup1)
    call GroupPointOrderLocBJ(udg_t_group1, "attack", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DestroyGroup(udg_t_group1)
    set udg_t_real1=5.50
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func020A)
    call TransmissionFromUnitWithNameBJ(GetPlayersAll(), gg_unit_h001_0029, "TRIGSTR_173", null, "TRIGSTR_174", bj_TIMETYPE_SET, 3.00, true)
    call TransmissionFromUnitWithNameBJ(GetPlayersAll(), gg_unit_h001_0029, "TRIGSTR_175", null, "TRIGSTR_176", bj_TIMETYPE_SET, 3.00, true)
    if ( Trig_IntroCinematic_Func023C() ) then
        return
    else
    endif
    set udg_t_real1=3.50
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func025A)
    call TriggerSleepAction(udg_t_real1)
    if ( Trig_IntroCinematic_Func027C() ) then
        return
    else
    endif
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func028A)
    set udg_t_real1=2.00
    call TriggerSleepAction(udg_t_real1)
    if ( Trig_IntroCinematic_Func031C() ) then
        return
    else
    endif
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func032A)
    call TriggerSleepAction(udg_t_real1)
    if ( Trig_IntroCinematic_Func034C() ) then
        return
    else
    endif
    set udg_t_real1=3.00
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func036A)
    call TriggerSleepAction(( 0.50 * udg_t_real1 ))
    call DestructableRestoreLife(gg_dest_B016_0393, GetDestructableMaxLife(GetEnumDestructable()), true)
    call TriggerSleepAction(( 0.50 * udg_t_real1 ))
    if ( Trig_IntroCinematic_Func040C() ) then
        return
    else
    endif
    set udg_t_real1=1.00
    call TriggerSleepAction(udg_t_real1)
    if ( Trig_IntroCinematic_Func043C() ) then
        return
    else
    endif
    set udg_cinematic=0
    call CinematicModeBJ(false, GetPlayersAll())
    call ForForce(GetPlayersAll(), function Trig_IntroCinematic_Func046A)
    call TriggerExecute(gg_trg_GameStart)
endfunction

//===========================================================================
function InitTrig_IntroCinematic takes nothing returns nothing
    set gg_trg_IntroCinematic=CreateTrigger()
    call TriggerAddAction(gg_trg_IntroCinematic, function Trig_IntroCinematic_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalkOrdersMarine11
//
// First marine, first "step"
//===========================================================================
function Trig_IntroWalkOrdersMarine11_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0032 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalkOrdersMarine11_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_2)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroWalkOrdersMarine11 takes nothing returns nothing
    set gg_trg_IntroWalkOrdersMarine11=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalkOrdersMarine11, gg_rct_Intro_Zombie_Pos)
    call TriggerAddCondition(gg_trg_IntroWalkOrdersMarine11, Condition(function Trig_IntroWalkOrdersMarine11_Conditions))
    call TriggerAddAction(gg_trg_IntroWalkOrdersMarine11, function Trig_IntroWalkOrdersMarine11_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalkOrdersMarine12
//
// First marine, second "step"
//===========================================================================
function Trig_IntroWalkOrdersMarine12_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0032 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalkOrdersMarine12_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_7)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroWalkOrdersMarine12 takes nothing returns nothing
    set gg_trg_IntroWalkOrdersMarine12=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalkOrdersMarine12, gg_rct_Intro_Zombie_Pos_Copy_2)
    call TriggerAddCondition(gg_trg_IntroWalkOrdersMarine12, Condition(function Trig_IntroWalkOrdersMarine12_Conditions))
    call TriggerAddAction(gg_trg_IntroWalkOrdersMarine12, function Trig_IntroWalkOrdersMarine12_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersMarineHold1
//
// First marine, second "step"
//===========================================================================
function Trig_IntroOrdersMarineHold1_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0032 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersMarineHold1_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroOrdersMarineHold1 takes nothing returns nothing
    set gg_trg_IntroOrdersMarineHold1=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersMarineHold1, gg_rct_Intro_Zombie_Pos_Copy_7)
    call TriggerAddCondition(gg_trg_IntroOrdersMarineHold1, Condition(function Trig_IntroOrdersMarineHold1_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersMarineHold1, function Trig_IntroOrdersMarineHold1_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalkOrdersMarine21
//===========================================================================
function Trig_IntroWalkOrdersMarine21_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0030 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalkOrdersMarine21_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_6)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroWalkOrdersMarine21 takes nothing returns nothing
    set gg_trg_IntroWalkOrdersMarine21=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalkOrdersMarine21, gg_rct_Intro_Zombie_Pos_Copy)
    call TriggerAddCondition(gg_trg_IntroWalkOrdersMarine21, Condition(function Trig_IntroWalkOrdersMarine21_Conditions))
    call TriggerAddAction(gg_trg_IntroWalkOrdersMarine21, function Trig_IntroWalkOrdersMarine21_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersMarineHold2
//
// First marine, second "step"
//===========================================================================
function Trig_IntroOrdersMarineHold2_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0030 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersMarineHold2_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroOrdersMarineHold2 takes nothing returns nothing
    set gg_trg_IntroOrdersMarineHold2=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersMarineHold2, gg_rct_Intro_Zombie_Pos_Copy_6)
    call TriggerAddCondition(gg_trg_IntroOrdersMarineHold2, Condition(function Trig_IntroOrdersMarineHold2_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersMarineHold2, function Trig_IntroOrdersMarineHold2_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalkOrdersMarine31
//===========================================================================
function Trig_IntroWalkOrdersMarine31_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0029 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalkOrdersMarine31_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_4)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroWalkOrdersMarine31 takes nothing returns nothing
    set gg_trg_IntroWalkOrdersMarine31=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalkOrdersMarine31, gg_rct_Intro_Zombie_Pos_Copy_11)
    call TriggerAddCondition(gg_trg_IntroWalkOrdersMarine31, Condition(function Trig_IntroWalkOrdersMarine31_Conditions))
    call TriggerAddAction(gg_trg_IntroWalkOrdersMarine31, function Trig_IntroWalkOrdersMarine31_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersMarineHold3 Hold Then Close Door
//
// First marine, second "step"
// "Main Character"
//===========================================================================
function Trig_IntroOrdersMarineHold3_Hold_Then_Close_Door_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0029 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersMarineHold3_Hold_Then_Close_Door_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
    call TriggerSleepAction(3.00)
    call SetUnitAcquireRangeBJ(GetTriggerUnit(), 100.00)
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_1)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroOrdersMarineHold3_Hold_Then_Close_Door takes nothing returns nothing
    set gg_trg_IntroOrdersMarineHold3_Hold_Then_Close_Door=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersMarineHold3_Hold_Then_Close_Door, gg_rct_Intro_Zombie_Pos_Copy_4)
    call TriggerAddCondition(gg_trg_IntroOrdersMarineHold3_Hold_Then_Close_Door, Condition(function Trig_IntroOrdersMarineHold3_Hold_Then_Close_Door_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersMarineHold3_Hold_Then_Close_Door, function Trig_IntroOrdersMarineHold3_Hold_Then_Close_Door_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalkOrdersMarine41
//===========================================================================
function Trig_IntroWalkOrdersMarine41_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0031 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalkOrdersMarine41_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_3)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroWalkOrdersMarine41 takes nothing returns nothing
    set gg_trg_IntroWalkOrdersMarine41=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalkOrdersMarine41, gg_rct_Intro_Zombie_Pos_2)
    call TriggerAddCondition(gg_trg_IntroWalkOrdersMarine41, Condition(function Trig_IntroWalkOrdersMarine41_Conditions))
    call TriggerAddAction(gg_trg_IntroWalkOrdersMarine41, function Trig_IntroWalkOrdersMarine41_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersMarineHold4
//
// First marine, second "step"
//===========================================================================
function Trig_IntroOrdersMarineHold4_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0031 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersMarineHold4_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
    call DisableTrigger(GetTriggeringTrigger())
endfunction

//===========================================================================
function InitTrig_IntroOrdersMarineHold4 takes nothing returns nothing
    set gg_trg_IntroOrdersMarineHold4=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersMarineHold4, gg_rct_Intro_Zombie_Pos_Copy_3)
    call TriggerAddCondition(gg_trg_IntroOrdersMarineHold4, Condition(function Trig_IntroOrdersMarineHold4_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersMarineHold4, function Trig_IntroOrdersMarineHold4_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersZombiesAttackMove1
//
// First marine, second "step"
//===========================================================================
function Trig_IntroOrdersZombiesAttackMove1_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n001' ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersZombiesAttackMove1_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_7)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "attack", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_IntroOrdersZombiesAttackMove1 takes nothing returns nothing
    set gg_trg_IntroOrdersZombiesAttackMove1=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersZombiesAttackMove1, gg_rct_Intro_Zombie_Pos_2)
    call TriggerAddCondition(gg_trg_IntroOrdersZombiesAttackMove1, Condition(function Trig_IntroOrdersZombiesAttackMove1_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersZombiesAttackMove1, function Trig_IntroOrdersZombiesAttackMove1_Actions)
endfunction

//===========================================================================
// Trigger: IntroOrdersZombiesAttackMove2
//
// First marine, second "step"
//===========================================================================
function Trig_IntroOrdersZombiesAttackMove2_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'n001' ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroOrdersZombiesAttackMove2_Actions takes nothing returns nothing
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Copy_7)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "attack", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_IntroOrdersZombiesAttackMove2 takes nothing returns nothing
    set gg_trg_IntroOrdersZombiesAttackMove2=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroOrdersZombiesAttackMove2, gg_rct_Intro_Zombie_Pos)
    call TriggerAddCondition(gg_trg_IntroOrdersZombiesAttackMove2, Condition(function Trig_IntroOrdersZombiesAttackMove2_Conditions))
    call TriggerAddAction(gg_trg_IntroOrdersZombiesAttackMove2, function Trig_IntroOrdersZombiesAttackMove2_Actions)
endfunction

//===========================================================================
// Trigger: IntroCloseDoor
//===========================================================================
function Trig_IntroCloseDoor_Conditions takes nothing returns boolean
    if ( not ( udg_cinematic == 1 ) ) then
        return false
    endif
    if ( not ( GetTriggerUnit() == gg_unit_h001_0029 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCloseDoor_Func018Func001C takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetEnumUnit()) == 'h001' ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroCloseDoor_Func018A takes nothing returns nothing
    if ( Trig_IntroCloseDoor_Func018Func001C() ) then
        call SetUnitLifePercentBJ(GetEnumUnit(), RMinBJ(25.00, GetUnitLifePercent(GetEnumUnit())))
    else
    endif
endfunction

function Trig_IntroCloseDoor_Actions takes nothing returns nothing
    call SetUnitAcquireRangeBJ(GetTriggerUnit(), 100.00)
    call TriggerSleepAction(0.15)
    call IssueImmediateOrderBJ(GetTriggerUnit(), "stop")
    call TriggerSleepAction(0.01)
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
    call SetUnitFacingTimed(GetTriggerUnit(), 180.00, 0.33)
    call TriggerSleepAction(0.20)
    call PauseUnitBJ(true, GetTriggerUnit())
    call SetUnitAnimation(GetTriggerUnit(), "spell")
    call TriggerSleepAction(0.40)
    call SetUnitLifePercentBJ(GetTriggerUnit(), 15.00)
    call AddSpecialEffectTargetUnitBJ("origin", GetTriggerUnit(), "Objects\\Spawnmodels\\Human\\HumanBlood\\HeroBloodElfBlood.mdl")
    call DestroyEffectBJ(GetLastCreatedEffectBJ())
    call DestructableRestoreLife(gg_dest_B01B_0357, GetDestructableMaxLife(gg_dest_B01B_0357), true)
    call DestructableRestoreLife(gg_dest_B01B_0355, GetDestructableMaxLife(gg_dest_B01B_0357), true)
    call TriggerSleepAction(0.60)
    set udg_t_group1=GetUnitsInRectAll(gg_rct_Into_Remaining_Zombies)
    call ForGroupBJ(udg_t_group1, function Trig_IntroCloseDoor_Func018A)
    call DestroyGroup(udg_t_group1)
    call SetUnitAnimation(GetTriggerUnit(), "spell")
    call KillDestructable(gg_dest_B00Y_0263)
    call TriggerSleepAction(1.00)
    call PauseUnitBJ(false, GetTriggerUnit())
    set udg_t_loc1=GetRectCenter(gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
    call IssuePointOrderLocBJ(GetTriggerUnit(), "move", udg_t_loc1)
    call RemoveLocation(udg_t_loc1)
endfunction

//===========================================================================
function InitTrig_IntroCloseDoor takes nothing returns nothing
    set gg_trg_IntroCloseDoor=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroCloseDoor, gg_rct_Intro_Zombie_Pos_Inside_Doors_1)
    call TriggerAddCondition(gg_trg_IntroCloseDoor, Condition(function Trig_IntroCloseDoor_Conditions))
    call TriggerAddAction(gg_trg_IntroCloseDoor, function Trig_IntroCloseDoor_Actions)
endfunction

//===========================================================================
// Trigger: IntroWalk Away From Door
//===========================================================================
function Trig_IntroWalk_Away_From_Door_Conditions takes nothing returns boolean
    if ( not ( GetTriggerUnit() == gg_unit_h001_0029 ) ) then
        return false
    endif
    return true
endfunction

function Trig_IntroWalk_Away_From_Door_Actions takes nothing returns nothing
    call TriggerSleepAction(0.25)
    call IssueImmediateOrderBJ(GetTriggerUnit(), "holdposition")
endfunction

//===========================================================================
function InitTrig_IntroWalk_Away_From_Door takes nothing returns nothing
    set gg_trg_IntroWalk_Away_From_Door=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_IntroWalk_Away_From_Door, gg_rct_Intro_Zombie_Pos_Inside_Doors_2)
    call TriggerAddCondition(gg_trg_IntroWalk_Away_From_Door, Condition(function Trig_IntroWalk_Away_From_Door_Conditions))
    call TriggerAddAction(gg_trg_IntroWalk_Away_From_Door, function Trig_IntroWalk_Away_From_Door_Actions)
endfunction

//===========================================================================
// Trigger: JassInit
//===========================================================================

function initMovementSpeed takes nothing returns nothing
    set unitMovementSpeed=s__Table_create()
    call SaveInteger(Table__ht, (unitMovementSpeed), (MECHA_DH_UID), ( 285)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (ZOMBIE_UID), ( 175)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (ZOMBIE_DOG_UID), ( 280)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (SPIDER_UID), ( 280)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (SPIDERLING_UID), ( 330)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (BROODMOTHER_UID), ( 250)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (MECHA_CL_UID), ( 270)) // INLINED!!
    call SaveInteger(Table__ht, (unitMovementSpeed), (SAW_BOT_UID), ( 260)) // INLINED!!
endfunction

function jassInit takes nothing returns nothing
    call hideBaseGui()
    //call uiInit()
    call initMovementSpeed()

    set destructableEvents=s__Table_create()

    //Setup tables for core-drops from enemies
    //enemyKills tracks kills per unit-type

    set enemyKillsT=s__Table_create()
    set coreKillsToNextDropT=s__Table_create()
    set coreDropGrowT=s__Table_create()
    set coreDropKillsRequiredT=s__Table_create()

    call SaveInteger(Table__ht, (coreDropGrowT), (ZOMBIE_UID), ( 3)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropKillsRequiredT), (ZOMBIE_UID), ( 5)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropGrowT), (ZOMBIE_DOG_UID), ( 2)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropKillsRequiredT), (ZOMBIE_DOG_UID), ( 5)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropGrowT), (SPIDER_UID), ( 2)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropKillsRequiredT), (SPIDER_UID), ( 4)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropGrowT), (SPIDERLING_UID), ( 3)) // INLINED!!
    call SaveInteger(Table__ht, (coreDropKillsRequiredT), (SPIDERLING_UID), ( 7)) // INLINED!!

    call SaveInteger(Table__ht, (coreKillsToNextDropT), (ZOMBIE_UID), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (ZOMBIE_UID))))) // INLINED!!
    call SaveInteger(Table__ht, (coreKillsToNextDropT), (ZOMBIE_DOG_UID), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (ZOMBIE_DOG_UID))))) // INLINED!!
    call SaveInteger(Table__ht, (coreKillsToNextDropT), (SPIDER_UID), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (SPIDER_UID))))) // INLINED!!
    call SaveInteger(Table__ht, (coreKillsToNextDropT), (SPIDERLING_UID), ( (LoadInteger(Table__ht, (coreDropKillsRequiredT), (SPIDERLING_UID))))) // INLINED!!
endfunction

//set coreDropT[udg_t_unittype1] = coreDropT[udg_t_unittype1] + 1
//set udg_t_int1 = coreDropKillsRequiredT[udg_t_unittype1]
//set udg_t_int2 = coreMaxDropT[udg_t_unittype1]
//if enemyKillsT[udg_t_unittype1] * (coreDropT[udg_t_unittype1] + 1) >= coreDropKillsRequiredT[udg_t_unittype1] * (coreDropT[udg_t_unittype1] + 1) and coreDropT[udg_t_unittype1] <= coreMaxDropT[udg_t_unittype1] then
//
//call BJDebugMsg("Kills: " + I2S(enemyKillsT[udg_t_unittype1]) + ", coresDropped=" + I2S(coreDropT[udg_t_unittype1]) + ", req=" + I2S(coreDropKillsRequiredT[udg_t_unittype1]) + ", max=" + I2S(coreMaxDropT[udg_t_unittype1]))

//set destructableEvents[GetHandleId(udg_t_destructible1)] = function MCLOnBossVentDeath
//set coreDropKillsRequiredT[udg_t_unittype1] = coreDropKillsRequiredT[udg_t_unittype1] + coreDropGrowT[udg_t_unittype1]
//set coreKillsToNextDropT[udg_t_unittype1] = coreKillsToNextDropT[udg_t_unittype1] - 1

//===========================================================================
// Trigger: MapInit
//
// //Called from init debug. is_testing is already set!
//===========================================================================
function Trig_MapInit_Func043C takes nothing returns boolean
    if ( not ( udg_is_testing == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_MapInit_Actions takes nothing returns nothing
    call jassInit()
    set udg_boss_BM_status=0
    set udg_bossUnit=null
    set udg_bossOngoing=false
    set udg_t_rect1=gg_rct_FinalBoss_GreenCrystal_L
    set udg_t_rect2=gg_rct_FinalBoss_Transmitter_L
    set mcl_crystal_l_x=GetRectCenterX(udg_t_rect1)
    set mcl_crystal_l_y=GetRectCenterY(udg_t_rect1)
    set mcl_transmitter_l_x=GetRectCenterX(udg_t_rect2)
    set mcl_transmitter_l_y=GetRectCenterY(udg_t_rect2)
    set udg_t_rect1=gg_rct_FinalBoss_GreenCrystal_R
    set udg_t_rect2=gg_rct_FinalBoss_Transmitter_R
    set mcl_crystal_r_x=GetRectCenterX(udg_t_rect1)
    set mcl_crystal_r_y=GetRectCenterY(udg_t_rect1)
    set mcl_transmitter_r_x=GetRectCenterX(udg_t_rect2)
    set mcl_transmitter_r_y=GetRectCenterY(udg_t_rect2)
    set udg_bossRegions[0]=gg_rct_Brood_Mother_Entrence_EggLoc1
    set udg_bossRegions[1]=gg_rct_Brood_Mother_Entrence_EggLoc2
    set udg_bossRegions[2]=gg_rct_Brood_Mother_Entrence_EggLoc3
    set udg_bossRegions[3]=gg_rct_Brood_Mother_Entrence_EggLoc4
    set udg_bossRegions[4]=gg_rct_Brood_Mother_Entrence_EggLoc5
    set udg_bossRegions[5]=gg_rct_Brood_Mother_Entrence_EggLoc6
    set udg_bossRegions[10]=gg_rct_FinalBoss_SpawnPoint
    set udg_bossRegions[11]=gg_rct_FinalBoss_SpawnPoint__Copy_2
    set udg_bossRegions[12]=gg_rct_FinalBoss_SpawnPoint__Copy_3
    set udg_bossRegions[13]=gg_rct_FinalBoss_SpawnPoint__Copy_4
    set udg_bossRegions[14]=gg_rct_FinalBoss_SpawnPoint__Copy_5
    set udg_bossRegions[15]=gg_rct_FinalBoss_SpawnPoint__Copy_6
    set udg_bossRegions[16]=gg_rct_FinalBoss_SpawnPoint__Copy_7
    set udg_bossRegions[17]=gg_rct_FinalBoss_SpawnPoint__Copy
    set udg_initial_spawn[0]=gg_rct_InitialSpawn1
    set udg_initial_spawn[1]=gg_rct_InitialSpawn2
    set udg_initial_spawn[2]=gg_rct_InitialSpawn3
    set udg_initial_spawn[3]=gg_rct_InitialSpawn4
    set udg_initial_spawn[4]=gg_rct_InitialSpawn5
    call SetDestructableAnimationBJ(gg_dest_B015_0523, "stand alternate")
    call SetDestructableAnimationBJ(gg_dest_B015_0358, "stand alternate")
    call SetDestructableAnimationBJ(gg_dest_B015_0524, "stand alternate")
    call EnableDragSelect(false, false)
    call EnableSelect(false, false)
    call SetTimeOfDay(0.00)
    call UseTimeOfDayBJ(false)
    if ( Trig_MapInit_Func043C() ) then
    else
        set udg_cinematic=1
    endif
    set udg_enemyPatrolPoints[0]=GetRectCenter(gg_rct_ZombiePatrolP1)
    set udg_enemyPatrolPoints[1]=GetRectCenter(gg_rct_ZombiePatrolP2)
    set udg_enemyPatrolPoints[2]=GetRectCenter(gg_rct_ZombiePatrolP3)
    set udg_enemyPatrolPoints[3]=GetRectCenter(gg_rct_ZombiePatrolP4)
    set udg_enemyPatrolPoints[10]=GetRectCenter(gg_rct_IceCavesPatrol1)
    set udg_enemyPatrolPoints[11]=GetRectCenter(gg_rct_IceCavesPatrol2)
    set udg_enemyPatrolPoints[12]=GetRectCenter(gg_rct_IceCavesPatrol3)
    set udg_coreSecretPoints[0]=gg_rct_SA_Battery1
    set udg_coreSecretPoints[1]=gg_rct_SA_Battery2
    set udg_coreSecretPoints[2]=gg_rct_SA_Battery3
    set udg_coreSecretPoints[3]=gg_rct_SA_Battery4
    set udg_coreSecretPoints[4]=gg_rct_SA_Battery5
    set udg_coreSecretPoints[10]=gg_rct_IceCaveBlockSecret_1_reward
    set udg_coreSecretPoints[11]=gg_rct_IceCaveBlockSecret_1
    set udg_coreSecretPoints[12]=null
    set udg_coreSecretPoints[13]=gg_rct_IceCaveBlockSecret_2_reward
    set udg_coreSecretPoints[14]=gg_rct_IceCaveBlockSecret_2
    set udg_coreSecretPoints[15]=null
    set udg_coreSecretPoints[16]=gg_rct_IceCaveBlockSecret_3_reward
    set udg_coreSecretPoints[17]=gg_rct_IceCaveBlock3_2
    set udg_coreSecretPoints[18]=gg_rct_IceCaveBlock3_1
    set udg_coreSecretPoints[19]=gg_rct_IceCaveBlockSecret_4_reward
    set udg_coreSecretPoints[20]=gg_rct_IceCaveBlockSecret_4
    set udg_coreSecretPoints[21]=null
    set udg_coreSecretPoints[22]=gg_rct_IceCaveBlockSecret_5_reward
    set udg_coreSecretPoints[23]=gg_rct_IceCaveBlockSecret_5
    set udg_coreSecretPoints[24]=null
    set udg_t_int1=0
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_1_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_3
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_4
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockDebris_5
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockCave_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockCave_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock16_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock16_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock2_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock2_12
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock7_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock7_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock18_3
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock18_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock18_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock18_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock6_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock6_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock8_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock8_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock14
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock14_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock1_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock1_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock5_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock5_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock9_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock9_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock4
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock13
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock4_Alt
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock15_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock15_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock12
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock11
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock10
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock17_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock17_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock17_3
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock4_Alt_2
    // -------------- STORE NUMBER OF NON-SECRET -----------
    set udg_t_int2=udg_t_int1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockSecret_4
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockSecret_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock3_2
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlock3_1
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockSecret_5
    set udg_t_int1=( udg_t_int1 + 1 )
    set udg_doodadRegions[udg_t_int1]=gg_rct_IceCaveBlockSecret_2
    // -------------- STORE NUMBER OF SECRET -----------
    set udg_t_int3=udg_t_int1
    // FILL NON-SECRET
    // MAYBE FILL SECRET
endfunction

//===========================================================================
function InitTrig_MapInit takes nothing returns nothing
    set gg_trg_MapInit=CreateTrigger()
    call TriggerAddAction(gg_trg_MapInit, function Trig_MapInit_Actions)
endfunction

//===========================================================================
// Trigger: DelayedMapInit
//===========================================================================
function Trig_DelayedMapInit_Func007Func003A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_IntroCamera1, GetEnumPlayer(), 0.00)
endfunction

function Trig_DelayedMapInit_Func007C takes nothing returns boolean
    if ( not ( udg_cinematic > 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_DelayedMapInit_Actions takes nothing returns nothing
    call uiInit()
    set udg_t_destructible1=gg_dest_B01B_3096
    call OpenDoor(udg_t_destructible1)
    set udg_t_destructible1=gg_dest_B01B_3097
    call OpenDoor(udg_t_destructible1)
    call TriggerExecute(gg_trg_InitIceCave)
    if ( Trig_DelayedMapInit_Func007C() ) then
        call SetUserControlForceOff(GetPlayersAll())
        call ForForce(GetPlayersAll(), function Trig_DelayedMapInit_Func007Func003A)
        call CinematicModeBJ(true, GetPlayersAll())
        call setUiVisible(false)
        call TriggerExecute(gg_trg_IntroCinematic)
    else
        // This is a debug/map-development game, smaller leaks are ok
        call DisplayTextToForce(GetPlayersAll(), "TRIGSTR_172")
        call TriggerExecute(gg_trg_IntroSkipActions)
        call TriggerExecute(gg_trg_GameStart)
        call CreateItemLoc('I000', GetRectCenter(gg_rct_ExitingSpawnArea))
    endif
endfunction

//===========================================================================
function InitTrig_DelayedMapInit takes nothing returns nothing
    set gg_trg_DelayedMapInit=CreateTrigger()
    call TriggerRegisterTimerEventSingle(gg_trg_DelayedMapInit, 0.01)
    call TriggerAddAction(gg_trg_DelayedMapInit, function Trig_DelayedMapInit_Actions)
endfunction

//===========================================================================
// Trigger: GameStart
//
// Called from IntroCinematic, IntroSkip or DelayedMapInit (if debug)
//===========================================================================
function Trig_GameStart_Func004Func001Func019Func001C takes nothing returns boolean
    if ( not ( GetDestructableTypeId(GetEnumDestructable()) == 'B016' ) ) then
        return false
    endif
    return true
endfunction

function Trig_GameStart_Func004Func001Func019A takes nothing returns nothing
    if ( Trig_GameStart_Func004Func001Func019Func001C() ) then
        set udg_respawnCurrentPoint[GetUnitUserData(GetLastCreatedUnit())]=GetEnumDestructable()
        call DestructableRestoreLife(GetEnumDestructable(), GetDestructableMaxLife(GetEnumDestructable()), true)
    else
    endif
endfunction

function Trig_GameStart_Func004Func001C takes nothing returns boolean
    if ( not ( GetPlayerSlotState(GetEnumPlayer()) == PLAYER_SLOT_STATE_PLAYING ) ) then
        return false
    endif
    return true
endfunction

function Trig_GameStart_Func004A takes nothing returns nothing
    if ( Trig_GameStart_Func004Func001C() ) then
        call ForceAddPlayerSimple(GetEnumPlayer(), udg_human_players)
        call CreateFogModifierRectBJ(false, GetEnumPlayer(), FOG_OF_WAR_VISIBLE, gg_rct_FinalBoss_Conveyor_Corridor)
        set udg_t_int1=( ( GetConvertedPlayerId(GetEnumPlayer()) * 100 ) + 0 )
        set udg_g_visModArr[udg_t_int1]=GetLastCreatedFogModifier()
        set udg_t_loc1=GetRectCenter(udg_initial_spawn[( GetConvertedPlayerId(GetEnumPlayer()) - 1 )])
        call CreateNUnitsAtLoc(1, 'h000', GetEnumPlayer(), udg_t_loc1, 1.00)
        set udg_t_unit1=GetLastCreatedUnit()
        call GroupAddUnitSimple(udg_t_unit1, udg_heroes_alive)
        call GroupAddUnitSimple(udg_t_unit1, udg_heroes_all)
        call s__MetroidvaniaController_setHero(GetEnumPlayer() , udg_t_unit1)
        call s__MetroidvaniaController_setAttack(GetEnumPlayer() , s__HeroAttackBasicAction_create(udg_t_unit1))
        call s__MetroidvaniaController_setDash(GetEnumPlayer() , s__HeroBasicDash_create(udg_t_unit1))
        call s__MetroidvaniaController_setInteract(GetEnumPlayer() , s__InteractAction_create(udg_t_unit1))
        call s__MetroidvaniaController_updateAbilityDetails((GetPlayerId((GetEnumPlayer())))) // INLINED!!
        call s__LockCamExtension_registerUnit((udg_t_unit1)) // INLINED!!
        call updateStatsPanel(GetEnumPlayer())
        call SelectUnitForPlayerSingle(GetLastCreatedUnit(), GetEnumPlayer())
        call SetCameraTargetControllerNoZForPlayer(GetEnumPlayer(), GetLastCreatedUnit(), 0, 0, false)
        call EnumDestructablesInCircleBJ(150.00, udg_t_loc1, function Trig_GameStart_Func004Func001Func019A)
        call RemoveLocation(udg_t_loc1)
    else
    endif
endfunction

function Trig_GameStart_Func008Func002C takes nothing returns boolean
    if ( not ( RandomItemInRectSimpleBJ(udg_coreSecretPoints[udg_t_int1]) == null ) ) then
        return false
    endif
    if ( not ( udg_t_int2 <= 3 ) ) then
        return false
    endif
    return true
endfunction

function Trig_GameStart_Actions takes nothing returns nothing
    call SetTerrainFogExBJ(0, 99999.00, 100000.00, 0, 100, 100, 100)
    call setUiVisible(true)
    call s__HeroStatsCore_addCoresForAll(3)
    call ForForce(GetPlayersByMapControl(MAP_CONTROL_USER), function Trig_GameStart_Func004A)
    call s__UserMouse_registerCode(function s__LockCamExtension_onMouseMovement , EVENT_MOUSE_MOVE) // INLINED!!
    // Start Area Cores
    set udg_t_int2=0
    set bj_forLoopAIndex=0
    set bj_forLoopAIndexEnd=12
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        set udg_t_int1=GetRandomInt(0, 4)
        if ( Trig_GameStart_Func008Func002C() ) then
            set udg_t_loc1=GetRectCenter(udg_coreSecretPoints[udg_t_int1])
            call CreateItemLoc('I001', udg_t_loc1)
            call RemoveLocation(udg_t_loc1)
            set udg_t_int2=( udg_t_int2 + 1 )
        else
        endif
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
endfunction

//===========================================================================
function InitTrig_GameStart takes nothing returns nothing
    set gg_trg_GameStart=CreateTrigger()
    call TriggerAddAction(gg_trg_GameStart, function Trig_GameStart_Actions)
endfunction

//===========================================================================
// Trigger: dummy
//===========================================================================
function Trig_dummy_Actions takes nothing returns nothing
    call BlzHideOriginFrames(true)
    call BlzFrameSetVisible(ui_portrait, true)
    call BlzFrameSetVisible(ui_portrait, false)
    call AddSpecialEffectLocBJ(udg_t_loc1, "Abilities\\Weapons\\DragonHawkMissile\\DragonHawkMissile.mdl")
    call BlzPlaySpecialEffect(GetLastCreatedEffectBJ(), ANIM_TYPE_DEATH)
    call DestroyEffectBJ(GetLastCreatedEffectBJ())
    call KillUnit(GetTriggerUnit())
endfunction

//===========================================================================
function InitTrig_dummy takes nothing returns nothing
    set gg_trg_dummy=CreateTrigger()
    call TriggerAddAction(gg_trg_dummy, function Trig_dummy_Actions)
endfunction

//===========================================================================
// Trigger: GameVictory
//===========================================================================
function Trig_GameVictory_Conditions takes nothing returns boolean
    if ( not ( GetUnitTypeId(GetTriggerUnit()) == 'h000' ) ) then
        return false
    endif
    return true
endfunction

function Trig_GameVictory_Func003A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_Victory1, GetEnumPlayer(), 0)
endfunction

function Trig_GameVictory_Func004A takes nothing returns nothing
    call CameraSetupApplyForPlayer(true, gg_cam_Victory2, GetEnumPlayer(), 20.00)
endfunction

function Trig_GameVictory_Func009A takes nothing returns nothing
    call CustomVictoryBJ(GetEnumPlayer(), true, true)
endfunction

function Trig_GameVictory_Actions takes nothing returns nothing
    call setUiVisible(false)
    call CinematicModeBJ(true, GetPlayersAll())
    call ForForce(udg_human_players, function Trig_GameVictory_Func003A)
    call ForForce(udg_human_players, function Trig_GameVictory_Func004A)
    call TransmissionFromUnitTypeWithNameBJ(GetPlayersAll(), Player(9), 'h000', "TRIGSTR_301", GetRectCenter(gg_rct_Victory_Area), null, "TRIGSTR_302", bj_TIMETYPE_SET, 4.00, true)
    call SetTimeOfDay(12)
    call TransmissionFromUnitTypeWithNameBJ(GetPlayersAll(), Player(9), 'h000', "TRIGSTR_305", GetRectCenter(gg_rct_Victory_Area), null, "TRIGSTR_306", bj_TIMETYPE_SET, 4.00, true)
    call TransmissionFromUnitTypeWithNameBJ(GetPlayersAll(), Player(9), 'h000', "TRIGSTR_307", GetRectCenter(gg_rct_Victory_Area), null, "TRIGSTR_308", bj_TIMETYPE_SET, 4.00, true)
    call ForForce(udg_human_players, function Trig_GameVictory_Func009A)
endfunction

//===========================================================================
function InitTrig_GameVictory takes nothing returns nothing
    set gg_trg_GameVictory=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_GameVictory, gg_rct_Victory_Area)
    call TriggerAddCondition(gg_trg_GameVictory, Condition(function Trig_GameVictory_Conditions))
    call TriggerAddAction(gg_trg_GameVictory, function Trig_GameVictory_Actions)
endfunction

//===========================================================================
// Trigger: OnIndex
//===========================================================================
function Trig_OnIndex_Actions takes nothing returns nothing
    set udg_t_unittype1=GetUnitTypeId(udg_UDexUnits[udg_UDex])
call s__ExtendableBonus_Set((udg_UDexUnits[udg_UDex] ) , ( si__BonusMovementSpeed ) , (( (LoadInteger(Table__ht, (unitMovementSpeed), (udg_t_unittype1))) - 1)*1.0)) // INLINED!!
endfunction

//===========================================================================
function InitTrig_OnIndex takes nothing returns nothing
    set gg_trg_OnIndex=CreateTrigger()
    call h__TriggerRegisterVariableEvent(gg_trg_OnIndex, "udg_UnitIndexEvent", EQUAL, 1.00)
    call TriggerAddAction(gg_trg_OnIndex, function Trig_OnIndex_Actions)
endfunction

//===========================================================================
function InitCustomTriggers takes nothing returns nothing
    //Function not found: call InitTrig_Table()
    //Function not found: call InitTrig_SpellEffectEvent()
    //Function not found: call InitTrig_RegisterPlayerUnitEvent()
    //Function not found: call InitTrig_TimerUtils()
    //Function not found: call InitTrig_Dummy_Recycler()
    //Function not found: call InitTrig_WorldBounds()
    //Function not found: call InitTrig_Alloc()
    //Function not found: call InitTrig_LineSegmentEnumeration()
    //Function not found: call InitTrig_MouseUtils()
    //Function not found: call InitTrig_UnitEvent()
    call InitTrig_UnitEventConfig()
    //Function not found: call InitTrig_NewBonusUtils()
    call InitTrig_Knockback_2D_Config()
    call InitTrig_Knockback_2D_Destroy()
    call InitTrig_Knockback_2D()
    call InitTrig_Knockback_2D_System()
    //Function not found: call InitTrig_CooldownReduction()
    //Function not found: call InitTrig_CooldownReductionUtils()
    //Function not found: call InitTrig_Relativistic_Missiles()
    //Function not found: call InitTrig_MissileEffect()
    //Function not found: call InitTrig_MissileUtils()
    call InitTrig_Check_Walkability_Setup()
    call InitTrig_Check_Walkability()
    call InitTrig_Damage_Engine_Config()
    //Function not found: call InitTrig_Damage_Engine()
    //Function not found: call InitTrig_DelayedDestroyer()
    //Function not found: call InitTrig_UI()
    //Function not found: call InitTrig_MouseUtilsLockCamExtension()
    //Function not found: call InitTrig_DestructablesUpdate()
    //Function not found: call InitTrig_HeroController()
    //Function not found: call InitTrig_KnockbackTZ()
    //Function not found: call InitTrig_ExtendableBonusSystem()
    //Function not found: call InitTrig_ExtendableBonusesGeneral()
    //Function not found: call InitTrig_ExtendableBonusesMetroidvania()
    call InitTrig_PickupCore()
    //Function not found: call InitTrig_RespawnHelpers()
    call InitTrig_ReincarnateStart()
    call InitTrig_BombDetonate()
    call InitTrig_BombPickup()
    //Function not found: call InitTrig_HeroAbilities()
    //Function not found: call InitTrig_Interaction()
    call InitTrig_EnemySpawnStartingArea()
    call InitTrig_EnemySpawnIceCavesArea()
    call InitTrig_EnemySpawningMain()
    call InitTrig_EnemyDespawnMain()
    //Function not found: call InitTrig_MechaCL_jass()
    call InitTrig_MechaCL_StartForceEnter()
    call InitTrig_MechaCL_HeroDeath()
    call InitTrig_MechaCL_SkipCinematic()
    call InitTrig_MechaCL_OnDamageTaken()
    call InitTrig_MechaCL_OnDamageTaken_Message_Reset()
    call InitTrig_MechaCL_UpdateLightning()
    call InitTrig_MechaCL_Death()
    call InitTrig_MechaCL_Hero_EnterConveyorArea()
    call InitTrig_MechaCL_Hero_LeaveConveyorArea()
    call InitTrig_MechaCL_AI_Main()
    call InitTrig_MechaCL_Missile_StartAnim()
    call InitTrig_MechaCL_Missile_FireFirstRound()
    call InitTrig_MechaCL_Missile_FireSecondRound()
    call InitTrig_MechaCL_Missile_End()
    call InitTrig_MechaCL_AI_Spawn_SawBot_Start()
    call InitTrig_MechaCL_AI_Spawn_SawBot_Call()
    call InitTrig_MechaCL_AI_Spawn_SawBot_SpawnStart()
    call InitTrig_MechaCL_AI_Spawn_SawBot_SpawnFinish()
    call InitTrig_MechaCL_OnCrystalDeath()
    call InitTrig_MechaCLOnFanDeath()
    call InitTrig_BroodMother_Spawn()
    call InitTrig_BroodMother_Death()
    call InitTrig_BroodMother_RewardEnter()
    call InitTrig_BroodMother_HeroDeath()
    call InitTrig_BroodMother_AI_LayEgg()
    call InitTrig_BroodMother_AI_LayEgg_OnCast()
    call InitTrig_BroodMother_AI_LayEgg_OnEggDeath()
    call InitTrig_BroodMother_AI()
    call InitTrig_EnemyKill()
    call InitTrig_ConveyorNorthEnter()
    call InitTrig_ConveyorNorthLeave()
    call InitTrig_ConveyorEastEnter()
    call InitTrig_ConveyorEastLeave()
    call InitTrig_ConveyorWestEnter()
    call InitTrig_ConveyorWestLeave()
    call InitTrig_ConveyorTick()
    call InitTrig_FinalBossCrystalsInit()
    call InitTrig_TP_To_final_boss()
    call InitTrig_OilBarrel()
    call InitTrig_InitializeDebug()
    call InitTrig_InitializeDebugTriggers()
    call InitTrig_RemoveDebugTriggers()
    call InitTrig_ChatKill()
    call InitTrig_HintExitSpawnArea()
    call InitTrig_HintOpenDoors()
    call InitTrig_HintExplodeStuff()
    call InitTrig_HintExplodeVents()
    //Function not found: call InitTrig_IceCavesFunctions()
    call InitTrig_IceCavesSetupEnd()
    call InitTrig_IceCavesSetupMain()
    call InitTrig_InitIceCave()
    call InitTrig_IntroSkipActions()
    call InitTrig_IntroSkip()
    call InitTrig_IntroCinematic()
    call InitTrig_IntroWalkOrdersMarine11()
    call InitTrig_IntroWalkOrdersMarine12()
    call InitTrig_IntroOrdersMarineHold1()
    call InitTrig_IntroWalkOrdersMarine21()
    call InitTrig_IntroOrdersMarineHold2()
    call InitTrig_IntroWalkOrdersMarine31()
    call InitTrig_IntroOrdersMarineHold3_Hold_Then_Close_Door()
    call InitTrig_IntroWalkOrdersMarine41()
    call InitTrig_IntroOrdersMarineHold4()
    call InitTrig_IntroOrdersZombiesAttackMove1()
    call InitTrig_IntroOrdersZombiesAttackMove2()
    call InitTrig_IntroCloseDoor()
    call InitTrig_IntroWalk_Away_From_Door()
    //Function not found: call InitTrig_JassInit()
    call InitTrig_MapInit()
    call InitTrig_DelayedMapInit()
    call InitTrig_GameStart()
    call InitTrig_dummy()
    call InitTrig_GameVictory()
    call InitTrig_OnIndex()
endfunction

//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute(gg_trg_UnitEventConfig)
    call ConditionalTriggerExecute(gg_trg_Check_Walkability_Setup)
    call ConditionalTriggerExecute(gg_trg_Damage_Engine_Config)
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation(Player(0), 0)
    call ForcePlayerStartLocation(Player(0), 0)
    call SetPlayerColor(Player(0), ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(0), false)
    call SetPlayerController(Player(0), MAP_CONTROL_USER)

    // Player 1
    call SetPlayerStartLocation(Player(1), 1)
    call ForcePlayerStartLocation(Player(1), 1)
    call SetPlayerColor(Player(1), ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(1), false)
    call SetPlayerController(Player(1), MAP_CONTROL_USER)

    // Player 2
    call SetPlayerStartLocation(Player(2), 2)
    call ForcePlayerStartLocation(Player(2), 2)
    call SetPlayerColor(Player(2), ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(2), false)
    call SetPlayerController(Player(2), MAP_CONTROL_USER)

    // Player 3
    call SetPlayerStartLocation(Player(3), 3)
    call ForcePlayerStartLocation(Player(3), 3)
    call SetPlayerColor(Player(3), ConvertPlayerColor(3))
    call SetPlayerRacePreference(Player(3), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(3), false)
    call SetPlayerController(Player(3), MAP_CONTROL_USER)

    // Player 4
    call SetPlayerStartLocation(Player(4), 4)
    call ForcePlayerStartLocation(Player(4), 4)
    call SetPlayerColor(Player(4), ConvertPlayerColor(4))
    call SetPlayerRacePreference(Player(4), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(4), false)
    call SetPlayerController(Player(4), MAP_CONTROL_USER)

    // Player 6
    call SetPlayerStartLocation(Player(6), 5)
    call ForcePlayerStartLocation(Player(6), 5)
    call SetPlayerColor(Player(6), ConvertPlayerColor(6))
    call SetPlayerRacePreference(Player(6), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(6), false)
    call SetPlayerController(Player(6), MAP_CONTROL_COMPUTER)

    // Player 8
    call SetPlayerStartLocation(Player(8), 6)
    call ForcePlayerStartLocation(Player(8), 6)
    call SetPlayerColor(Player(8), ConvertPlayerColor(8))
    call SetPlayerRacePreference(Player(8), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(8), false)
    call SetPlayerController(Player(8), MAP_CONTROL_COMPUTER)

    // Player 9
    call SetPlayerStartLocation(Player(9), 7)
    call ForcePlayerStartLocation(Player(9), 7)
    call SetPlayerColor(Player(9), ConvertPlayerColor(9))
    call SetPlayerRacePreference(Player(9), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(9), false)
    call SetPlayerController(Player(9), MAP_CONTROL_COMPUTER)

    // Player 10
    call SetPlayerStartLocation(Player(10), 8)
    call ForcePlayerStartLocation(Player(10), 8)
    call SetPlayerColor(Player(10), ConvertPlayerColor(10))
    call SetPlayerRacePreference(Player(10), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(10), false)
    call SetPlayerController(Player(10), MAP_CONTROL_COMPUTER)

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_106
    call SetPlayerTeam(Player(0), 0)
    call SetPlayerState(Player(0), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(1), 0)
    call SetPlayerState(Player(1), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(2), 0)
    call SetPlayerState(Player(2), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(3), 0)
    call SetPlayerState(Player(3), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(4), 0)
    call SetPlayerState(Player(4), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(9), 0)
    call SetPlayerState(Player(9), PLAYER_STATE_ALLIED_VICTORY, 1)

    //   Allied
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(4), true)

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(4), true)

    // Force: TRIGSTR_103
    call SetPlayerTeam(Player(6), 1)

    // Force: TRIGSTR_105
    call SetPlayerTeam(Player(8), 2)

    // Force: TRIGSTR_267
    call SetPlayerTeam(Player(10), 3)

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount(0, 4)
    call SetStartLocPrio(0, 0, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(0, 3, 4, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(1, 4)
    call SetStartLocPrio(1, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(1, 3, 4, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(2, 4)
    call SetStartLocPrio(2, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(2, 3, 4, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(3, 4)
    call SetStartLocPrio(3, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(3, 3, 4, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(4, 4)
    call SetStartLocPrio(4, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 1, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 2, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(4, 3, 3, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(5, 5)
    call SetStartLocPrio(5, 0, 1, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(5, 1, 4, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(5, 2, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(5, 3, 8, MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(6, 8)
    call SetStartLocPrio(6, 0, 1, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 4, 5, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(6, 5, 7, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(6, 6, 8, MAP_LOC_PRIO_HIGH)

    call SetStartLocPrioCount(7, 5)
    call SetStartLocPrio(7, 0, 1, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(7, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 2, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(7, 3, 8, MAP_LOC_PRIO_LOW)

    call SetStartLocPrioCount(8, 5)
    call SetStartLocPrio(8, 0, 1, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 1, 2, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 2, 4, MAP_LOC_PRIO_LOW)
    call SetStartLocPrio(8, 3, 5, MAP_LOC_PRIO_LOW)
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds(- 11776.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), - 12032.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 11520.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 11264.0 - GetCameraMargin(CAMERA_MARGIN_TOP), - 11776.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 11264.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 11520.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), - 12032.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
    call NewSoundEnvironment("Default")
    call SetAmbientDaySound("IceCrownDay")
    call SetAmbientNightSound("IceCrownNight")
    call SetMapMusic("Music", true, 0)
    call InitSounds()
    call CreateRegions()
    call CreateCameras()
    call CreateAllDestructables()
    call CreateAllItems()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs745158250")
call ExecuteFunc("TimerUtils__init")

    call InitGlobals()
    call InitCustomTriggers()
    call RunInitializationTriggers()

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName("TRIGSTR_001")
    call SetMapDescription("TRIGSTR_003")
    call SetPlayers(9)
    call SetTeams(9)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)

    call DefineStartLocation(0, 192.0, - 1600.0)
    call DefineStartLocation(1, 192.0, - 1600.0)
    call DefineStartLocation(2, 192.0, - 1600.0)
    call DefineStartLocation(3, 192.0, - 1600.0)
    call DefineStartLocation(4, 192.0, - 1600.0)
    call DefineStartLocation(5, 192.0, - 1600.0)
    call DefineStartLocation(6, 192.0, - 1600.0)
    call DefineStartLocation(7, 192.0, - 1600.0)
    call DefineStartLocation(8, 192.0, - 1600.0)

    // Player setup
    call InitCustomPlayerSlots()
    call InitCustomTeams()
    call InitAllyPriorities()
endfunction




//Struct method generated initializers/callers:

//Functions for BigArrays:
function sa__RealAbilityBonus_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
            call BJDebugMsg("RealAbilityBonus missing AbilityCode!")
set f__result_integer= - 1
   return true
endfunction
function sa__RealAbilityBonus_Field takes nothing returns boolean
local integer this=f__arg_this
            call BJDebugMsg("RealAbilityBonus missing Field!")
set f__result_abilityreallevelfield= null
   return true
endfunction
function sa__RealAbilityBonus_Set takes nothing returns boolean
    set f__result_real=s__RealAbilityBonus_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__RealAbilityBonus_Get takes nothing returns boolean
    set f__result_real=s__RealAbilityBonus_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__IntegerAbilityBonus_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
            call BJDebugMsg("IntegerAbilityBonus missing AbilityCode!")
set f__result_integer= - 1
   return true
endfunction
function sa__IntegerAbilityBonus_Field takes nothing returns boolean
local integer this=f__arg_this
            call BJDebugMsg("IntegerAbilityBonus missing Field!")
set f__result_abilityintegerlevelfield= null
   return true
endfunction
function sa__IntegerAbilityBonus_Set takes nothing returns boolean
    set f__result_real=s__IntegerAbilityBonus_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__IntegerAbilityBonus_Get takes nothing returns boolean
    set f__result_real=s__IntegerAbilityBonus_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__IntegerAbilityBonus_IsIntegerBonus takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__MetroidvaniaController_tryToExecuteAction takes nothing returns boolean
local integer this=f__arg_this
local integer action=f__arg_integer1
            if not s__MetroidvaniaController_isDoingAction[this] and action > 0 and s__HeroActionBase_isCastable(action) then
                set s__MetroidvaniaController_currentAction[this]=action
                set s__MetroidvaniaController_isDoingAction[this]=true
                call s__MetroidvaniaController_updateTargetCoords(this,action)
                call s__HeroActionBase_start(action)
            endif
   return true
endfunction
function sa__MetroidvaniaController_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_attack[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_attackAlt[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_util1[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_util2[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_dash[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_interact[this])
            call sc__HeroActionBase_updateAbilityDetails(s__MetroidvaniaController_map[this])
   return true
endfunction
function sa__MetroidvaniaController_getAttack takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_attack[this]
   return true
endfunction
function sa__MetroidvaniaController_getAttackAlt takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_attackAlt[this]
   return true
endfunction
function sa__MetroidvaniaController_getUtil1 takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_util1[this]
   return true
endfunction
function sa__MetroidvaniaController_getUtil2 takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_util2[this]
   return true
endfunction
function sa__MetroidvaniaController_getDash takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_dash[this]
   return true
endfunction
function sa__MetroidvaniaController_getInteract takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__MetroidvaniaController_interact[this]
   return true
endfunction
function sa__MetroidvaniaController_getTargetUnit takes nothing returns boolean
local integer this=f__arg_this
set f__result_unit= s__MetroidvaniaController_target[this]
   return true
endfunction
function sa__MetroidvaniaController_getHero takes nothing returns boolean
local integer this=f__arg_this
set f__result_unit= s__MetroidvaniaController_u[this]
   return true
endfunction
function sa__MetroidvaniaController_setTargetUnit takes nothing returns boolean
    set s__MetroidvaniaController_target[(f__arg_this)]=(f__arg_unit1) // INLINED!!
   return true
endfunction
function sa__MetroidvaniaController_getMetroidvaniaController takes nothing returns boolean
local player p=f__arg_player1
set f__result_integer= (GetPlayerId(p))
   return true
endfunction
function sa__HeroStatsCore_coresAppliedToStat takes nothing returns boolean
local player p=f__arg_player1
local integer statIndex=f__arg_integer1
set f__result_integer= s__HeroStatsCore_coresApplied[GetPlayerId(p) * STAT_COUNT + statIndex]
   return true
endfunction
function sa__BonusSystemSpeed_IsIntegerBonus takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__BonusSystemSpeed_Get takes nothing returns boolean
    set f__result_real=s__BonusSystemSpeed_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BonusSystemSpeed_Set takes nothing returns boolean
    set f__result_real=s__BonusSystemSpeed_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__BonusSystemPower_IsIntegerBonus takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__BonusSystemPower_Get takes nothing returns boolean
    set f__result_real=s__BonusSystemPower_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BonusSystemPower_Set takes nothing returns boolean
    set f__result_real=s__BonusSystemPower_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__BonusMana_IsIntegerBonus takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__BonusMana_Get takes nothing returns boolean
    set f__result_real=s__BonusMana_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BonusMana_Set takes nothing returns boolean
    set f__result_real=s__BonusMana_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__BonusHealth_IsIntegerBonus takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__BonusHealth_Get takes nothing returns boolean
    set f__result_real=s__BonusHealth_Get(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__BonusHealth_Set takes nothing returns boolean
    set f__result_real=s__BonusHealth_Set(f__arg_this,f__arg_unit1,f__arg_real1)
   return true
endfunction
function sa__BonusManaRegen_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__MANAREGEN_ABILITY
   return true
endfunction
function sa__BonusManaRegen_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityreallevelfield= ExtendableBonusesBasicBonuses__MANAREGEN_FIELD
   return true
endfunction
function sa__BonusHealthRegen_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__HEALTHREGEN_ABILITY
   return true
endfunction
function sa__BonusHealthRegen_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityreallevelfield= ExtendableBonusesBasicBonuses__HEALTHREGEN_FIELD
   return true
endfunction
function sa__BonusAttackSpeed_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__ATTACKSPEED_ABILITY
   return true
endfunction
function sa__BonusAttackSpeed_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityreallevelfield= ExtendableBonusesBasicBonuses__ATTACKSPEED_FIELD
   return true
endfunction
function sa__BonusIntelligence_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__STATS_ABILITY
   return true
endfunction
function sa__BonusIntelligence_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__INTELLIGENCE_FIELD
   return true
endfunction
function sa__BonusStrength_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__STATS_ABILITY
   return true
endfunction
function sa__BonusStrength_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__STRENGTH_FIELD
   return true
endfunction
function sa__BonusAgility_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__STATS_ABILITY
   return true
endfunction
function sa__BonusAgility_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__AGILITY_FIELD
   return true
endfunction
function sa__BonusSightRange_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__SIGHT_RANGE_ABILITY
   return true
endfunction
function sa__BonusSightRange_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__SIGHT_RANGE_FIELD
   return true
endfunction
function sa__BonusMovementSpeed_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__MOVEMENTSPEED_ABILITY
   return true
endfunction
function sa__BonusMovementSpeed_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__MOVEMENTSPEED_FIELD
   return true
endfunction
function sa__BonusArmor_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__ARMOR_ABILITY
   return true
endfunction
function sa__BonusArmor_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__ARMOR_FIELD
   return true
endfunction
function sa__BonusDamage_AbilityCode takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= ExtendableBonusesBasicBonuses__DAMAGE_ABILITY
   return true
endfunction
function sa__BonusDamage_Field takes nothing returns boolean
local integer this=f__arg_this
set f__result_abilityintegerlevelfield= ExtendableBonusesBasicBonuses__DAMAGE_FIELD
   return true
endfunction
function sa__HeroActionBase_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
            call BJDebugMsg("!!! NO UPDATE FUNCTION IMPLEMENTED !!!")
   return true
endfunction
function sa__HeroActionBase_create takes nothing returns boolean
    set f__result_integer=s__HeroActionBase_create(f__arg_unit1,f__arg_integer1,f__arg_string1)
   return true
endfunction
function sa__Missiles_terminate takes nothing returns boolean
local integer this=f__arg_this
        local integer aux
        if s__Missiles_allocated[this] and s__Missiles_launched[this] then
            set s__Missiles_allocated[this]=false
            if s__Missiles_pkey[this] != - 1 then
                set aux=s__Missiles_frozen[s__Missiles_pid]
                set s__Missiles_pkey[aux]=s__Missiles_pkey[this]
                set s__Missiles_frozen[s__Missiles_pkey[this]]=s__Missiles_frozen[s__Missiles_pid]
                set s__Missiles_pid=s__Missiles_pid - 1
                set s__Missiles_pkey[this]=- 1
            endif
            if (st__Missiles__MissileEvents_onRemove[si__Missiles__MissileEvents_type[this]]!=null) then
                call sc__Missiles__MissileEvents_onRemove(this)
            endif
            if s__Missiles_dummy[this] != null then
                call s__Missiles__Pool_recycle(s__Missiles_dummy[this])
            endif
            set aux=s__Missiles_collection[s__Missiles_count]
            set s__Missiles_index[aux]=s__Missiles_index[this]
            set s__Missiles_collection[s__Missiles_index[this]]=s__Missiles_collection[s__Missiles_count]
            set s__Missiles_count=s__Missiles_count - 1
            set s__Missiles_index[this]=- 1
            call s__Missiles__Coordinates_deallocate((s__Missiles_origin[this])) // INLINED!!
            call s__Missiles__Coordinates_deallocate((s__Missiles_impact[this])) // INLINED!!
            call s__MissileEffect_destroy(s__Missiles_effect[this])
            call sc__Missiles_reset(this)
            call FlushChildHashtable(s__Missiles_table, this)
        endif
   return true
endfunction
function sa__Missiles_reset takes nothing returns boolean
local integer this=f__arg_this
            set s__Missiles_launched[this]=false
            set s__Missiles_finished[this]=false
            set s__Missiles_collideZ[this]=false
            set s__Missiles_paused[this]=false
            set s__Missiles_roll[this]=false
            set s__Missiles_source[this]=null
            set s__Missiles_target[this]=null
            set s__Missiles_owner[this]=null
            set s__Missiles_dummy[this]=null
            set s__Missiles_open[this]=0.
            set s__Missiles_height[this]=0.
            set s__Missiles_veloc[this]=0.
            set s__Missiles_acceleration[this]=0.
            set s__Missiles_collision[this]=0.
            set s__Missiles_damage[this]=0.
            set s__Missiles_travel[this]=0.
            set s__Missiles_turn[this]=0.
            set s__Missiles_time[this]=0.
            set s__Missiles_sight[this]=0.
            set s__Missiles_data[this]=0
            set s__Missiles_type[this]=0
            set s__Missiles_tileset[this]=0
            set s__Missiles_pkey[this]=- 1
            set s__Missiles_index[this]=- 1
   return true
endfunction
function sa__Missiles_move takes nothing returns boolean

            local integer j= 0
            local integer i
            local integer k
            local unit u
            local real a
            local real d
            local real s
            local real h
            local real c
            local real dx
            local real dy
            local real vel
            local real yaw
            local real pitch
            local integer missile
            local integer o
            local integer this
            if Missiles_SWEET_SPOT > 0 then
                set i=s__Missiles_last
            else
                set i=0
            endif
            loop
                exitwhen ( ( j >= Missiles_SWEET_SPOT and Missiles_SWEET_SPOT > 0 ) or j > s__Missiles_id )
                    set this=s__Missiles_missiles[i]
                    set s__Missiles_temp=this
                    if s__Missiles_allocated[this] and not s__Missiles_paused[this] then
        set o=s__Missiles_origin[this]
        set h=s__Missiles_height[this]
        set c=s__Missiles_open[this]
        set d=s__Missiles__Coordinates_distance[o]
        if (st__Missiles__MissileEvents_onHit[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                call GroupEnumUnitsInRange(s__Missiles_group, s__Missiles_x[this], s__Missiles_y[this], s__Missiles_collision[this] + Missiles__COLLISION_SIZE, null)
                loop
                    set u=FirstOfGroup(s__Missiles_group)
                    exitwhen u == null
                        if not HaveSavedBoolean(s__Missiles_table, this, GetHandleId(u)) then
                            if IsUnitInRangeXY(u, s__Missiles_x[this], s__Missiles_y[this], s__Missiles_collision[this]) then
                                if s__Missiles_collideZ[this] then
                                    set dx=Missiles__GetLocZ(GetUnitX(u) , GetUnitY(u)) + GetUnitFlyHeight(u)
                                    set dy=BlzGetUnitCollisionSize(u)
                                    if dx + dy >= s__Missiles_z[this] - s__Missiles_collision[this] and dx <= s__Missiles_z[this] + s__Missiles_collision[this] then
                                        call SaveBoolean(s__Missiles_table, this, GetHandleId(u), true)
                                        if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onHit(this,u) then
                                            call s__Missiles_terminate(this)
                                            exitwhen true
                                        endif
                                    endif
                                else
                                    call SaveBoolean(s__Missiles_table, this, GetHandleId(u), true)
                                    if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onHit(this,u) then
                                        call s__Missiles_terminate(this)
                                        exitwhen true
                                    endif
                                endif
                            endif
                        endif
                    call GroupRemoveUnit(s__Missiles_group, u)
                endloop
            endif
        endif
        if (st__Missiles__MissileEvents_onMissile[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set k=0
                loop
                    exitwhen k > s__Missiles_count
                        set missile=s__Missiles_collection[k]
                        if missile != this then
                            if not HaveSavedBoolean(s__Missiles_table, this, missile) then
                                set dx=s__Missiles_x[missile] - s__Missiles_x[this]
                                set dy=s__Missiles_y[missile] - s__Missiles_y[this]
                                if SquareRoot(dx * dx + dy * dy) <= s__Missiles_collision[this] then
                                    call SaveBoolean(s__Missiles_table, this, missile, true)
                                    if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onMissile(this,missile) then
                                        call s__Missiles_terminate(this)
                                        exitwhen true
                                    endif
                                endif
                            endif
                        endif
                    set k=k + 1
                endloop
            endif
        endif
        if (st__Missiles__MissileEvents_onDestructable[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set dx=s__Missiles_collision[this] + 64.0
                call SetRect(s__Missiles_rect, s__Missiles_x[this] - dx, s__Missiles_y[this] - dx, s__Missiles_x[this] + dx, s__Missiles_y[this] + dx)
                call EnumDestructablesInRect(s__Missiles_rect, null, function s__Missiles_onDest)
            endif
        endif
        if (st__Missiles__MissileEvents_onItem[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and s__Missiles_collision[this] > 0 then
                set dx=s__Missiles_collision[this]
                call SetRect(s__Missiles_rect, s__Missiles_x[this] - dx, s__Missiles_y[this] - dx, s__Missiles_x[this] + dx, s__Missiles_y[this] + dx)
                call EnumItemsInRect(s__Missiles_rect, null, function s__Missiles_onItems)
            endif
        endif
        if (st__Missiles__MissileEvents_onCliff[si__Missiles__MissileEvents_type[this]]!=null) then
            set dx=GetTerrainCliffLevel(s__Missiles_nextX[this], s__Missiles_nextY[this])
            set dy=GetTerrainCliffLevel(s__Missiles_x[this], s__Missiles_y[this])
            if dy < dx and s__Missiles_z[this] < ( dx - (GetTerrainCliffLevel(s__WorldBounds_maxX, s__WorldBounds_maxY)) ) * bj_CLIFFHEIGHT then // INLINED!!
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onCliff(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        endif
        if (st__Missiles__MissileEvents_onTerrain[si__Missiles__MissileEvents_type[this]]!=null) then
            if Missiles__GetLocZ(s__Missiles_x[this] , s__Missiles_y[this]) > s__Missiles_z[this] then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onTerrain(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        endif
        if (st__Missiles__MissileEvents_onTileset[si__Missiles__MissileEvents_type[this]]!=null) then
            set k=GetTerrainType(s__Missiles_x[this], s__Missiles_y[this])
            if k != s__Missiles_tileset[this] then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onTileset(this,k) then
                    call s__Missiles_terminate(this)
                endif
            endif
            set s__Missiles_tileset[this]=k
        endif
        if (st__Missiles__MissileEvents_onPeriod[si__Missiles__MissileEvents_type[this]]!=null) then
            if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onPeriod(this) then
                call s__Missiles_terminate(this)
            endif
        endif
        set u=s__Missiles_target[this]
        if u != null and GetUnitTypeId(u) != 0 then
            call s__Missiles__Coordinates_move(s__Missiles_impact[this],GetUnitX(u) , GetUnitY(u) , GetUnitFlyHeight(u) + s__Missiles_toZ[this])
            set dx=s__Missiles__Coordinates_x[s__Missiles_impact[this]] - s__Missiles_nextX[this]
            set dy=s__Missiles__Coordinates_y[s__Missiles_impact[this]] - s__Missiles_nextY[this]
            set a=Atan2(dy, dx)
            set s__Missiles_travel[this]=s__Missiles__Coordinates_distance[o] - SquareRoot(dx * dx + dy * dy)
        else
            set a=s__Missiles__Coordinates_angle[o]
            set s__Missiles_target[this]=null
        endif
        if s__Missiles_turn[this] != 0 and not ( Cos(s__Missiles_cA[this] - a) >= Cos(s__Missiles_turn[this]) ) then
            if Sin(a - s__Missiles_cA[this]) >= 0 then
                set s__Missiles_cA[this]=s__Missiles_cA[this] + s__Missiles_turn[this]
            else
                set s__Missiles_cA[this]=s__Missiles_cA[this] - s__Missiles_turn[this]
            endif
        else
            set s__Missiles_cA[this]=a
        endif
        set vel=s__Missiles_veloc[this] * s__Missiles_dilation
        set yaw=s__Missiles_cA[this]
        set s=s__Missiles_travel[this] + vel
        set s__Missiles_veloc[this]=s__Missiles_veloc[this] + s__Missiles_acceleration[this]
        set s__Missiles_travel[this]=s
        set pitch=s__Missiles__Coordinates_alpha[o]
        set s__Missiles_prevX[this]=s__Missiles_x[this]
        set s__Missiles_prevY[this]=s__Missiles_y[this]
        set s__Missiles_prevZ[this]=s__Missiles_z[this]
        set s__Missiles_x[this]=s__Missiles_nextX[this]
        set s__Missiles_y[this]=s__Missiles_nextY[this]
        set s__Missiles_z[this]=s__Missiles_nextZ[this]
        set s__Missiles_nextX[this]=s__Missiles_x[this] + vel * Cos(yaw)
        set s__Missiles_nextY[this]=s__Missiles_y[this] + vel * Sin(yaw)
        if h != 0 or s__Missiles__Coordinates_slope[o] != 0 then
            set s__Missiles_nextZ[this]=4 * h * s * ( d - s ) / ( d * d ) + s__Missiles__Coordinates_slope[o] * s + s__Missiles__Coordinates_z[o]
            set pitch=pitch - Atan(( ( 4 * h ) * ( 2 * s - d ) ) / ( d * d ))
        endif
        if c != 0 then
            set dx=4 * c * s * ( d - s ) / ( d * d )
            set a=yaw + bj_PI / 2
            set s__Missiles_x[this]=s__Missiles_x[this] + dx * Cos(a)
            set s__Missiles_y[this]=s__Missiles_y[this] + dx * Sin(a)
            set yaw=yaw + Atan(- ( ( 4 * c ) * ( 2 * s - d ) ) / ( d * d ))
        endif
        if s >= d - 0.0001 then
            set s__Missiles_finished[this]=true
            if (st__Missiles__MissileEvents_onFinish[si__Missiles__MissileEvents_type[this]]!=null) then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onFinish(this) then
                    call s__Missiles_terminate(this)
                endif
            else
                call s__Missiles_terminate(this)
            endif
        else
            if not s__Missiles_roll[this] then
                call s__MissileEffect_orient(s__Missiles_effect[this],yaw , - pitch , 0)
            else
                call s__MissileEffect_orient(s__Missiles_effect[this],yaw , - pitch , Atan2(c, h))
            endif
        endif
        if not s__MissileEffect_move(s__Missiles_effect[this],s__Missiles_x[this] , s__Missiles_y[this] , s__Missiles_z[this]) then
            if (st__Missiles__MissileEvents_onBoundaries[si__Missiles__MissileEvents_type[this]]!=null) then
                if s__Missiles_allocated[this] and sc__Missiles__MissileEvents_onBoundaries(this) then
                    call s__Missiles_terminate(this)
                endif
            endif
        else
            if s__Missiles_dummy[this] != null then
                call SetUnitX(s__Missiles_dummy[this], s__Missiles_x[this])
                call SetUnitY(s__Missiles_dummy[this], s__Missiles_y[this])
            endif
        endif
                    else
                        set i=s__Missiles_remove(this,i)
                        set j=j - 1
                    endif
                set i=i + 1
                set j=j + 1
                if i > s__Missiles_id and Missiles_SWEET_SPOT > 0 then
                    set i=0
                endif
            endloop
            set s__Missiles_last=i
            set u=null
   return true
endfunction
function sa__Missiles_create takes nothing returns boolean
local real x=f__arg_real1
local real y=f__arg_real2
local real z=f__arg_real3
local real toX=f__arg_real4
local real toY=f__arg_real5
local real toZ=f__arg_real6
            local integer this= s__Missiles__allocate()
            call s__Missiles_reset(this)
            set s__Missiles_origin[this]=s__Missiles__Coordinates_create(x , y , z)
            set s__Missiles_impact[this]=s__Missiles__Coordinates_create(toX , toY , toZ)
            set s__Missiles_effect[this]=s__MissileEffect_create(x , y , s__Missiles__Coordinates_z[s__Missiles_origin[this]])
            call s__Missiles__Coordinates_link(s__Missiles_origin[this] , s__Missiles_impact[this])
            set s__Missiles_allocated[this]=true
            set s__Missiles_cA[this]=s__Missiles__Coordinates_angle[s__Missiles_origin[this]]
            set s__Missiles_x[this]=x
            set s__Missiles_y[this]=y
            set s__Missiles_z[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_prevX[this]=x
            set s__Missiles_prevY[this]=y
            set s__Missiles_prevZ[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_nextX[this]=x
            set s__Missiles_nextY[this]=y
            set s__Missiles_nextZ[this]=s__Missiles__Coordinates_z[s__Missiles_impact[this]]
            set s__Missiles_toZ[this]=toZ
set f__result_integer= this
   return true
endfunction
function sa__FinalBossHoming_onFinish takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__FinalBossHoming_onHit takes nothing returns boolean
    set f__result_boolean=s__FinalBossHoming_onHit(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__FinalBossHoming_onDestructable takes nothing returns boolean
    set f__result_boolean=s__FinalBossHoming_onDestructable(f__arg_this,f__arg_destructable1)
   return true
endfunction
function sa__FinalBossHoming_onTerrain takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__FinalBossHoming_onTileset takes nothing returns boolean
local integer this=f__arg_this
local integer tileset=f__arg_integer1
        if tileset == 'cOc1' then
set f__result_boolean= true
return true
        endif
set f__result_boolean= false
   return true
endfunction
function sa__HeroAttackBasic_onFinish takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__HeroAttackBasic_onHit takes nothing returns boolean
    set f__result_boolean=s__HeroAttackBasic_onHit(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__HeroAttackBasic_onDestructable takes nothing returns boolean
    set f__result_boolean=s__HeroAttackBasic_onDestructable(f__arg_this,f__arg_destructable1)
   return true
endfunction
function sa__HeroAttackBasic_onTerrain takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__HeroAttackBasic_onTileset takes nothing returns boolean
local integer this=f__arg_this
local integer tileset=f__arg_integer1
        if tileset == 'cOc1' then
set f__result_boolean= true
return true
        endif
set f__result_boolean= false
   return true
endfunction
function sa__HeroAttackBasicAction_animationSpeed takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemSpeed))) // INLINED!!
   return true
endfunction
function sa__HeroAttackBasicAction_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
        local real duration= 0.8 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] )) // INLINED!!
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.33 * duration , duration , duration * 1.25)
        set s__HeroActionBase_energyCost[this]=3.5
   return true
endfunction
function sa__HeroAttackBasicAction_onStart takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_ATTACK_BASIC , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , (1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemSpeed)))) , tx , ty) // INLINED!!
        set p=null
   return true
endfunction
function sa__HeroAttackBasicAction_onActionPoint takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real dmg= s__HeroAttackBasicAction_damageCalculation(this)
        call s__HeroAttackBasic_fire(s__HeroActionBase_u[this] , tx , ty , dmg , 0.02 , 1800. , 1400.)
        set p=null
   return true
endfunction
function sa__HeroAttackBasicAction_abilityText takes nothing returns boolean
local integer this=f__arg_this
        local string s= "Fires a plama bolt towards targeted unit or mouse pointer. |nDamage: " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) , STAT_INDEX_FIREPOWER) + ".|n" // INLINED!!
        set s=s + CNOTE + Si2Name(STAT_INDEX_FIREPOWER) + "-percent is increased by 1% per " + Si2Name(STAT_INDEX_SYSTEM_POWER)
set f__result_string= s
   return true
endfunction
function sa__HeroAttackBasicAction_abilityName takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "[Q] Plasma Bolt"
   return true
endfunction
function sa__HeroAttackRapidAction_animationSpeed takes nothing returns boolean
local integer this=f__arg_this
set f__result_real= 1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemSpeed))) // INLINED!!
   return true
endfunction
function sa__HeroAttackRapidAction_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
        local real duration= 0.8 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] )) // INLINED!!
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.33 * duration , duration , duration * 1.25)
        set s__HeroActionBase_energyCost[this]=3.5
   return true
endfunction
function sa__HeroAttackRapidAction_onStart takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_ATTACK_BASIC , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , (1.0 + 0.01 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemSpeed)))) , tx , ty) // INLINED!!
        set p=null
   return true
endfunction
function sa__HeroAttackRapidAction_onActionPoint takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real dmg= s__HeroAttackRapidAction_damageCalculation(this)
        call s__HeroAttackBasic_fire(s__HeroActionBase_u[this] , tx , ty , dmg , 0.02 , 1800. , 1400.)
        set p=null
   return true
endfunction
function sa__HeroAttackRapidAction_abilityText takes nothing returns boolean
local integer this=f__arg_this
        local string s= "Fires a plama bolt towards targeted unit or mouse pointer. |nDamage: " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , (1.0 + (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower))) * 0.01) , STAT_INDEX_FIREPOWER) + ".|n" // INLINED!!
        set s=s + CNOTE + Si2Name(STAT_INDEX_FIREPOWER) + "-percent is increased by 1% per " + Si2Name(STAT_INDEX_SYSTEM_POWER)
set f__result_string= s
   return true
endfunction
function sa__HeroAttackRapidAction_abilityName takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "[Q] Plasma Bolt"
   return true
endfunction
function sa__HeroBasicBombAction_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.0 , 0.1 , 5.0 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] ))) // INLINED!!
        set s__HeroActionBase_energyCost[this]=12.0
   return true
endfunction
function sa__HeroBasicBombAction_onStart takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real x= GetUnitX(s__HeroActionBase_u[this])
        local real y= GetUnitY(s__HeroActionBase_u[this])
        local real angle= Atan2(ty - y, tx - x)
        local real ux= x + 64. * Cos(angle)
        local real uy= y + 64. * Sin(angle)
        local unit bomb
        call updateWalkablePoint(ux , uy)
        set bomb=CreateUnit(p, BOMB_UNIT_TYPE, GetLocationX(walkablePoint), GetLocationY(walkablePoint), 0.0)
        call UnitApplyTimedLife(bomb, TIMED_LIFE, 2.0)
        set bomb=null
        set p=null
   return true
endfunction
function sa__HeroBasicBombAction_create takes nothing returns boolean
    set f__result_integer=s__HeroBasicBombAction_create(f__arg_unit1)
   return true
endfunction
function sa__HeroBasicBombAction_getDamage takes nothing returns boolean
    set f__result_real=s__HeroBasicBombAction_getDamage(f__arg_unit1)
   return true
endfunction
function sa__HeroBasicBombAction_abilityText takes nothing returns boolean
local integer this=f__arg_this
        local real dmg= s__HeroBasicBombAction_getDamage(s__HeroActionBase_u[this])
        local string s= "Places a bomb at your current location, exploding after 2 seconds, dealing damage and slowing in a 200 unit radius.|nDamage: " + (I2S(R2I(((dmg)*1.0) + 0.1))) + " (" + (I2S(R2I(((s__HeroBasicBombAction_baseDmg)*1.0) + 0.1))) + " + " + ScalingText(GetDamage(s__HeroActionBase_u[this]) , s__HeroBasicBombAction_percentDmg , STAT_INDEX_FIREPOWER) // INLINED!!
        set s=s + " + " + ScalingText((s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) , s__HeroBasicBombAction_percentPower , STAT_INDEX_SYSTEM_POWER) + ").|nSlows: 40% for 1.5 seconds.|nThe bomb is able to destroy some webs, rocks and debries." // INLINED!!
set f__result_string= s
   return true
endfunction
function sa__HeroBasicBombAction_abilityName takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "[E] Energy Bomb"
   return true
endfunction
function sa__HeroBasicDash_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.320 , 0.360 , 2.5 * (100. / ( 100. + systemspeed[GetUnitUserData((s__HeroActionBase_u[this]))] ))) // INLINED!!
        set s__HeroActionBase_energyCost[this]=RMaxBJ(11.0 - R2I((s__ExtendableBonus_Get((s__HeroActionBase_u[this] ) , ( si__BonusSystemPower))) + 0.01) / 10, 3.) // INLINED!!
   return true
endfunction
function sa__HeroBasicDash_onStart takes nothing returns boolean
local integer this=f__arg_this
        local player p= GetOwningPlayer(s__HeroActionBase_u[this])
        local real tx= (s__MetroidvaniaController_currentActionTargetX[(GetPlayerId((p)))]) // INLINED!!
        local real ty= (s__MetroidvaniaController_currentActionTargetY[(GetPlayerId((p)))]) // INLINED!!
        local real ux= GetUnitX(s__HeroActionBase_u[this])
        local real uy= GetUnitY(s__HeroActionBase_u[this])
        local real angle= Atan2(ty - uy, tx - ux)
        call OrderAbilWithSpeed(s__HeroActionBase_u[this] , ABIL_SPELL_SLAM , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , 1.25 , tx , ty)
        call s__KnockbackTZ_doKnockback(s__HeroActionBase_u[this] , angle , s__HeroBasicDash_dashSpeed(this) , s__CooldownDetails_actionDuration[s__HeroActionBase_cooldownDetails[this]] , 0. , 1. , 8.)
        if GetRandomInt(0, 1) == 1 then
            call playSound3d(ux , uy , SOUND_DASH1)
        else
            call playSound3d(ux , uy , SOUND_DASH2)
        endif
        set p=null
   return true
endfunction
function sa__HeroBasicDash_abilityText takes nothing returns boolean
local integer this=f__arg_this
        local string s= "Dashes towards mouse pointer over 0.36 seconds. Dashed distance: " + ScalingText((GetUnitMoveSpeed((s__HeroActionBase_u[this]))) , (1.1 + 0.005 * (s__ExtendableBonus_Get((s__HeroActionBase_u[(this)] ) , ( si__BonusSystemPower)))) , STAT_INDEX_MOBILITY) + ".|n" + CNOTE + Si2Name(STAT_INDEX_MOBILITY) + "-percent is increased by 0.5% per " // INLINED!!
        set s=s + Si2Name(STAT_INDEX_SYSTEM_POWER) + ", and " + Si2Color(STAT_INDEX_ENERGY) + "Energy-cost" + CNOTE + " reduced by 1 per 10 " + Si2Name(STAT_INDEX_SYSTEM_POWER) + " (minimum 3 Energy)"
set f__result_string= s
   return true
endfunction
function sa__HeroBasicDash_abilityName takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "[D] Dash"
   return true
endfunction
function sa__HeroShockBlast_onFinish takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__HeroShockBlast_onHit takes nothing returns boolean
    set f__result_boolean=s__HeroShockBlast_onHit(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__HeroShockBlast_onDestructable takes nothing returns boolean
    set f__result_boolean=s__HeroShockBlast_onDestructable(f__arg_this,f__arg_destructable1)
   return true
endfunction
function sa__HeroShockBlast_onTerrain takes nothing returns boolean
local integer this=f__arg_this
set f__result_boolean= true
   return true
endfunction
function sa__HeroShockBlast_onTileset takes nothing returns boolean
local integer this=f__arg_this
local integer tileset=f__arg_integer1
        if tileset == 'cOc1' then
set f__result_boolean= true
return true
        endif
set f__result_boolean= false
   return true
endfunction
function sa__InteractAction_updateAbilityDetails takes nothing returns boolean
local integer this=f__arg_this
        call s__CooldownDetails_update(s__HeroActionBase_cooldownDetails[this],0.1 , 0.2 , 1.0)
   return true
endfunction
function sa__InteractAction_onStart takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__InteractAction_onActionPoint takes nothing returns boolean
local integer this=f__arg_this
        local real x= GetUnitX(s__HeroActionBase_u[this])
        local real y= GetUnitY(s__HeroActionBase_u[this])
        call SetRect(enumRect, x - INTERACT_RANGE, y - INTERACT_RANGE, x + INTERACT_RANGE, y + INTERACT_RANGE)
        call EnumDestructablesInRect(enumRect, null, function s__InteractAction_processDestructable)
   return true
endfunction
function sa__InteractAction_abilityText takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "Open or closes nearby smaller doors and interact with computers connected with cables."
   return true
endfunction
function sa__InteractAction_abilityName takes nothing returns boolean
local integer this=f__arg_this
set f__result_string= "[F] Interact"
   return true
endfunction
function sa___prototype2_DamageEngine_RegisterFromHook takes nothing returns boolean
    call DamageEngine_RegisterFromHook(f__arg_trigger1,f__arg_string1,f__arg_limitop1,f__arg_real1)
    return true
endfunction
function sa___prototype1_TimerUtils__init takes nothing returns boolean

     local integer i=0
     local integer o=- 1
     local boolean oops= false
        if ( TimerUtils__didinit ) then
    return true
        else
            set TimerUtils__didinit=true
        endif
            set TimerUtils__ht=InitHashtable()
            loop
                exitwhen ( i == TimerUtils__QUANTITY )
                set s__TimerUtils__tT[i]= CreateTimer()
                call SaveInteger(TimerUtils__ht, 0, GetHandleId((s__TimerUtils__tT[i] )), ( TimerUtils__HELD)) // INLINED!!
                set i=i + 1
            endloop
            set TimerUtils__tN=TimerUtils__QUANTITY
    return true
endfunction
function sa___prototype1_KnockbackTZ__StartKnockback takes nothing returns boolean

        call TimerStart(s__KnockbackTZ_updTimer, KnockbackTZ__TICK_RATE, true, function s__KnockbackTZ_update)
    return true
endfunction
function sa___prototype9_MetroidvaniaController__controllerCallback takes nothing returns boolean
    call s__MetroidvaniaController_MetroidvaniaController__controllerCallback((f__arg_unit1) , (f__arg_integer1)) // INLINED!!
    return true
endfunction

function jasshelper__initstructs745158250 takes nothing returns nothing
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[4]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[68]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[69]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[70]=null
    set st__RealAbilityBonus_AbilityCode[4]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_AbilityCode[4],Condition( function sa__RealAbilityBonus_AbilityCode))
    call TriggerAddAction(st__RealAbilityBonus_AbilityCode[4], function sa__RealAbilityBonus_AbilityCode)
    set st__RealAbilityBonus_Field[4]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_Field[4],Condition( function sa__RealAbilityBonus_Field))
    call TriggerAddAction(st__RealAbilityBonus_Field[4], function sa__RealAbilityBonus_Field)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4]=CreateTrigger()
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[68]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[69]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[70]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4]
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4],Condition( function sa__RealAbilityBonus_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[4], function sa__RealAbilityBonus_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4]=CreateTrigger()
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[68]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[69]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[70]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4]
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4],Condition( function sa__RealAbilityBonus_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[4], function sa__RealAbilityBonus_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[4]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[68]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[69]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[70]=null
    set st__IntegerAbilityBonus_AbilityCode[5]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[5],Condition( function sa__IntegerAbilityBonus_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[5], function sa__IntegerAbilityBonus_AbilityCode)
    set st__IntegerAbilityBonus_Field[5]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[5],Condition( function sa__IntegerAbilityBonus_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[5], function sa__IntegerAbilityBonus_Field)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]=CreateTrigger()
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[61]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[62]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[63]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[64]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[65]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[66]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[67]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5]
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5],Condition( function sa__IntegerAbilityBonus_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[5], function sa__IntegerAbilityBonus_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]=CreateTrigger()
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[61]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[62]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[63]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[64]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[65]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[66]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[67]=st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5]
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5],Condition( function sa__IntegerAbilityBonus_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[5], function sa__IntegerAbilityBonus_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]=CreateTrigger()
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[61]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[62]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[63]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[64]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[65]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[66]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[67]=st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5]
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5],Condition( function sa__IntegerAbilityBonus_IsIntegerBonus))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[5], function sa__IntegerAbilityBonus_IsIntegerBonus)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[5]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[61]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[62]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[63]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[64]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[65]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[66]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[67]=null
    set st__MetroidvaniaController_tryToExecuteAction=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_tryToExecuteAction,Condition( function sa__MetroidvaniaController_tryToExecuteAction))
    set st__MetroidvaniaController_updateAbilityDetails=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_updateAbilityDetails,Condition( function sa__MetroidvaniaController_updateAbilityDetails))
    set st__MetroidvaniaController_getAttack=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getAttack,Condition( function sa__MetroidvaniaController_getAttack))
    set st__MetroidvaniaController_getAttackAlt=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getAttackAlt,Condition( function sa__MetroidvaniaController_getAttackAlt))
    set st__MetroidvaniaController_getUtil1=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getUtil1,Condition( function sa__MetroidvaniaController_getUtil1))
    set st__MetroidvaniaController_getUtil2=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getUtil2,Condition( function sa__MetroidvaniaController_getUtil2))
    set st__MetroidvaniaController_getDash=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getDash,Condition( function sa__MetroidvaniaController_getDash))
    set st__MetroidvaniaController_getInteract=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getInteract,Condition( function sa__MetroidvaniaController_getInteract))
    set st__MetroidvaniaController_getTargetUnit=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getTargetUnit,Condition( function sa__MetroidvaniaController_getTargetUnit))
    set st__MetroidvaniaController_getHero=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getHero,Condition( function sa__MetroidvaniaController_getHero))
    set st__MetroidvaniaController_setTargetUnit=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_setTargetUnit,Condition( function sa__MetroidvaniaController_setTargetUnit))
    set st__MetroidvaniaController_getMetroidvaniaController=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController_getMetroidvaniaController,Condition( function sa__MetroidvaniaController_getMetroidvaniaController))
    set st__MetroidvaniaController__ActionInterface_onStart[96]=null
    set st__MetroidvaniaController__ActionInterface_onActionPoint[96]=null
    set st__MetroidvaniaController__ActionInterface_onActionPoint[101]=null
    set st__MetroidvaniaController__ActionInterface_onActionPoint[102]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[96]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[99]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[100]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[101]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[102]=null
    set st__MetroidvaniaController__ActionInterface_onBackswing[104]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[96]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[99]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[100]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[101]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[102]=null
    set st__MetroidvaniaController__ActionInterface_onRelease[104]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[96]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[99]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[100]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[101]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[102]=null
    set st__MetroidvaniaController__ActionInterface_onCooldownFinished[104]=null
    set st__MetroidvaniaController__ActionInterface_animationSpeed[96]=null
    set st__MetroidvaniaController__ActionInterface_animationSpeed[101]=null
    set st__MetroidvaniaController__ActionInterface_animationSpeed[102]=null
    set st__MetroidvaniaController__ActionInterface_animationSpeed[104]=null
    set st__MetroidvaniaController__ActionInterface_abilityText[96]=null
    set st__MetroidvaniaController__ActionInterface_abilityName[96]=null
    set st__HeroStatsCore_coresAppliedToStat=CreateTrigger()
    call TriggerAddCondition(st__HeroStatsCore_coresAppliedToStat,Condition( function sa__HeroStatsCore_coresAppliedToStat))
    set st__Missiles__MissileEvents_onHit[87]=null
    set st__Missiles__MissileEvents_onMissile[87]=null
    set st__Missiles__MissileEvents_onMissile[98]=null
    set st__Missiles__MissileEvents_onMissile[103]=null
    set st__Missiles__MissileEvents_onMissile[105]=null
    set st__Missiles__MissileEvents_onDestructable[87]=null
    set st__Missiles__MissileEvents_onItem[87]=null
    set st__Missiles__MissileEvents_onItem[98]=null
    set st__Missiles__MissileEvents_onItem[103]=null
    set st__Missiles__MissileEvents_onItem[105]=null
    set st__Missiles__MissileEvents_onCliff[87]=null
    set st__Missiles__MissileEvents_onCliff[98]=null
    set st__Missiles__MissileEvents_onCliff[103]=null
    set st__Missiles__MissileEvents_onCliff[105]=null
    set st__Missiles__MissileEvents_onTerrain[87]=null
    set st__Missiles__MissileEvents_onTileset[87]=null
    set st__Missiles__MissileEvents_onPeriod[87]=null
    set st__Missiles__MissileEvents_onPeriod[98]=null
    set st__Missiles__MissileEvents_onPeriod[103]=null
    set st__Missiles__MissileEvents_onPeriod[105]=null
    set st__Missiles__MissileEvents_onFinish[87]=null
    set st__Missiles__MissileEvents_onBoundaries[87]=null
    set st__Missiles__MissileEvents_onBoundaries[98]=null
    set st__Missiles__MissileEvents_onBoundaries[103]=null
    set st__Missiles__MissileEvents_onBoundaries[105]=null
    set st__Missiles__MissileEvents_onPause[87]=null
    set st__Missiles__MissileEvents_onPause[98]=null
    set st__Missiles__MissileEvents_onPause[103]=null
    set st__Missiles__MissileEvents_onPause[105]=null
    set st__Missiles__MissileEvents_onResume[87]=null
    set st__Missiles__MissileEvents_onResume[98]=null
    set st__Missiles__MissileEvents_onResume[103]=null
    set st__Missiles__MissileEvents_onResume[105]=null
    set st__Missiles__MissileEvents_onRemove[87]=null
    set st__Missiles__MissileEvents_onRemove[98]=null
    set st__Missiles__MissileEvents_onRemove[103]=null
    set st__Missiles__MissileEvents_onRemove[105]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[83]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[83],Condition( function sa__BonusSystemSpeed_IsIntegerBonus))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[83], function sa__BonusSystemSpeed_IsIntegerBonus)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[83]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[83],Condition( function sa__BonusSystemSpeed_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[83], function sa__BonusSystemSpeed_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[83]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[83],Condition( function sa__BonusSystemSpeed_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[83], function sa__BonusSystemSpeed_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[83]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[82]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[82],Condition( function sa__BonusSystemPower_IsIntegerBonus))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[82], function sa__BonusSystemPower_IsIntegerBonus)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[82]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[82],Condition( function sa__BonusSystemPower_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[82], function sa__BonusSystemPower_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[82]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[82],Condition( function sa__BonusSystemPower_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[82], function sa__BonusSystemPower_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[82]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[72]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[72],Condition( function sa__BonusMana_IsIntegerBonus))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[72], function sa__BonusMana_IsIntegerBonus)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[72]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[72],Condition( function sa__BonusMana_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[72], function sa__BonusMana_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[72]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[72],Condition( function sa__BonusMana_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[72], function sa__BonusMana_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[72]=null
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[71]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[71],Condition( function sa__BonusHealth_IsIntegerBonus))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_IsIntegerBonus[71], function sa__BonusHealth_IsIntegerBonus)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[71]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[71],Condition( function sa__BonusHealth_Get))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Get[71], function sa__BonusHealth_Get)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[71]=CreateTrigger()
    call TriggerAddCondition(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[71],Condition( function sa__BonusHealth_Set))
    call TriggerAddAction(st__ExtendableBonusSystem_ExtendableBonusPlugin_Set[71], function sa__BonusHealth_Set)
    set st__ExtendableBonusSystem_ExtendableBonusPlugin_onDestroy[71]=null
    set st__RealAbilityBonus_AbilityCode[70]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_AbilityCode[70],Condition( function sa__BonusManaRegen_AbilityCode))
    call TriggerAddAction(st__RealAbilityBonus_AbilityCode[70], function sa__BonusManaRegen_AbilityCode)
    set st__RealAbilityBonus_Field[70]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_Field[70],Condition( function sa__BonusManaRegen_Field))
    call TriggerAddAction(st__RealAbilityBonus_Field[70], function sa__BonusManaRegen_Field)
    set st__RealAbilityBonus_AbilityCode[69]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_AbilityCode[69],Condition( function sa__BonusHealthRegen_AbilityCode))
    call TriggerAddAction(st__RealAbilityBonus_AbilityCode[69], function sa__BonusHealthRegen_AbilityCode)
    set st__RealAbilityBonus_Field[69]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_Field[69],Condition( function sa__BonusHealthRegen_Field))
    call TriggerAddAction(st__RealAbilityBonus_Field[69], function sa__BonusHealthRegen_Field)
    set st__RealAbilityBonus_AbilityCode[68]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_AbilityCode[68],Condition( function sa__BonusAttackSpeed_AbilityCode))
    call TriggerAddAction(st__RealAbilityBonus_AbilityCode[68], function sa__BonusAttackSpeed_AbilityCode)
    set st__RealAbilityBonus_Field[68]=CreateTrigger()
    call TriggerAddCondition(st__RealAbilityBonus_Field[68],Condition( function sa__BonusAttackSpeed_Field))
    call TriggerAddAction(st__RealAbilityBonus_Field[68], function sa__BonusAttackSpeed_Field)
    set st__IntegerAbilityBonus_AbilityCode[67]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[67],Condition( function sa__BonusIntelligence_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[67], function sa__BonusIntelligence_AbilityCode)
    set st__IntegerAbilityBonus_Field[67]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[67],Condition( function sa__BonusIntelligence_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[67], function sa__BonusIntelligence_Field)
    set st__IntegerAbilityBonus_AbilityCode[66]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[66],Condition( function sa__BonusStrength_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[66], function sa__BonusStrength_AbilityCode)
    set st__IntegerAbilityBonus_Field[66]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[66],Condition( function sa__BonusStrength_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[66], function sa__BonusStrength_Field)
    set st__IntegerAbilityBonus_AbilityCode[65]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[65],Condition( function sa__BonusAgility_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[65], function sa__BonusAgility_AbilityCode)
    set st__IntegerAbilityBonus_Field[65]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[65],Condition( function sa__BonusAgility_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[65], function sa__BonusAgility_Field)
    set st__IntegerAbilityBonus_AbilityCode[64]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[64],Condition( function sa__BonusSightRange_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[64], function sa__BonusSightRange_AbilityCode)
    set st__IntegerAbilityBonus_Field[64]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[64],Condition( function sa__BonusSightRange_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[64], function sa__BonusSightRange_Field)
    set st__IntegerAbilityBonus_AbilityCode[63]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[63],Condition( function sa__BonusMovementSpeed_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[63], function sa__BonusMovementSpeed_AbilityCode)
    set st__IntegerAbilityBonus_Field[63]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[63],Condition( function sa__BonusMovementSpeed_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[63], function sa__BonusMovementSpeed_Field)
    set st__IntegerAbilityBonus_AbilityCode[62]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[62],Condition( function sa__BonusArmor_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[62], function sa__BonusArmor_AbilityCode)
    set st__IntegerAbilityBonus_Field[62]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[62],Condition( function sa__BonusArmor_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[62], function sa__BonusArmor_Field)
    set st__IntegerAbilityBonus_AbilityCode[61]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_AbilityCode[61],Condition( function sa__BonusDamage_AbilityCode))
    call TriggerAddAction(st__IntegerAbilityBonus_AbilityCode[61], function sa__BonusDamage_AbilityCode)
    set st__IntegerAbilityBonus_Field[61]=CreateTrigger()
    call TriggerAddCondition(st__IntegerAbilityBonus_Field[61],Condition( function sa__BonusDamage_Field))
    call TriggerAddAction(st__IntegerAbilityBonus_Field[61], function sa__BonusDamage_Field)
    set st__CDR_onDestroy[59]=null
    set st__CDR_onDestroy[81]=null
    set st__HeroActionBase_updateAbilityDetails[96]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[96],Condition( function sa__HeroActionBase_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[96], function sa__HeroActionBase_updateAbilityDetails)
    set st__HeroActionBase_create=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_create,Condition( function sa__HeroActionBase_create))
    set st__MetroidvaniaController__ActionInterface_onDestroy[96]=null
    set st__MetroidvaniaController__ActionInterface_onDestroy[99]=null
    set st__MetroidvaniaController__ActionInterface_onDestroy[100]=null
    set st__MetroidvaniaController__ActionInterface_onDestroy[101]=null
    set st__MetroidvaniaController__ActionInterface_onDestroy[102]=null
    set st__MetroidvaniaController__ActionInterface_onDestroy[104]=null
    set st__Missiles_terminate=CreateTrigger()
    call TriggerAddCondition(st__Missiles_terminate,Condition( function sa__Missiles_terminate))
    set st__Missiles_reset=CreateTrigger()
    call TriggerAddCondition(st__Missiles_reset,Condition( function sa__Missiles_reset))
    set st__Missiles_move=CreateTrigger()
    call TriggerAddCondition(st__Missiles_move,Condition( function sa__Missiles_move))
    set st__Missiles_create=CreateTrigger()
    call TriggerAddCondition(st__Missiles_create,Condition( function sa__Missiles_create))
    set st__Missiles__MissileEvents_onDestroy[87]=null
    set st__Missiles__MissileEvents_onDestroy[98]=null
    set st__Missiles__MissileEvents_onDestroy[103]=null
    set st__Missiles__MissileEvents_onDestroy[105]=null
    set st__Missiles__MissileEvents_onFinish[105]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onFinish[105],Condition( function sa__FinalBossHoming_onFinish))
    call TriggerAddAction(st__Missiles__MissileEvents_onFinish[105], function sa__FinalBossHoming_onFinish)
    set st__Missiles__MissileEvents_onHit[105]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onHit[105],Condition( function sa__FinalBossHoming_onHit))
    call TriggerAddAction(st__Missiles__MissileEvents_onHit[105], function sa__FinalBossHoming_onHit)
    set st__Missiles__MissileEvents_onDestructable[105]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onDestructable[105],Condition( function sa__FinalBossHoming_onDestructable))
    call TriggerAddAction(st__Missiles__MissileEvents_onDestructable[105], function sa__FinalBossHoming_onDestructable)
    set st__Missiles__MissileEvents_onTerrain[105]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTerrain[105],Condition( function sa__FinalBossHoming_onTerrain))
    call TriggerAddAction(st__Missiles__MissileEvents_onTerrain[105], function sa__FinalBossHoming_onTerrain)
    set st__Missiles__MissileEvents_onTileset[105]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTileset[105],Condition( function sa__FinalBossHoming_onTileset))
    call TriggerAddAction(st__Missiles__MissileEvents_onTileset[105], function sa__FinalBossHoming_onTileset)
    set st__Missiles__MissileEvents_onFinish[98]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onFinish[98],Condition( function sa__HeroAttackBasic_onFinish))
    call TriggerAddAction(st__Missiles__MissileEvents_onFinish[98], function sa__HeroAttackBasic_onFinish)
    set st__Missiles__MissileEvents_onHit[98]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onHit[98],Condition( function sa__HeroAttackBasic_onHit))
    call TriggerAddAction(st__Missiles__MissileEvents_onHit[98], function sa__HeroAttackBasic_onHit)
    set st__Missiles__MissileEvents_onDestructable[98]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onDestructable[98],Condition( function sa__HeroAttackBasic_onDestructable))
    call TriggerAddAction(st__Missiles__MissileEvents_onDestructable[98], function sa__HeroAttackBasic_onDestructable)
    set st__Missiles__MissileEvents_onTerrain[98]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTerrain[98],Condition( function sa__HeroAttackBasic_onTerrain))
    call TriggerAddAction(st__Missiles__MissileEvents_onTerrain[98], function sa__HeroAttackBasic_onTerrain)
    set st__Missiles__MissileEvents_onTileset[98]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTileset[98],Condition( function sa__HeroAttackBasic_onTileset))
    call TriggerAddAction(st__Missiles__MissileEvents_onTileset[98], function sa__HeroAttackBasic_onTileset)
    set st__MetroidvaniaController__ActionInterface_animationSpeed[99]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_animationSpeed[99],Condition( function sa__HeroAttackBasicAction_animationSpeed))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_animationSpeed[99], function sa__HeroAttackBasicAction_animationSpeed)
    set st__HeroActionBase_updateAbilityDetails[99]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[99],Condition( function sa__HeroAttackBasicAction_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[99], function sa__HeroAttackBasicAction_updateAbilityDetails)
    set st__MetroidvaniaController__ActionInterface_onStart[99]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onStart[99],Condition( function sa__HeroAttackBasicAction_onStart))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onStart[99], function sa__HeroAttackBasicAction_onStart)
    set st__MetroidvaniaController__ActionInterface_onActionPoint[99]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onActionPoint[99],Condition( function sa__HeroAttackBasicAction_onActionPoint))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onActionPoint[99], function sa__HeroAttackBasicAction_onActionPoint)
    set st__MetroidvaniaController__ActionInterface_abilityText[99]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityText[99],Condition( function sa__HeroAttackBasicAction_abilityText))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityText[99], function sa__HeroAttackBasicAction_abilityText)
    set st__MetroidvaniaController__ActionInterface_abilityName[99]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityName[99],Condition( function sa__HeroAttackBasicAction_abilityName))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityName[99], function sa__HeroAttackBasicAction_abilityName)
    set st__MetroidvaniaController__ActionInterface_animationSpeed[100]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_animationSpeed[100],Condition( function sa__HeroAttackRapidAction_animationSpeed))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_animationSpeed[100], function sa__HeroAttackRapidAction_animationSpeed)
    set st__HeroActionBase_updateAbilityDetails[100]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[100],Condition( function sa__HeroAttackRapidAction_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[100], function sa__HeroAttackRapidAction_updateAbilityDetails)
    set st__MetroidvaniaController__ActionInterface_onStart[100]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onStart[100],Condition( function sa__HeroAttackRapidAction_onStart))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onStart[100], function sa__HeroAttackRapidAction_onStart)
    set st__MetroidvaniaController__ActionInterface_onActionPoint[100]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onActionPoint[100],Condition( function sa__HeroAttackRapidAction_onActionPoint))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onActionPoint[100], function sa__HeroAttackRapidAction_onActionPoint)
    set st__MetroidvaniaController__ActionInterface_abilityText[100]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityText[100],Condition( function sa__HeroAttackRapidAction_abilityText))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityText[100], function sa__HeroAttackRapidAction_abilityText)
    set st__MetroidvaniaController__ActionInterface_abilityName[100]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityName[100],Condition( function sa__HeroAttackRapidAction_abilityName))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityName[100], function sa__HeroAttackRapidAction_abilityName)
    set st__HeroActionBase_updateAbilityDetails[101]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[101],Condition( function sa__HeroBasicBombAction_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[101], function sa__HeroBasicBombAction_updateAbilityDetails)
    set st__MetroidvaniaController__ActionInterface_onStart[101]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onStart[101],Condition( function sa__HeroBasicBombAction_onStart))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onStart[101], function sa__HeroBasicBombAction_onStart)
    set st__HeroBasicBombAction_create=CreateTrigger()
    call TriggerAddCondition(st__HeroBasicBombAction_create,Condition( function sa__HeroBasicBombAction_create))
    set st__HeroBasicBombAction_getDamage=CreateTrigger()
    call TriggerAddCondition(st__HeroBasicBombAction_getDamage,Condition( function sa__HeroBasicBombAction_getDamage))
    set st__MetroidvaniaController__ActionInterface_abilityText[101]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityText[101],Condition( function sa__HeroBasicBombAction_abilityText))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityText[101], function sa__HeroBasicBombAction_abilityText)
    set st__MetroidvaniaController__ActionInterface_abilityName[101]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityName[101],Condition( function sa__HeroBasicBombAction_abilityName))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityName[101], function sa__HeroBasicBombAction_abilityName)
    set st__HeroActionBase_updateAbilityDetails[102]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[102],Condition( function sa__HeroBasicDash_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[102], function sa__HeroBasicDash_updateAbilityDetails)
    set st__MetroidvaniaController__ActionInterface_onStart[102]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onStart[102],Condition( function sa__HeroBasicDash_onStart))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onStart[102], function sa__HeroBasicDash_onStart)
    set st__MetroidvaniaController__ActionInterface_abilityText[102]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityText[102],Condition( function sa__HeroBasicDash_abilityText))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityText[102], function sa__HeroBasicDash_abilityText)
    set st__MetroidvaniaController__ActionInterface_abilityName[102]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityName[102],Condition( function sa__HeroBasicDash_abilityName))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityName[102], function sa__HeroBasicDash_abilityName)
    set st__Missiles__MissileEvents_onFinish[103]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onFinish[103],Condition( function sa__HeroShockBlast_onFinish))
    call TriggerAddAction(st__Missiles__MissileEvents_onFinish[103], function sa__HeroShockBlast_onFinish)
    set st__Missiles__MissileEvents_onHit[103]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onHit[103],Condition( function sa__HeroShockBlast_onHit))
    call TriggerAddAction(st__Missiles__MissileEvents_onHit[103], function sa__HeroShockBlast_onHit)
    set st__Missiles__MissileEvents_onDestructable[103]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onDestructable[103],Condition( function sa__HeroShockBlast_onDestructable))
    call TriggerAddAction(st__Missiles__MissileEvents_onDestructable[103], function sa__HeroShockBlast_onDestructable)
    set st__Missiles__MissileEvents_onTerrain[103]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTerrain[103],Condition( function sa__HeroShockBlast_onTerrain))
    call TriggerAddAction(st__Missiles__MissileEvents_onTerrain[103], function sa__HeroShockBlast_onTerrain)
    set st__Missiles__MissileEvents_onTileset[103]=CreateTrigger()
    call TriggerAddCondition(st__Missiles__MissileEvents_onTileset[103],Condition( function sa__HeroShockBlast_onTileset))
    call TriggerAddAction(st__Missiles__MissileEvents_onTileset[103], function sa__HeroShockBlast_onTileset)
    set st__HeroActionBase_updateAbilityDetails[104]=CreateTrigger()
    call TriggerAddCondition(st__HeroActionBase_updateAbilityDetails[104],Condition( function sa__InteractAction_updateAbilityDetails))
    call TriggerAddAction(st__HeroActionBase_updateAbilityDetails[104], function sa__InteractAction_updateAbilityDetails)
    set st__MetroidvaniaController__ActionInterface_onStart[104]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onStart[104],Condition( function sa__InteractAction_onStart))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onStart[104], function sa__InteractAction_onStart)
    set st__MetroidvaniaController__ActionInterface_onActionPoint[104]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_onActionPoint[104],Condition( function sa__InteractAction_onActionPoint))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_onActionPoint[104], function sa__InteractAction_onActionPoint)
    set st__MetroidvaniaController__ActionInterface_abilityText[104]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityText[104],Condition( function sa__InteractAction_abilityText))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityText[104], function sa__InteractAction_abilityText)
    set st__MetroidvaniaController__ActionInterface_abilityName[104]=CreateTrigger()
    call TriggerAddCondition(st__MetroidvaniaController__ActionInterface_abilityName[104],Condition( function sa__InteractAction_abilityName))
    call TriggerAddAction(st__MetroidvaniaController__ActionInterface_abilityName[104], function sa__InteractAction_abilityName)
    set st___prototype2[1]=CreateTrigger()
    call TriggerAddAction(st___prototype2[1],function sa___prototype2_DamageEngine_RegisterFromHook)
    call TriggerAddCondition(st___prototype2[1],Condition(function sa___prototype2_DamageEngine_RegisterFromHook))
    set st___prototype1[1]=CreateTrigger()
    call TriggerAddAction(st___prototype1[1],function sa___prototype1_TimerUtils__init)
    call TriggerAddCondition(st___prototype1[1],Condition(function sa___prototype1_TimerUtils__init))
    set st___prototype1[2]=CreateTrigger()
    call TriggerAddAction(st___prototype1[2],function sa___prototype1_KnockbackTZ__StartKnockback)
    call TriggerAddCondition(st___prototype1[2],Condition(function sa___prototype1_KnockbackTZ__StartKnockback))
    set st___prototype9[1]=CreateTrigger()
    call TriggerAddAction(st___prototype9[1],function sa___prototype9_MetroidvaniaController__controllerCallback)
    call TriggerAddCondition(st___prototype9[1],Condition(function sa___prototype9_MetroidvaniaController__controllerCallback))








call ExecuteFunc("s__UserMouse_MouseUtils__Init___onInit")

















































call ExecuteFunc("s__WorldBounds_WorldBounds__WorldBoundInit___onInit")



call ExecuteFunc("s__DummyRecycler__S_DummyRecycler__M___onInit")




















call ExecuteFunc("s__SpellEffectEvent__S_SpellEffectEvent__M___onInit")


























    call ExecuteFunc("s__Damage_onInit")
    call ExecuteFunc("s__CDR_onInit")
    call ExecuteFunc("s__BonusDamage_onInit")
    call ExecuteFunc("s__BonusArmor_onInit")
    call ExecuteFunc("s__BonusMovementSpeed_onInit")
    call ExecuteFunc("s__BonusSightRange_onInit")
    call ExecuteFunc("s__BonusAgility_onInit")
    call ExecuteFunc("s__BonusStrength_onInit")
    call ExecuteFunc("s__BonusIntelligence_onInit")
    call ExecuteFunc("s__BonusAttackSpeed_onInit")
    call ExecuteFunc("s__BonusHealthRegen_onInit")
    call ExecuteFunc("s__BonusManaRegen_onInit")
    call ExecuteFunc("s__BonusHealth_onInit")
    call ExecuteFunc("s__BonusMana_onInit")
    call ExecuteFunc("s__NewBonusUtils__NewBonusUtils_onInit")
    call ExecuteFunc("s__BonusSystemPower_onInit")
    call ExecuteFunc("s__BonusSystemSpeed_onInit")
    call ExecuteFunc("s__Missiles__Pool_onInit")
    call ExecuteFunc("s__KnockbackTZ_onInit")
    call ExecuteFunc("s__DestructableUpdater_onInit")
    call ExecuteFunc("s__MetroidvaniaController_onInit")
endfunction

